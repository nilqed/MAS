
<html>
<head>
<title>./masarith/SACI.md</title>
<meta name="generator" content="pas2html 0.9.2">
<meta name="date" content="1992-02-12T13:19:12+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80"><font color="#B22222">(* ----------------------------------------------------------------------------
 * $Id: SACI.md,v 1.2 1992/02/12 13:19:11 pesch Exp $
 * ----------------------------------------------------------------------------
 * This file is part of MAS.
 * ----------------------------------------------------------------------------
 * Copyright (c) 1989 - 1992 Universitaet Passau
 * ----------------------------------------------------------------------------
 * $Log: SACI.md,v $
 * Revision 1.2  1992/02/12  13:19:11  pesch
 * Moved CONST Definition to the right place.
 *
 * Revision 1.1  1992/01/22  15:08:14  kredel
 * Initial revision
 *
 * ----------------------------------------------------------------------------
 *)</font>

DEFINITION MODULE SACI;

<font color="#B22222">(* SAC Integer Definition Module. *)</font>



FROM MASSTOR IMPORT LIST;

<strong><font color="#228B22">CONST</font></strong> rcsid = "$Id: SACI.md,v 1.2 1992/02/12 13:19:11 pesch Exp $";
<strong><font color="#228B22">CONST</font></strong> copyright = "Copyright (c) 1989 - 1992 Universitaet Passau";


    
<strong><font color="#4169E1">PROCEDURE AADV</font></strong>(L: LIST; <strong><font color="#228B22">VAR</font></strong> AL,LP: LIST);
<font color="#B22222">(*Arithmetic advance.  L is a list.  If L ne () then a=FIRST(L) and
LP=RED(L).  Otherwise a=0 and LP=().*)</font>


<strong><font color="#4169E1">PROCEDURE IABSF</font></strong>(A: LIST): LIST;
<font color="#B22222">(*Integer absolute value function.  A is an integer.  B=ABS(A).*)</font>


<strong><font color="#4169E1">PROCEDURE ICOMP</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Integer comparison.  A and B are integers.  s=SIGN(A-B).*)</font>


<strong><font color="#4169E1">PROCEDURE IDEGCD</font></strong>(AL,BL: LIST; <strong><font color="#228B22">VAR</font></strong> CL,UL1,VL1,UL2,VL2: LIST);
<font color="#B22222">(*Integer doubly extended greatest common divisor algorithm.  a and b
are integers.  c=GCD(a,b).  a*u1+b*v1=c and a*u2+b*v2=0.
If a ne 0 and b ne 0 then ABS(u1) le ABS(b)/(2*c), ABS(v1) le
ABS(a)/(2*c), u2=-b/c and v2=a/c.  Otherwise u1=v2=SIGN(a),
v1=SIGN(b) and u2=-SIGN(b).*)</font>


<strong><font color="#4169E1">PROCEDURE IDIF</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Integer difference.  A and B are integers.  C=A-B.*)</font>


<strong><font color="#4169E1">PROCEDURE IDIPR2</font></strong>(A,B,AL,BL: LIST): LIST;
<font color="#B22222">(*Integer digit inner product, length 2.  A and B are integers.
a and b are beta-integers.  C=A*a+B*b.*)</font>


<strong><font color="#4169E1">PROCEDURE IDPR</font></strong>(A,BL: LIST): LIST;
<font color="#B22222">(*Integer-digit product.  A is an integer.  b is a beta-digit.
C=A*b.*)</font>


<strong><font color="#4169E1">PROCEDURE IDP2</font></strong>(A,KL: LIST): LIST;
<font color="#B22222">(*Integer division by power of 2.  A is an integer.  k is a
non-negative beta-digit.  B is the integral part of A/2**k.*)</font>


<strong><font color="#4169E1">PROCEDURE IDQ</font></strong>(A,BL: LIST): LIST;
<font color="#B22222">(*Integer-digit quotient.  A is an integer.  b is a non-zero
beta-digit.  C=INTEGER(A/b).*)</font>


<strong><font color="#4169E1">PROCEDURE IDQR</font></strong>(A,BL: LIST; <strong><font color="#228B22">VAR</font></strong> Q,RL: LIST);
<font color="#B22222">(*Integer-digit quotient and remainder.  A is an integer.  b is a
non-zero beta-digit.  Q is the integral part of A/b and r=A-b*Q.*)</font>


<strong><font color="#4169E1">PROCEDURE IDREM</font></strong>(A,BL: LIST): LIST;
<font color="#B22222">(*Integer-digit remainder.  A is an integer.  b is a non-zero
beta-digit.  r=A-b*INTEGER(A/b).*)</font>


<strong><font color="#4169E1">PROCEDURE IEGCD</font></strong>(AL,BL: LIST; <strong><font color="#228B22">VAR</font></strong> CL,UL1,VL1: LIST);
<font color="#B22222">(*Integer extended greatest common divisor algorithm.  a and b are
integers.  c=GCD(a,b).  a*u1+b*v1=c.  If a ne 0 and b ne 0
then ABS(u1) le ABS(b)/(2*c) and ABS(v1) le ABS(a)/(2*c).
Otherwise u1=SIGN(a) and v1=SIGN(b).*)</font>


<strong><font color="#4169E1">PROCEDURE IEVEN</font></strong>(A: LIST): BOOLEAN;
<font color="#B22222">(*Integer even.  A is an integer.  If A is even then true is returned 
and otherwise false. *)</font>


<strong><font color="#4169E1">PROCEDURE IEXP</font></strong>(A,NL: LIST): LIST;
<font color="#B22222">(*Integer exponentiation.  A is an integer.  n is a non-negative
beta-integer.  B=A**n.*)</font>


<strong><font color="#4169E1">PROCEDURE IFCL2</font></strong>(AL: LIST; <strong><font color="#228B22">VAR</font></strong> ML,NL: LIST);
<font color="#B22222">(*Integer, floor and ceiling, logarithm, base 2.  a is a non-zero
integer.  m and n, gamma-integers, are the floor and ceiling of
LOG2(ABS(a)) respectively.*)</font>


<strong><font color="#4169E1">PROCEDURE IGCD</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Integer greatest common divisor.  A and B are integers.  C=GCD(A,B).*)</font>


<strong><font color="#4169E1">PROCEDURE IGCDCF</font></strong>(A,B: LIST; <strong><font color="#228B22">VAR</font></strong> C,AB,BB: LIST);
<font color="#B22222">(*Integer greatest common divisor and cofactors.  A and B are integers.
C eq GCD(A,B).  If C eq 0 then AB eq BB eq 0 and otherwise
AB eq A/C,BB eq B/C.*)</font>


<strong><font color="#4169E1">PROCEDURE IHEGCD</font></strong>(A,B: LIST; <strong><font color="#228B22">VAR</font></strong> C,V: LIST);
<font color="#B22222">(*Integer half-extended greatest common divisor.  A and B are integers.
C=GCD(A,B).  If A ne 0, B*V=C(mod A), with ABS(V) le ABS(A)/2C.  If
A=0,V=SIGN(B).*)</font>


<strong><font color="#4169E1">PROCEDURE ILCM</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Integer least common multiple.  A and B are integers.
C=LCM(A,B), a nonnegative integer.*)</font>


<strong><font color="#4169E1">PROCEDURE ILCOMB</font></strong>(A,B,UL,VL: LIST): LIST;
<font color="#B22222">(*Integer linear combination.  A and B are non-negative integers.
u and v are beta-integers such that A*u+B*v ge 0.  C=A*u+B*v.*)</font>


<strong><font color="#4169E1">PROCEDURE ILOG2</font></strong>(A: LIST): LIST;
<font color="#B22222">(*Integer logarithm, base 2.  A is an integer.  If A=0 then n=0.
Otherwise n=FLOOR(LOG2(ABS(A)))+1, a beta-integer.*)</font>


<strong><font color="#4169E1">PROCEDURE ILWRIT</font></strong>(L: LIST);
<font color="#B22222">(*Integer list write.  L is a list of integers.  The list L is written
in the output stream.*)</font>


<strong><font color="#4169E1">PROCEDURE IMAX</font></strong>(AL,BL: LIST): LIST;
<font color="#B22222">(*Integer maximum.  a and b are integers.  c is the maximum of a
and b.*)</font>


<strong><font color="#4169E1">PROCEDURE IMIN</font></strong>(AL,BL: LIST): LIST;
<font color="#B22222">(*Integer minimum.  a and b are integers.  c is the minimum of a
and b.*)</font>


<strong><font color="#4169E1">PROCEDURE IMP2</font></strong>(A,HL: LIST): LIST;
<font color="#B22222">(*Integer multiplication by power of 2.  A is an integer.  h is a
non-negative beta-integer.  B=A*(2**h).*)</font>


<strong><font color="#4169E1">PROCEDURE INEG</font></strong>(A: LIST): LIST;
<font color="#B22222">(*Integer negation.  A is an integer.  B=-A.*)</font>


<strong><font color="#4169E1">PROCEDURE IODD</font></strong>(A: LIST): BOOLEAN;
<font color="#B22222">(*Integer odd.  A is an integer.  If a is odd then true is returned
and otherwise false. *)</font>


<strong><font color="#4169E1">PROCEDURE IORD2</font></strong>(AL: LIST): LIST;
<font color="#B22222">(*Integer, order of 2.  a is a non-zero integer.  n is the largest
integer such that 2**n divides a.*)</font>


<strong><font color="#4169E1">PROCEDURE IPOWER</font></strong>(A,L: LIST; <strong><font color="#228B22">VAR</font></strong> B,NL: LIST);
<font color="#B22222">(*Integer power.  A, greater than or equal to 3, is an odd positive
integer.  L is a list (p(1),p(2), ...,p(k)) of the first k prime
numbers, with p(k) greater than or equal to the base 3 logarithm of A.
If A=B**m for some m greater than or equal to 2 then n is the least
such m and B=A**(1/n).  Otherwise B=0 and n=0.*)</font>


<strong><font color="#4169E1">PROCEDURE IPROD</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Integer product.  A and B are integers.  C=A*B.*)</font>


<strong><font color="#4169E1">PROCEDURE IPRODK</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Integer product, Karatsuba algorithm.  A and B are integers.  C=A*B.*)</font>


<strong><font color="#4169E1">PROCEDURE IQ</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Integer quotient.  A and B are integers, B ne 0.  C is the integral
part of A/B.*)</font>


<strong><font color="#4169E1">PROCEDURE IQR</font></strong>(A,B: LIST; <strong><font color="#228B22">VAR</font></strong> Q,R: LIST);
<font color="#B22222">(*Integer quotient and remainder.  A and B are integers, B ne 0.  Q is
the quotient, integral part of A/B, and R is the remainder A-B*Q.*)</font>


<strong><font color="#4169E1">PROCEDURE IRAND</font></strong>(NL: LIST): LIST;
<font color="#B22222">(*Integer, random.  n is a positive beta-integer.  A is an integer
with random sign and random absolute value less than 2**n.*)</font>


<strong><font color="#4169E1">PROCEDURE IREAD</font></strong>(): LIST;
<font color="#B22222">(*Integer read.  The integer A is read from the input stream.  Any
preceding blanks are skipped.*)</font>


<strong><font color="#4169E1">PROCEDURE IREM</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Integer remainder.  A and B are integers, B non-zero.  C is the
remainder of A and B.*)</font>


<strong><font color="#4169E1">PROCEDURE IROOT</font></strong>(A,NL: LIST; <strong><font color="#228B22">VAR</font></strong> B,TL: LIST);
<font color="#B22222">(*Integer root.  A is a positive integer.  n, greater than or equal
to 2, is a beta-integer.  B=FLOOR(A**(1/n)) and t=SIGN(A-B**n).*)</font>


<strong><font color="#4169E1">PROCEDURE ISEG</font></strong>(A,NL: LIST; <strong><font color="#228B22">VAR</font></strong> A1,A0: LIST);
<font color="#B22222">(*Integer segmentation.  A is an integer.  n is a positive beta-
integer.  A1 is the integral part of A/beta**n.  A0=A-A1*beta**n.*)</font>


<strong><font color="#4169E1">PROCEDURE ISIGNF</font></strong>(A: LIST): LIST;
<font color="#B22222">(*Integer sign function.  A is an integer.  s=SIGN(A).*)</font>


<strong><font color="#4169E1">PROCEDURE ISQRT</font></strong>(A: LIST; <strong><font color="#228B22">VAR</font></strong> B,TL: LIST);
<font color="#B22222">(*Integer square root.  A is a non-negative integer.  B is the floor
function of the square root of A and t is the sign of A-B*B.*)</font>


<strong><font color="#4169E1">PROCEDURE ISSUM</font></strong>(NL,L: LIST): LIST;
<font color="#B22222">(*Integer shifted sum.  n is a positive integer.  L is a list
(c(0),c(1), ...,c(k)), k non-negative, of integers c(i) with
ABS(c(i)) less than beta**(2*n+1).  Either each c(i) is
non-negative or each c(i) is non-positive.  C is the sum on i,
from 0 to k, of c(i)*(beta**(i*n)).*)</font>


<strong><font color="#4169E1">PROCEDURE ISUM</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Integer sum.  A and B are integers.  C=A+B.*)</font>


<strong><font color="#4169E1">PROCEDURE ITRUNC</font></strong>(A,NL: LIST): LIST;
<font color="#B22222">(*Integer truncation.  A is an integer.  n is a beta-integer.
B=INTEGER(A/2**n).*)</font>


<strong><font color="#4169E1">PROCEDURE IWRITE</font></strong>(A: LIST);
<font color="#B22222">(*Integer write.  The input integer A is converted to decimal and
written in the output stream.*)</font>


<strong><font color="#4169E1">END</font></strong> SACI.


<font color="#B22222">(* -EOF- *)</font>
</pre>
</body>

</html>
