
<html>
<head>
<title>./maslisp/MASSYM2.mi</title>
<meta name="generator" content="pas2html 0.9.2">
<meta name="date" content="1993-05-11T13:40:06+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80"><font color="#B22222">(* ----------------------------------------------------------------------------
 * $Id: MASSYM2.mi,v 1.5 1993/05/11 10:48:59 kredel Exp $
 * ----------------------------------------------------------------------------
 * This file is part of MAS.
 * ----------------------------------------------------------------------------
 * Copyright (c) 1989 - 1992 Universitaet Passau
 * ----------------------------------------------------------------------------
 * $Log: MASSYM2.mi,v $
 * Revision 1.5  1993/05/11  10:48:59  kredel
 * Small changes in STINS
 *
 * Revision 1.4  1992/10/16  13:53:40  kredel
 * Errors found by Mocka corrected
 *
 * Revision 1.3  1992/10/15  16:27:54  kredel
 * Changed rcsid variable
 *
 * Revision 1.2  1992/02/12  17:32:33  pesch
 * Moved CONST definition to the right place
 *
 * Revision 1.1  1992/01/22  15:11:30  kredel
 * Initial revision
 *
 * ----------------------------------------------------------------------------
 *)</font>

IMPLEMENTATION MODULE MASSYM2;

<font color="#B22222">(* MAS/SAC Symbol System Implementation module 2. *)</font>


<font color="#B22222">(* Version: HASH-TABLE with AVL-TREEs for Symboltable *)</font>


<font color="#B22222">(* Import lists and declarations. *)</font>

FROM MASELEM IMPORT GAMMAINT, MASEXP, MASQREM, MASREM;

FROM MASSTOR IMPORT BETA, SIL, LIST, LISTVAR, 
                    LENGTH, SFIRST, SRED,
                    LIST1, INV, ADV, FIRST, RED, COMP;

FROM MASBIOS IMPORT BLINES, CREAD, CWRITE, CREADB,
                    DIGIT, LETTER, LISTS,
                    MASORD, GWRITE, DIBUFF,
                    CHI, BKSP, SWRITE, TAB;

FROM SACLIST IMPORT CLOUT, ADV2, CONC, COMP2, EQUAL, 
                    SECOND, RED2, AWRITE, AREAD,  SLELT,ADV3;


<strong><font color="#228B22">CONST</font></strong> rcsidi = "$Id: MASSYM2.mi,v 1.5 1993/05/11 10:48:59 kredel Exp $";
<strong><font color="#228B22">CONST</font></strong> copyrighti = "Copyright (c) 1989 - 1992 Universitaet Passau";

<strong><font color="#228B22">CONST</font></strong> ICOUNT = 1; <font color="#B22222">(* ? *)</font>

<strong><font color="#228B22">VAR</font></strong> NAM, SBASE: GAMMAINT;

<strong><font color="#228B22">VAR</font></strong> newIns: BOOLEAN;


<strong><font color="#4169E1">PROCEDURE ACOMP</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Alphabetic comparison. A and B are symbols. t=+1,0,-1 according
to whether A preceds, is equal, or follows B alphabetically.*)</font>
<strong><font color="#228B22">VAR</font></strong>  TL: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> TL:=ACOMP1(NAME(A),NAME(B));
<font color="#B22222">(*4*)</font> RETURN(TL); <strong><font color="#4169E1">END</font></strong> ACOMP;


<strong><font color="#4169E1">PROCEDURE ACOMP1</font></strong>(A,B: LIST): LIST;
<font color="#B22222">(*Alphabetic comparison, 1. subalgorithm. A and B are packed strings.
s=-1,0,1 according to whether a preceds, is equal, or succeeds B
alphabetically.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AL, AP, BL, BP, SL: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> AP:=A; BP:=B; SL:=0;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*compare.*)</font>
      <font color="#4169E1">REPEAT</font> ADV(AP, AL,AP); ADV(BP, BL,BP);
             <font color="#4169E1">IF</font> AL &gt; BL <font color="#4169E1">THEN</font> SL:=1; <font color="#4169E1">ELSE</font>
                <font color="#4169E1">IF</font> AL &lt; BL <font color="#4169E1">THEN</font> SL:=-1; <strong><font color="#4169E1">END</font></strong>;
                <strong><font color="#4169E1">END</font></strong>;
             <font color="#4169E1">IF</font> SL &lt;&gt; 0 <font color="#4169E1">THEN</font> RETURN(SL); <strong><font color="#4169E1">END</font></strong>;
             <font color="#4169E1">UNTIL</font> (AP = SIL) <font color="#4169E1">OR</font> (BP = SIL);
<font color="#B22222">(*3*)</font> <font color="#B22222">(*end.*)</font>
      <font color="#4169E1">IF</font> BP &lt;&gt; SIL <font color="#4169E1">THEN</font> SL:=-1; <font color="#4169E1">ELSE</font>
         <font color="#4169E1">IF</font> AP &lt;&gt; SIL <font color="#4169E1">THEN</font> SL:=1; <strong><font color="#4169E1">END</font></strong>;
         <strong><font color="#4169E1">END</font></strong>;
      RETURN(SL);
<font color="#B22222">(*6*)</font> <strong><font color="#4169E1">END</font></strong> ACOMP1;


<strong><font color="#4169E1">PROCEDURE ASSOC</font></strong>(AL,L: LIST): LIST;
<font color="#B22222">(*Associate. L=(a1 b1, a2 b2, ...,a sub n b sub n), n ge 0,
a is an object. If there is an i such that a=a sub i then
P=(b sub i, ...,a sub n b sub n), otherwise P=().*)</font>
<strong><font color="#228B22">VAR</font></strong>  ALP, P: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> P:=L;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*search.*)</font>
      <font color="#4169E1">WHILE</font> P &lt;&gt; SIL <font color="#4169E1">DO</font> ADV(P, ALP,P);
            <font color="#4169E1">IF</font> AL = ALP <font color="#4169E1">THEN</font> RETURN(P); <strong><font color="#4169E1">END</font></strong>;
            ADV(P, ALP,P); <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*5*)</font> RETURN(P); <strong><font color="#4169E1">END</font></strong> ASSOC;


<strong><font color="#4169E1">PROCEDURE ASSOCQ</font></strong>(AL,L: LIST): LIST;
<font color="#B22222">(*Associate equal. L=(a1 b1, a2 b2, ...,a sub n b sub n), n ge 0,
a is an object. If there is an i such that a is equal to a sub i then
P=(b sub i, ...,a sub n b sub n), otherwise P=().*)</font>
<strong><font color="#228B22">VAR</font></strong>  ALP, P: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> P:=L;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*search.*)</font>
      <font color="#4169E1">WHILE</font> P &lt;&gt; SIL <font color="#4169E1">DO</font> ADV(P, ALP,P);
            <font color="#4169E1">IF</font> EQUAL(AL,ALP) = 1 <font color="#4169E1">THEN</font> RETURN(P); <strong><font color="#4169E1">END</font></strong>;
            ADV(P, ALP,P); <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*5*)</font> RETURN(P); <strong><font color="#4169E1">END</font></strong> ASSOCQ;


<strong><font color="#4169E1">PROCEDURE ATTRIB</font></strong>(L: LIST): LIST;
<font color="#B22222">(*Attribute. L is a symbol. Returns the attributes of L.*)</font>
<strong><font color="#228B22">VAR</font></strong>  LP: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> LP:=SIL;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*symbol.*)</font> <font color="#4169E1">IF</font> SYMBOL(L) <font color="#4169E1">THEN</font> LP:=RED2(L) <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*5*)</font> RETURN(LP); <strong><font color="#4169E1">END</font></strong> ATTRIB;


<strong><font color="#4169E1">PROCEDURE BEGINU</font></strong>();
<font color="#B22222">(*Begin, universal. The symbolic system is initialized without
initializing any subsystems. It is assumed, that at least BEGIN1
was called previously.*)</font>
<strong><font color="#228B22">VAR</font></strong>  CL, NL, TL: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize symbolic globals.*)</font> SYMTB:=SIL; 
      NL:=0; CL:=CHI+1; TL:=BETA DIV CL;
      <font color="#4169E1">REPEAT</font> TL:=TL DIV CL; NL:=NL+1;
             <font color="#4169E1">UNTIL</font> TL = 0;
      SBASE:=MASEXP(CL,NL);
<font color="#B22222">(*2*)</font> <font color="#B22222">(*translator options.*)</font> TRMAX:=10; COUNT:=0; NAM:=0;
<font color="#B22222">(*3*)</font> <font color="#B22222">(*hiding type.*)</font> NOSHOW:=ENTER(LISTS("NOSHOW"));
<font color="#B22222">(*5*)</font> RETURN; <strong><font color="#4169E1">END</font></strong> BEGINU;


<strong><font color="#4169E1">PROCEDURE EXPLOD</font></strong>(S: LIST): LIST;
<font color="#B22222">(*Explode symbol. S is a symbol, L its character list.*)</font>
<strong><font color="#228B22">VAR</font></strong>  A, AP, CL, DL, J1Y, L, LP, Q: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*get packed character list.*)</font> LP:=NAME(S); L:=SIL; CL:=CHI+1;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*unpack characters.*)</font>
      <font color="#4169E1">REPEAT</font> DL:=SBASE DIV CL; ADV(LP, A,LP);
             <font color="#4169E1">REPEAT</font> MASQREM(A,DL, Q,AP); A:=AP; J1Y:=Q-1; 
                    L:=COMP(J1Y,L); DL:=DL DIV CL;
                    <font color="#4169E1">UNTIL</font> A = 0;
             <font color="#4169E1">UNTIL</font> LP = SIL;
<font color="#B22222">(*3*)</font> <font color="#B22222">(*exit*)</font> L:=INV(L);
<font color="#B22222">(*6*)</font> RETURN(L); <strong><font color="#4169E1">END</font></strong> EXPLOD;


<strong><font color="#4169E1">PROCEDURE ENTER</font></strong>(L: LIST): LIST;
<font color="#B22222">(*Enter into symbol table. L is a character list, S the pointer
to the corresponding symbol. If the symbol is not yet in the
symbol table SYMTB, then a new node is created.*)</font>
<strong><font color="#228B22">VAR</font></strong>  J1Y, S: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> J1Y:=PACK(L); S:=STINS(J1Y);
<font color="#B22222">(*4*)</font> RETURN(S); <strong><font color="#4169E1">END</font></strong> ENTER;


<strong><font color="#4169E1">PROCEDURE GENSYM</font></strong>(): LIST;
<font color="#B22222">(*Generate symbol. S is a newly generated symbol. NAM is advanced.*)</font>
<strong><font color="#228B22">VAR</font></strong>  J1Y, Q, S: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*increase counter.*)</font> NAM:=NAM+1;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*create character list.*)</font> S:=LIST1(MASORD("Y")); Q:=NAM;
      <font color="#4169E1">REPEAT</font> J1Y:=MASREM(Q,10); S:=COMP(J1Y,S); Q:=Q DIV 10;
             <font color="#4169E1">UNTIL</font> Q = 0;
<font color="#B22222">(*3*)</font> <font color="#B22222">(*enter in symbol table.*)</font> J1Y:=COMP(MASORD("J"),S);
      S:=ENTER(J1Y);
<font color="#B22222">(*6*)</font> RETURN(S); <strong><font color="#4169E1">END</font></strong> GENSYM;


<strong><font color="#4169E1">PROCEDURE GET</font></strong>(S,AL: LIST): LIST;
<font color="#B22222">(*Get property. The property list of the symbol S is searched
under indicator a. A is the property under a, if any, otherwise
A is set to beta.*)</font>
<strong><font color="#228B22">VAR</font></strong>  A: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> A:=ASSOC(AL,ATTRIB(S));
      <font color="#4169E1">IF</font> A &lt;&gt; SIL <font color="#4169E1">THEN</font> A:=FIRST(A) <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*4*)</font> RETURN(A) <strong><font color="#4169E1">END</font></strong> GET;


<strong><font color="#4169E1">PROCEDURE NAME</font></strong>(L: LIST): LIST;
<font color="#B22222">(*Name. L is a symbol. Returns the name of L.*)</font>
<strong><font color="#228B22">VAR</font></strong>  LP: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> LP:=SIL;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*symbol.*)</font> <font color="#4169E1">IF</font> SYMBOL(L) <font color="#4169E1">THEN</font> LP:=SECOND(L) <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*5*)</font> RETURN(LP); <strong><font color="#4169E1">END</font></strong> NAME;


<strong><font color="#4169E1">PROCEDURE PACK</font></strong>(L: LIST): LIST;
<font color="#B22222">(*Pack character list. L is a non-empty character list. B is the
packed list.*)</font>
<strong><font color="#228B22">VAR</font></strong>  A, B, BL, CL, DL, J1Y, LP: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> LP:=L; B:=SIL; BL:=CHI+1; A:=0; DL:=1;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*process characters.*)</font>
      <font color="#4169E1">REPEAT</font> ADV(LP, CL,LP);
             <font color="#4169E1">IF</font> DL = SBASE <font color="#4169E1">THEN</font> B:=COMP(A,B); A:=0; DL:=1; <strong><font color="#4169E1">END</font></strong>;
             DL:=DL*BL; J1Y:=A*BL; J1Y:=J1Y+CL; A:=J1Y+1;
             <font color="#4169E1">UNTIL</font> LP = SIL;
<font color="#B22222">(*3*)</font> <font color="#B22222">(*shift left and invert.*)</font>
      <font color="#4169E1">WHILE</font> DL &lt; SBASE <font color="#4169E1">DO</font> DL:=DL*BL; A:=A*BL; <strong><font color="#4169E1">END</font></strong>;
      J1Y:=COMP(A,B); B:=INV(J1Y);
<font color="#B22222">(*6*)</font> RETURN(B); <strong><font color="#4169E1">END</font></strong> PACK;


<strong><font color="#4169E1">PROCEDURE PUT</font></strong>(S,AL,A: LIST);
<font color="#B22222">(*Put. The property A is stored on the property list of
the symbol S under the indicator a.*)</font>
<strong><font color="#228B22">VAR</font></strong>  L: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*already there.*)</font> L:=ASSOC(AL,ATTRIB(S));
      <font color="#4169E1">IF</font> L &lt;&gt; SIL <font color="#4169E1">THEN</font> SFIRST(L,A); RETURN; <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*new entry.*)</font> SRED(RED(S),COMP2(AL,A,ATTRIB(S)));
<font color="#B22222">(*5*)</font> RETURN; <strong><font color="#4169E1">END</font></strong> PUT;


<strong><font color="#4169E1">PROCEDURE REMPRP</font></strong>(S,AL: LIST);
<font color="#B22222">(*Remove property. Under indicator a on the property list of
symbol S the property is removed.*)</font>
<strong><font color="#228B22">VAR</font></strong>  BL, L, LP: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> L:=RED(S); LP:=RED(L);
<font color="#B22222">(*2*)</font> <font color="#B22222">(*search and remove.*)</font>
      <font color="#4169E1">WHILE</font> LP &lt;&gt; SIL <font color="#4169E1">DO</font> ADV(LP, BL,LP);
            <font color="#4169E1">IF</font> AL = BL <font color="#4169E1">THEN</font> SRED(L,RED(LP)); RETURN <strong><font color="#4169E1">END</font></strong>;
            L:=LP; LP:=RED(LP) <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*5*)</font> RETURN <strong><font color="#4169E1">END</font></strong> REMPRP;


<strong><font color="#4169E1">PROCEDURE SMEMB</font></strong>(S,L: LIST): LIST;
<font color="#B22222">(*Symbol membership. S is a symbol, L a list containing possibly
also symbols. b=1 if S or a copy of S occurs in L, b=0 otherwise.*)</font>
<strong><font color="#228B22">VAR</font></strong>  BL, LP, SP, SS: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initilize.*)</font> LP:=L; BL:=1; SP:=SECOND(S);
<font color="#B22222">(*2*)</font> <font color="#B22222">(*search.*)</font>
      <font color="#4169E1">WHILE</font> LP &lt;&gt; SIL <font color="#4169E1">DO</font> ADV(LP, SS,LP);
            <font color="#4169E1">IF</font> SYMBOL(SS) <font color="#4169E1">AND</font> (ACOMP1(NAME(SS),SP) = 0)
               <font color="#4169E1">THEN</font> RETURN(BL) <strong><font color="#4169E1">END</font></strong>;
            <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*3*)</font> <font color="#B22222">(*exit.*)</font> BL:=0;
<font color="#B22222">(*6*)</font> RETURN(BL) <strong><font color="#4169E1">END</font></strong> SMEMB;


<strong><font color="#4169E1">PROCEDURE SREAD</font></strong>(): LIST;
<font color="#B22222">(*Symbol read. The next symbol is read from input. S is the symbol in
the symbol table SYMTB.*)</font>
<strong><font color="#228B22">VAR</font></strong>  J1Y, S: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> J1Y:=SREAD1(); S:=ENTER(J1Y);
<font color="#B22222">(*4*)</font> RETURN(S); <strong><font color="#4169E1">END</font></strong> SREAD;


<strong><font color="#4169E1">PROCEDURE SREAD1</font></strong>(): LIST;
<font color="#B22222">(*Symbol read, 1. The first non-alphanumeric character of the
input stream terminates the symbol.  L is the character list of
the symbol, which is not entered in the symbol table.*)</font>
<strong><font color="#228B22">VAR</font></strong>  C, L: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*skip leading blanks.*)</font> L:=SIL; C:=CREADB();
      <font color="#4169E1">IF</font> <font color="#4169E1">NOT</font> LETTER(C) <font color="#4169E1">THEN</font> SWRITE("No symbol found by SREAD1");
         DIBUFF; L:=LISTS("???"); RETURN(L) <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*collect characters.*)</font>
      <font color="#4169E1">REPEAT</font> L:=COMP(C,L); C:=CREAD();
             <font color="#4169E1">UNTIL</font> <font color="#4169E1">NOT</font> DIGIT(C) <font color="#4169E1">AND</font> <font color="#4169E1">NOT</font> LETTER(C);
      BKSP; L:=INV(L);
<font color="#B22222">(*5*)</font> RETURN(L); <strong><font color="#4169E1">END</font></strong> SREAD1;


<strong><font color="#4169E1">PROCEDURE SYMBOL</font></strong>(AP: LIST): BOOLEAN;
<font color="#B22222">(*Symbol. AP is an object. Returns true if it is a symbol and
false else.*)</font>
<strong><font color="#228B22">VAR</font></strong>  BL: BOOLEAN;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> BL:=FALSE;
      <font color="#4169E1">IF</font> AP &gt; BETA <font color="#4169E1">THEN</font>
         <font color="#4169E1">IF</font> FIRST(AP) = -BETA <font color="#4169E1">THEN</font> BL:=TRUE <strong><font color="#4169E1">END</font></strong>
         <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*4*)</font> RETURN(BL); <strong><font color="#4169E1">END</font></strong> SYMBOL;


<strong><font color="#4169E1">PROCEDURE SYNEW</font></strong>(L: LIST): LIST;
<font color="#B22222">(*Symbol new. L is a packed character list.*)</font>
<strong><font color="#228B22">VAR</font></strong>  S: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> S:=COMP(-BETA,COMP(L,SIL));
<font color="#B22222">(*4*)</font> RETURN(S); <strong><font color="#4169E1">END</font></strong> SYNEW;


<strong><font color="#4169E1">PROCEDURE SymSummary</font></strong>();
<font color="#B22222">(*Summary of symbol system. The number of symbols in SYMTB and
the number of their properties is written.*)</font>
<strong><font color="#228B22">VAR</font></strong>   P, S: LIST;
      i: CARDINAL;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(* 
(*0*)</font> <font color="#B22222">(*test.*)</font> BLINES(2);
      SWRITE("SYMTBarr = "); BLINES(1); 
      <font color="#4169E1">FOR</font> i:=0 <font color="#4169E1">TO</font> maxtab <font color="#4169E1">DO</font> 
          SWRITE("["); AWRITE(i); SWRITE("] = "); 
          UWRITE(SYMTBarr[i]); 
          <font color="#4169E1">IF</font> SYMTBarr[i] &lt; SIL <font color="#4169E1">THEN</font> SYMTBarr[i]:=SIL <strong><font color="#4169E1">END</font></strong>;  
          <strong><font color="#4169E1">END</font></strong>;
      *)
<font color="#B22222">(*1*)</font> <font color="#B22222">(*count symbols and their properties.*)</font> BLINES(2);
      STCNT(SYMTB,S,P);                      <font color="#B22222">(* SYMTB dummy ! *)</font>
      AWRITE(S); SWRITE(" symbols <font color="#4169E1">and</font> ");
      AWRITE(P); SWRITE(" properties."); BLINES(1);
      <font color="#B22222">(*debug*)</font>
      STWRT(SYMTB);                          <font color="#B22222">(* SYMTB dummy ! *)</font>
      <font color="#B22222">(*gubed*)</font>
<font color="#B22222">(*5*)</font> <strong><font color="#4169E1">END</font></strong> SymSummary;


<strong><font color="#4169E1">PROCEDURE SYWRIT</font></strong>(S: LIST);
<font color="#B22222">(*Symbol write. The symbol S is written in the output stream.*)</font>
<strong><font color="#228B22">VAR</font></strong>  N, L: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*get unpacked name.*)</font> N:=EXPLOD(S);
<font color="#B22222">(*2*)</font> <font color="#B22222">(*transmit.*)</font> CLOUT(N);
<font color="#B22222">(*5*)</font> <strong><font color="#4169E1">END</font></strong> SYWRIT;


<strong><font color="#4169E1">PROCEDURE SUBLIS</font></strong>(L,A: LIST): LIST;
<font color="#B22222">(*Substitution with list. L=(x1 e1, ...,x sub n e sub n),
a and e sub i are objects. The x sub i are beta-digits
or pointers to uniquely stored lists like symbols. B is A
with the x sub i substituted by the e sub i.*)</font>
<strong><font color="#228B22">VAR</font></strong>  B, C1, C2, J1Y, J2Y: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*basis.*)</font> B:=ASSOC(A,L);
      <font color="#4169E1">IF</font> B &lt;&gt; SIL <font color="#4169E1">THEN</font> B:=FIRST(B); RETURN(B); <strong><font color="#4169E1">END</font></strong>;
      <font color="#4169E1">IF</font> (A &lt;= BETA) <font color="#4169E1">OR</font> SYMBOL(A) <font color="#4169E1">THEN</font> B:=A; RETURN(B); <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*recursion.*)</font> ADV(A, C1,C2); J1Y:=SUBLIS(L,C1);
      J2Y:=SUBLIS(L,C2); B:=COMP(J1Y,J2Y);
<font color="#B22222">(*5*)</font> RETURN(B); <strong><font color="#4169E1">END</font></strong> SUBLIS;


<strong><font color="#4169E1">PROCEDURE UREAD</font></strong>(): LIST;
<font color="#B22222">(*Universal read. The next atom, symbol, string or list over atoms, 
strings and symbols is read and stored under L. Blanks may occur 
anywhere. Elements of a list may or may not be separated by a comma.*)</font>
<strong><font color="#228B22">VAR</font></strong>   C, J1Y, L: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*BRANCH ON C.*)</font> L:=SIL; C:=CREADB();
      <font color="#4169E1">IF</font> DIGIT(C) <font color="#4169E1">OR</font> (C = MASORD("-")) <font color="#4169E1">OR</font> (C = MASORD("+")) <font color="#4169E1">THEN</font> 
         BKSP; L:=AREAD(); RETURN(L) <strong><font color="#4169E1">END</font></strong>;
      <font color="#4169E1">IF</font> LETTER(C) <font color="#4169E1">THEN</font> BKSP; L:=SREAD(); RETURN(L) <strong><font color="#4169E1">END</font></strong>;
      <font color="#4169E1">IF</font> C = MASORD(<font color="#666666">'"'</font>) <font color="#4169E1">THEN</font> 
         LOOP C:=CREAD();
              <font color="#4169E1">IF</font> C = MASORD(<font color="#666666">'"'</font>) <font color="#4169E1">THEN</font> C:=CREAD();
                 <font color="#4169E1">IF</font> C &lt;&gt; MASORD(<font color="#666666">'"'</font>) <font color="#4169E1">THEN</font> BKSP; EXIT <strong><font color="#4169E1">END</font></strong>; 
                 <strong><font color="#4169E1">END</font></strong>;
              L:=COMP(C,L);
              <strong><font color="#4169E1">END</font></strong>;
         L:=INV(L); RETURN(L) <strong><font color="#4169E1">END</font></strong>;
      <font color="#4169E1">IF</font> C &lt;&gt; MASORD("(") <font color="#4169E1">THEN</font>
         SWRITE("Atoms, strings, symbols, <font color="#4169E1">or</font> lists expected by UREAD, ");
         CWRITE(C); SWRITE(" found."); DIBUFF; RETURN(0) <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*2*)</font> <font color="#B22222">(*READ LIST.*)</font> C:=CREADB();
      <font color="#4169E1">IF</font> C = MASORD(")") <font color="#4169E1">THEN</font> RETURN(L); <strong><font color="#4169E1">END</font></strong>;
      BKSP;
      LOOP J1Y:=UREAD(); L:=COMP(J1Y,L); C:=CREADB();
           <font color="#4169E1">IF</font> C = MASORD(")") <font color="#4169E1">THEN</font> L:=INV(L); RETURN(L) <strong><font color="#4169E1">END</font></strong>; 
           <font color="#4169E1">IF</font> C &lt;&gt; MASORD(",") <font color="#4169E1">THEN</font> BKSP; <strong><font color="#4169E1">END</font></strong>;
           <strong><font color="#4169E1">END</font></strong>;
<font color="#B22222">(*5*)</font> <strong><font color="#4169E1">END</font></strong> UREAD;


<strong><font color="#4169E1">PROCEDURE UWRITE</font></strong>(L: LIST);
<font color="#B22222">(*Universal write. L is an atom, symbol or a list over
atoms and symbols. L is written in the output stream,
followed by BLINES(0). *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> UWRIT1(L); BLINES(0);
<font color="#B22222">(*4*)</font> RETURN; <strong><font color="#4169E1">END</font></strong> UWRITE;


<strong><font color="#4169E1">PROCEDURE UWRIT1</font></strong>(L: LIST);
<font color="#B22222">(*Universal write, 1. subalgorithm. L is an atom, a symbol
or a list over atoms or symbols. L is written in the output
stream. *)</font>
<strong><font color="#228B22">VAR</font></strong>  AL, LP: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*ATOM OR SYMBOL.*)</font>
      <font color="#4169E1">IF</font> L &lt; BETA <font color="#4169E1">THEN</font> AWRITE(L); RETURN <strong><font color="#4169E1">END</font></strong>; 
      <font color="#4169E1">IF</font> SYMBOL(L) <font color="#4169E1">THEN</font> SYWRIT(L); RETURN <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*LIST.*)</font> SWRITE("("); LP:=L;
      <font color="#4169E1">WHILE</font> LP &lt;&gt; SIL <font color="#4169E1">DO</font> ADV(LP, AL,LP); UWRIT1(AL);
            <font color="#4169E1">IF</font> AL = NOSHOW <font color="#4169E1">THEN</font> SWRITE(" ..."); LP:=SIL <strong><font color="#4169E1">END</font></strong>; 
            <font color="#4169E1">IF</font> LP &lt;&gt; SIL <font color="#4169E1">THEN</font> SWRITE(" ") <strong><font color="#4169E1">END</font></strong> 
            <strong><font color="#4169E1">END</font></strong>;
      SWRITE(")"); 
<font color="#B22222">(*5*)</font> <strong><font color="#4169E1">END</font></strong> UWRIT1;


<font color="#B22222">(*************************************************************************)</font>
<font color="#B22222">(*
MODULE SymbolTableAccess;
(* by Thomas Wollersberger December 1990, modified AVL-Version *)</font>
<font color="#B22222">(* Version HASH+AVL *)</font>

IMPORT LIST,SIL,ADV2,COMP,ACOMP1,NAME,SYNEW,SRED,RED,SFIRST,
       UWRIT1,UWRITE,GET,ICOUNT,COUNT,LENGTH,TAB,BLINES,ADV,
       LISTVAR,SWRITE,CONC,ATTRIB,FIRST,ADV3,SLELT,RED2;
EXPORT STINS,STCNT,STLST,STLSTI,STSRCH,STWRT;
*)


<strong><font color="#228B22">CONST</font></strong> maxtab = 498; <font color="#B22222">(* length of hashtable *)</font>
                    <font color="#B22222">(* good values: 112,192,!198!,210,222,306,!498!,996 *)</font>
                    <font color="#B22222">(* more symbols -&gt; more tableplaces *)</font>
 
<strong><font color="#228B22">CONST</font></strong>  maxtab1 = maxtab + 1;
 
<strong><font color="#228B22">VAR</font></strong> SYMTBarr : ARRAY [0..maxtab] <font color="#4169E1">OF</font> LIST;

<font color="#B22222">(* Remark : All procedures have access to the same symboltable,
            here implemented as an Hash-table with AVL-trees for
            collision resolution. The varible SYMTB
            of type LIST defined in the definition-module is
            never used (It's only history !). The procedures
            parametrisized with a Symboltable will only use the
            Hash-table defined in this local module (incidentally
            it is named SYMTBarr, too !). You can use the outer SYMTB
            as a dummy-variable.   Th.W. *)</font>


<strong><font color="#4169E1">PROCEDURE hash</font></strong>(name:LIST): CARDINAL;
<font color="#B22222">(* computes a number (0..maxtab) from the packed character list name.
   The numbers should be distributed very uniform, but that depends on
   the average structure of the names. Three possiblities are tested : *)</font>

  <font color="#B22222">(* 1. Simply take 16 Bits of the Coding of the first characters ! *)</font>
  <font color="#B22222">(* fastest version *)</font>
  <font color="#B22222">(*
  VAR f:LIST;
  BEGIN
  f:=FIRST(name); (*Assert f &gt;= 0 *)</font>
  RETURN(CARDINAL(f) MOD maxtab1)      
  *)

  <font color="#B22222">(* 2. Simply take the Coding of the first characters ! *)</font>
  
  <strong><font color="#228B22">VAR</font></strong> f:LIST;
  <strong><font color="#4169E1">BEGIN</font></strong>
  f:=FIRST(name); <font color="#B22222">(*Assert f &gt;= 0 *)</font>
  RETURN(CARDINAL(f MOD maxtab1))      
  

  <font color="#B22222">(* 3. Sum up over all characters ! *)</font>
  <font color="#B22222">(*
  VAR s:CARDINAL;
      f:LIST;
  BEGIN
  s:=0;
  WHILE name # SIL DO
    ADV(name, f,name);
    s:=(s+CARDINAL(f MOD maxtab1)) MOD maxtab1
  END;
  RETURN(s)
  *)</font>

<strong><font color="#4169E1">END</font></strong> hash;


  <strong><font color="#4169E1">PROCEDURE SearchInsertAVL</font></strong> (B, t:LIST; 
            <strong><font color="#228B22">VAR</font></strong> S: LIST; <strong><font color="#228B22">VAR</font></strong> HeightChanged:BOOLEAN): LIST;
  <font color="#B22222">(* For further documentation see any book on AVL-trees ! *)</font>
  <strong><font color="#228B22">VAR</font></strong>  lt,bal,elem,rt: LIST;
       tt, lth,balh,rth,lth1,rth1: LIST;
    <strong><font color="#4169E1">BEGIN</font></strong>     tt:=t; 
    <font color="#4169E1">IF</font> t=SIL  <font color="#B22222">(* empty tree *)</font>
      <font color="#4169E1">THEN</font> S:=SYNEW(B);
           tt:=COMP(SIL,COMP(0,COMP(S,SIL)));
           HeightChanged:=TRUE;
           newIns:=TRUE

      <font color="#4169E1">ELSE</font> ADV3(t, lt,bal,elem,rt);
           <font color="#4169E1">CASE</font> INTEGER(ACOMP1(B,NAME(elem))) <font color="#4169E1">OF</font>

            -1: <font color="#B22222">(* search/insert left *)</font>
                lt:=SearchInsertAVL(B, lt, S,HeightChanged);
                <font color="#4169E1">IF</font> newIns <font color="#4169E1">THEN</font> SFIRST(t,lt); newIns:=FALSE <strong><font color="#4169E1">END</font></strong>;
                <font color="#4169E1">IF</font> HeightChanged  <font color="#B22222">(* reset balance *)</font>
                  <font color="#4169E1">THEN</font> <font color="#4169E1">CASE</font> INTEGER(bal) <font color="#4169E1">OF</font>
                        -1: ADV3(lt, lth,balh,elem,rth);
                            <font color="#4169E1">IF</font> balh=-1
                              <font color="#4169E1">THEN</font> <font color="#B22222">(* LL-Rotation *)</font>
                                   SFIRST(t,rth);
                                   SRED(RED2(lt),t); SLELT(t,2,0);
                                   tt:=lt; newIns:=TRUE
                              <font color="#4169E1">ELSE</font> <font color="#B22222">(* LR-Rotation *)</font>
                                   ADV3(rth, lth1,balh,elem,rth1);
                                   SRED(RED2(lt),lth1);
                                   SFIRST(rth,lt);
                                   SFIRST(t,rth1);
                                   SRED(RED2(rth),t);
                                   <font color="#4169E1">IF</font> balh=-1
                                     <font color="#4169E1">THEN</font> SLELT(t,2,1) <font color="#4169E1">ELSE</font> SLELT(t,2,0)
                                   <strong><font color="#4169E1">END</font></strong>;
                                   <font color="#4169E1">IF</font> balh=1
                                     <font color="#4169E1">THEN</font> SLELT(lt,2,-1) <font color="#4169E1">ELSE</font> SLELT(lt,2,0)
                                   <strong><font color="#4169E1">END</font></strong>;
                                   tt:=rth; newIns:=TRUE
                            <strong><font color="#4169E1">END</font></strong>;
                            SLELT(t,2,0); HeightChanged:=FALSE |

                         0: SLELT(t,2,-1) |

                         1: SLELT(t,2,0); HeightChanged:=FALSE
                       <strong><font color="#4169E1">END</font></strong>
                <strong><font color="#4169E1">END</font></strong> <font color="#B22222">(* IF HeightChanged *)</font> |

             0: <font color="#B22222">(* Symbol found *)</font>
                S:=elem; HeightChanged:=FALSE |

             1: <font color="#B22222">(* search/insert right *)</font>
                rt:=SearchInsertAVL(B, rt, S,HeightChanged);
                <font color="#4169E1">IF</font> newIns <font color="#4169E1">THEN</font> SRED(RED2(t),rt); newIns:=FALSE <strong><font color="#4169E1">END</font></strong>;
                <font color="#4169E1">IF</font> HeightChanged  <font color="#B22222">(* reset balance *)</font>
                  <font color="#4169E1">THEN</font> <font color="#4169E1">CASE</font> INTEGER(bal) <font color="#4169E1">OF</font>
                        -1: SLELT(t,2,0); HeightChanged:=FALSE |

                         0: SLELT(t,2,1) |

                         1: ADV3(rt, lth,balh,elem,rth);
                            <font color="#4169E1">IF</font> balh=1
                              <font color="#4169E1">THEN</font> <font color="#B22222">(* RR-Rotation *)</font>
                                   SRED(RED2(t),lth);
                                   SFIRST(rt,t); SLELT(t,2,0);
                                   tt:=rt; newIns:=TRUE;
                              <font color="#4169E1">ELSE</font> <font color="#B22222">(* RL-Rotation *)</font>
                                   ADV3(lth, lth1,balh,elem,rth1);
                                   SFIRST(rt,rth1);
                                   SRED(RED2(lth),rt);
                                   SRED(RED2(t),lth1);
                                   SFIRST(lth,t);
                                   <font color="#4169E1">IF</font> balh=1
                                     <font color="#4169E1">THEN</font> SLELT(t,2,-1) <font color="#4169E1">ELSE</font> SLELT(t,2,0)
                                   <strong><font color="#4169E1">END</font></strong>;
                                   <font color="#4169E1">IF</font> balh=-1
                                     <font color="#4169E1">THEN</font> SLELT(rt,2,1) <font color="#4169E1">ELSE</font> SLELT(rt,2,0)
                                   <strong><font color="#4169E1">END</font></strong>;
                                   tt:=lth; newIns:=TRUE
                            <strong><font color="#4169E1">END</font></strong>;
                            SLELT(t,2,0); HeightChanged:=FALSE
                       <strong><font color="#4169E1">END</font></strong>
                <strong><font color="#4169E1">END</font></strong> <font color="#B22222">(* IF HeightChanged *)</font>

           <strong><font color="#4169E1">END</font></strong> <font color="#B22222">(* CASE *)</font>
    <strong><font color="#4169E1">END</font></strong>; <font color="#B22222">(* IF *)</font>
  RETURN(tt); 
  <strong><font color="#4169E1">END</font></strong> SearchInsertAVL;


<strong><font color="#4169E1">PROCEDURE STINS</font></strong>(B: LIST): LIST;
<font color="#B22222">(* Symbol table insertion. B is a packed list of characters. S is a
pointer to the corresponding symbol in the symbol table. If
it is not yet in, a new node is created. *)</font>
<strong><font color="#228B22">VAR</font></strong> h: BOOLEAN;
    S: LIST; 
    n: CARDINAL;
  <strong><font color="#4169E1">BEGIN</font></strong>
  newIns:=FALSE; h:=FALSE; S:=SIL; 
  n:=hash(B);
  SYMTBarr[n]:=SearchInsertAVL( B, SYMTBarr[n], S, h ); 
  <font color="#B22222">(* computes symbol S for name B *)</font>
  RETURN(S)
<strong><font color="#4169E1">END</font></strong> STINS;


<strong><font color="#4169E1">PROCEDURE STCNT</font></strong>(T: LIST; <strong><font color="#228B22">VAR</font></strong> S,P: LIST);
<font color="#B22222">(* Symbol table count. T is a dummy list, S is the number of
symbols in T, P the number of properties of all symbols of
the tree. Since every symbol has a name property, P ge S. *)</font>
<strong><font color="#228B22">VAR</font></strong> bal: LIST;

  <strong><font color="#4169E1">PROCEDURE STCNTrec</font></strong>(T: LIST; <strong><font color="#228B22">VAR</font></strong> S,P: LIST);

    <strong><font color="#228B22">VAR</font></strong>  J1Y,K,L,PP,R,SP: LIST;

    <strong><font color="#4169E1">BEGIN</font></strong>
    <font color="#4169E1">IF</font> T = SIL
      <font color="#4169E1">THEN</font> S:=0; P:=0
      <font color="#4169E1">ELSE</font> ADV3(T, L,bal,K,R);
           STCNTrec(L, S,P); <font color="#B22222">(* left branch *)</font>
           S:=S+1; J1Y:=LENGTH(K); J1Y:=J1Y DIV 2;
           P:=P+J1Y;
           <font color="#4169E1">IF</font> (COUNT &gt;= 1) <font color="#4169E1">AND</font> (GET(K,ICOUNT) &lt;&gt; SIL)
             <font color="#4169E1">THEN</font> UWRIT1(K); TAB(8); UWRITE(GET(K,ICOUNT)) <strong><font color="#4169E1">END</font></strong>;
           STCNTrec(R, SP,PP); <font color="#B22222">(* right branch *)</font>
          S:=S+SP; P:=P+PP
    <strong><font color="#4169E1">END</font></strong>
  <strong><font color="#4169E1">END</font></strong> STCNTrec;

  <strong><font color="#228B22">VAR</font></strong> s1,p1:LIST;
      i: CARDINAL;

  <strong><font color="#4169E1">BEGIN</font></strong>
  S:=0; P:=0;
  <font color="#4169E1">FOR</font> i:=0 <font color="#4169E1">TO</font> maxtab <font color="#4169E1">DO</font>
    STCNTrec(SYMTBarr[i], s1,p1);
    S:=S+s1; P:=P+p1  <font color="#B22222">(* sum up over array *)</font>
  <strong><font color="#4169E1">END</font></strong>

<strong><font color="#4169E1">END</font></strong> STCNT;


<strong><font color="#4169E1">PROCEDURE STLST</font></strong>(T: LIST): LIST;
<font color="#B22222">(* Symbol table list. T is a dummy list. L is the list of
its symbols in alphabetic order. *)</font>
<strong><font color="#228B22">VAR</font></strong> bal,J1Y: LIST;

  <strong><font color="#4169E1">PROCEDURE STLST1tree</font></strong>(T: LIST): LIST; <font color="#B22222">(* inorder list *)</font>

    <strong><font color="#228B22">VAR</font></strong>  LL,RL,SL: LIST;

    <strong><font color="#4169E1">BEGIN</font></strong>
    <font color="#4169E1">IF</font> T = SIL <font color="#4169E1">THEN</font> RETURN(SIL) <strong><font color="#4169E1">END</font></strong>;
    ADV2(T, LL,SL,RL);  <font color="#B22222">(* left tree,symbol,right tree *)</font>
    <font color="#4169E1">IF</font> LL &lt;&gt; SIL <font color="#4169E1">THEN</font> LL:=STLST1tree(LL) <strong><font color="#4169E1">END</font></strong>;
    <font color="#4169E1">IF</font> RL &lt;&gt; SIL <font color="#4169E1">THEN</font> RL:=STLST1tree(RL) <strong><font color="#4169E1">END</font></strong>;
    J1Y:=COMP(SL,RL);
    RETURN( CONC(LL,J1Y) )

  <strong><font color="#4169E1">END</font></strong> STLST1tree;


  <strong><font color="#228B22">VAR</font></strong> AuxTree:LIST;

  <strong><font color="#4169E1">PROCEDURE WalkThroughTreeAndInsertIntoAuxtree</font></strong>(T:LIST);

    <font color="#B22222">(* Elements of AVL-tree T are inserted into normal binary tree *)</font>

    <strong><font color="#4169E1">PROCEDURE insert</font></strong>(sym:LIST); <font color="#B22222">(* local proc. for inserting into AuxTree *)</font>
      <strong><font color="#228B22">VAR</font></strong> h,l,m,r:LIST;
      <strong><font color="#4169E1">BEGIN</font></strong>
      <font color="#4169E1">IF</font> AuxTree=SIL
        <font color="#4169E1">THEN</font> <font color="#B22222">(* new root *)</font>
          AuxTree:=COMP(SIL,COMP(sym,SIL))
        <font color="#4169E1">ELSE</font> <font color="#B22222">(* scan tree *)</font>
          h:=AuxTree;
          LOOP <font color="#B22222">(* trace one path until one fitting empty leave is found *)</font>
            ADV2(h, l,m,r);
            <font color="#4169E1">CASE</font> INTEGER(ACOMP1(NAME(m),NAME(sym))) <font color="#4169E1">OF</font>
             -1: <font color="#4169E1">IF</font> r=SIL
                   <font color="#4169E1">THEN</font> SRED(RED(h),COMP(SIL,COMP(sym,SIL))); EXIT
                   <font color="#4169E1">ELSE</font> h:=r
                 <strong><font color="#4169E1">END</font></strong> |
              1: <font color="#4169E1">IF</font> l=SIL
                   <font color="#4169E1">THEN</font> SFIRST(h,COMP(SIL,COMP(sym,SIL))); EXIT
                   <font color="#4169E1">ELSE</font> h:=l
                 <strong><font color="#4169E1">END</font></strong>
            <strong><font color="#4169E1">END</font></strong> <font color="#B22222">(* CASE *)</font>
          <strong><font color="#4169E1">END</font></strong> <font color="#B22222">(* LOOP *)</font>
      <strong><font color="#4169E1">END</font></strong> <font color="#B22222">(* IF *)</font>
    <strong><font color="#4169E1">END</font></strong> insert;

    <strong><font color="#228B22">VAR</font></strong> L,M,R:LIST;

    <strong><font color="#4169E1">BEGIN</font></strong>
    <font color="#4169E1">IF</font> T # SIL
      <font color="#4169E1">THEN</font> ADV3(T, L,bal,M,R); <font color="#B22222">(* cut from tree T and insert into AuxTree *)</font>
           insert(M);
           <font color="#B22222">(* I take preorder, because I expect in-(~alphabetic-)order
           to produce very unbalanced trees ! *)</font>
           WalkThroughTreeAndInsertIntoAuxtree(L);
           WalkThroughTreeAndInsertIntoAuxtree(R)
    <strong><font color="#4169E1">END</font></strong>

  <strong><font color="#4169E1">END</font></strong> WalkThroughTreeAndInsertIntoAuxtree;


  <strong><font color="#228B22">VAR</font></strong> i:CARDINAL;

  <strong><font color="#4169E1">BEGIN</font></strong>
  <font color="#B22222">(* insert all elements of the table into an auxiliary binary tree *)</font>
  AuxTree:=SIL;
  <font color="#4169E1">FOR</font> i:=0 <font color="#4169E1">TO</font> maxtab <font color="#4169E1">DO</font>
    WalkThroughTreeAndInsertIntoAuxtree(SYMTBarr[i])
  <strong><font color="#4169E1">END</font></strong>;
  RETURN( STLST1tree(AuxTree) ) <font color="#B22222">(* inorder-traverse AuxTree *)</font>

<strong><font color="#4169E1">END</font></strong> STLST;


<strong><font color="#4169E1">PROCEDURE STLSTI</font></strong>(T: LIST): LIST;
<font color="#B22222">(* Symbol table list, internal-order (quick to compute).
T is a dummy list, L is the list of the symbols. *)</font>
<strong><font color="#228B22">VAR</font></strong> bal,J1Y: LIST;

  <strong><font color="#4169E1">PROCEDURE STLSTIrec</font></strong>(T: LIST): LIST;  <font color="#B22222">(* preorder list *)</font>

    <strong><font color="#228B22">VAR</font></strong> LL,RL,SL: LIST;

    <strong><font color="#4169E1">BEGIN</font></strong>
    <font color="#4169E1">IF</font> T = SIL <font color="#4169E1">THEN</font> RETURN(SIL) <strong><font color="#4169E1">END</font></strong>;
    ADV3(T, LL,bal,SL,RL);
    <font color="#4169E1">IF</font> LL &lt;&gt; SIL <font color="#4169E1">THEN</font> LL:=STLSTIrec(LL) <strong><font color="#4169E1">END</font></strong>;
    <font color="#4169E1">IF</font> RL &lt;&gt; SIL <font color="#4169E1">THEN</font> RL:=STLSTIrec(RL) <strong><font color="#4169E1">END</font></strong>;
    J1Y:=CONC(LL,RL);
    RETURN( COMP(SL,J1Y) )
  <strong><font color="#4169E1">END</font></strong> STLSTIrec;


  <strong><font color="#228B22">VAR</font></strong> L:LIST;
      i:CARDINAL;

  <strong><font color="#4169E1">BEGIN</font></strong> <font color="#B22222">(* compute a list from every tree, concatenate them all. *)</font>
  L:=SIL;
  <font color="#4169E1">FOR</font> i:=0 <font color="#4169E1">TO</font> maxtab <font color="#4169E1">DO</font>
    L:=CONC(L, STLSTIrec(SYMTBarr[i]) )
  <strong><font color="#4169E1">END</font></strong>;
  RETURN(L)

<strong><font color="#4169E1">END</font></strong> STLSTI;


<strong><font color="#4169E1">PROCEDURE STSRCH</font></strong>(T,AP: LIST): LIST;
<font color="#B22222">(* Symbol table search. T is a dummy list, AP is a packed list of
characters. If the symbol with the name AP occurs already in the
symbol table T then S points to the entry and otherwise S=(). *)</font>
<strong><font color="#228B22">VAR</font></strong>  l,b,m,r: LIST;

  <strong><font color="#4169E1">BEGIN</font></strong>
  T:=SYMTBarr[hash(AP)]; <font color="#B22222">(* hash the fitting tree *)</font>
  <font color="#4169E1">WHILE</font> T # SIL <font color="#4169E1">DO</font> <font color="#B22222">(* walk through until you find or not. *)</font>
    ADV3(T, l,b,m,r);
    <font color="#4169E1">CASE</font> INTEGER(ACOMP1(NAME(m),AP)) <font color="#4169E1">OF</font>
     -1: T:=r |
      0: RETURN(m) | <font color="#B22222">(* found *)</font>
      1: T:=l
    <strong><font color="#4169E1">END</font></strong>
  <strong><font color="#4169E1">END</font></strong>;
  RETURN(SIL) <font color="#B22222">(* not found *)</font>

<strong><font color="#4169E1">END</font></strong> STSRCH;


<strong><font color="#4169E1">PROCEDURE STWRT</font></strong>(T: LIST);
<font color="#B22222">(*Symbol table write. T is a dummy list. The symbols followed
by their properties are printed in alphabetic order. *)</font>
<strong><font color="#228B22">VAR</font></strong> a,M,ML:LIST;

  <strong><font color="#4169E1">BEGIN</font></strong>
  T:=STLST(T); <font color="#B22222">(* Now T is a list of the symbols in alphabetical order *)</font>

  <font color="#4169E1">WHILE</font> T # SIL <font color="#4169E1">DO</font> <font color="#B22222">(* Walk through list *)</font>
    ADV(T, a,T); 
    UWRIT1(a); SWRITE(": ");
    M:=ATTRIB(a);
    <font color="#4169E1">WHILE</font> M &lt;&gt; SIL <font color="#4169E1">DO</font> ADV(M, ML,M); UWRIT1(ML); SWRITE(" ") <strong><font color="#4169E1">END</font></strong>;
    BLINES(0)
  <strong><font color="#4169E1">END</font></strong>

<strong><font color="#4169E1">END</font></strong> STWRT;


<font color="#B22222">(* Initialisation of Hash-table of AVL-trees : *)</font>

<strong><font color="#228B22">VAR</font></strong> i:CARDINAL;

<strong><font color="#4169E1">BEGIN</font></strong>

<font color="#4169E1">FOR</font> i:=0 <font color="#4169E1">TO</font> maxtab <font color="#4169E1">DO</font> LISTVAR(SYMTBarr[i]); SYMTBarr[i]:=SIL <strong><font color="#4169E1">END</font></strong>;

<font color="#B22222">(*
END SymbolTableAccess;
(*************************************************************************)</font>
<font color="#B22222">(* Initialization. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
*)

LISTVAR(SYMTB); <font color="#B22222">(* SYMTB is Dummy-Variable here !! *)</font>

BEGINU;

<strong><font color="#4169E1">END</font></strong> MASSYM2.

<font color="#B22222">(* -EOF- *)</font>
</pre>
</body>

</html>
