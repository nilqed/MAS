
<html>
<head>
<title>./masdom/DIPAGB.mi</title>
<meta name="generator" content="pas2html 0.9.2">
<meta name="date" content="1995-11-04T20:39:35+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80"><font color="#B22222">(* ----------------------------------------------------------------------------
 * $Id: DIPAGB.mi,v 1.5 1995/11/04 20:39:35 pesch Exp $
 * ----------------------------------------------------------------------------
 * This file is part of MAS.
 * ----------------------------------------------------------------------------
 * Copyright (c) 1989 - 1994 Universitaet Passau
 * ----------------------------------------------------------------------------
 * $Log: DIPAGB.mi,v $
 * Revision 1.5  1995/11/04 20:39:35  pesch
 * Renamed massignal.m? to massig.m? because of conflict with MASSIGNAL.m?
 * on certain OS.
 *
 * Revision 1.4  1995/09/12  17:35:59  pesch
 * Use massignal instead of mpsignal.
 *
 * Revision 1.3  1994/10/16  13:18:35  rose
 * Minor additions.
 *
 * Revision 1.2  1994/06/06  17:36:19  rose
 * Syntactical errors (found by Mocka) corrected.
 *
 * Revision 1.1  1994/05/19  10:42:31  rose
 * New module DIPAGB. Computes a Groebner basis with the second Buchberger
 * criterion (Gebauer/Moeller).
 * Implemented critical pair selection strategies: normal, normal with sugar.
 *
 * ----------------------------------------------------------------------------
 *)</font>


IMPLEMENTATION MODULE DIPAGB;

<font color="#B22222">(* DIP Arbitrary Domain Groebner Basis Implementation Module. *)</font>



FROM DIPADOM	IMPORT	DIPBCP, DIPDIF, DIPROD, DIWRIT;

FROM DIPC	IMPORT	DIPEVL, DIPFMO, DIPMAD, DIPMCP, EVCOMP, EVDIF, EVDOV,
			EVLCM, EVMT, EVNNZE, EVSUM, VALIS;

FROM DIPGB	IMPORT	DIIFSP, DIPSP;

FROM DIPTOOLS	IMPORT	ADDDFDIP, ADDNFDIP, DIPCNST, DIPIMO, DIPONE;

FROM MASADOM	IMPORT	ADFI, ADGCDC, ADPNF, ADPSP, ADPSUGNF, ADPSUGSP,
			ADQUOT;

FROM MASBIOS	IMPORT	BLINES, CUNIT, SOUNIT, SWRITE;

FROM MASELEM	IMPORT	GAMMAINT;

FROM MASERR	IMPORT	ERROR, fatal, severe;

FROM MASLISPU	IMPORT	PROCF1, PROCF2, PROCF3, PROCF4, PROCP0, PROCP1,
			PROCP1V2;

FROM MASNCC	IMPORT	EVGCD;

FROM MASRN	IMPORT	RNMAX;

FROM MASSTOR	IMPORT	ADV, BETA, CELLS, COMP, FIRST, INV, LENGTH, LIST,
			LIST1, LISTVAR, RED, SIL, SRED, TIME;

FROM massig	IMPORT	Action, SIGUSR1, SIG_IGN, signal;

FROM SACLIST	IMPORT	AWRITE, CINV, COMP2, CONC, FIRST2, FOURTH, LELT,
			LIST2, LIST3, LIST4, LWRITE, RED4, SECOND, THIRD;

FROM SACPOL	IMPORT	VLWRIT;

FROM SACRN	IMPORT	RNCOMP, RNDIF, RNINT, RNPROD, RNSUM, RNWRIT;

FROM SYSTEM	IMPORT	ADR;


<strong><font color="#228B22">VAR</font></strong> DIPAGBOpt: RECORD
                  TraceFlag: CARDINAL;
                            <font color="#B22222">(* A non-negative integer level for interactive
                               documentation. *)</font>
                  Strategy: CARDINAL;
                            <font color="#B22222">(* The strategy for the extended critical pair
                               selection. The following strategies are
                               supported in this module:
                                  0 (= normal)
                                  1 (= normal with sugar)
                               *)</font>
                  VariableWeight: LIST;
                            <font color="#B22222">(* A list of r non-negative rational numbers
                               where the i-th component is the weight of
                               the (r-i+1)-th variable in the variable list
                               VALIS. *)</font>
                  UpdateVariableWeight: PROCP0;
                            <font color="#B22222">(* The procedure to update the DIPAGB variable
                               weight list. *)</font>
                  Update: PROCP1V2;
                            <font color="#B22222">(* The procedure to update the extended ideal basis
                               and the extended critical pair list as required
                               by DIPAGB. *)</font>
                  InitUpdate: PROCP1V2;
                            <font color="#B22222">(* The initialization procedure. *)</font>
                  CPExtend: PROCF2;
                            <font color="#B22222">(* The function to extend a critical pair by
                               further components. *)</font>
                  DIPExtend: PROCF1;
                            <font color="#B22222">(* The function to extend a distributive polynomial
                               by further components. *)</font>
                  ECPInsert: PROCF2;
                            <font color="#B22222">(* The function to insert an extended critical pair
                               into the extended critical pair list. *)</font>
                  ECPSelect: PROCP1V2;
                            <font color="#B22222">(* The procedure to select an extended critical
                               pair from the extended critical pair list. The
                               extended critical pair list is modified. *)</font>
                  ECPWrite: PROCP1;
                            <font color="#B22222">(* The procedure to write an extended critical
                               pair in the output stream. *)</font>
                  EDIPNormalform: PROCF2;
                            <font color="#B22222">(* The function to reduce an extended distributive
                               polynomial to normalform w.r.t. a list of
                               extended distributive polynomials. *)</font>
                  EDIPSPolynomial: PROCF2;
                            <font color="#B22222">(* The function to compute the extended
                               S-polynomial of two extended distributive
                               polynomials. *)</font>
                  EDIPUnExtend: PROCF1;
                            <font color="#B22222">(* The function to get the distributive polynomial
                               from an extended distributive polynomial. *)</font>
                  EDIPWrite: PROCP1;
                            <font color="#B22222">(* The procedure to write an extended distributive
                               polynomial in the output stream. *)</font>
               <strong><font color="#4169E1">END</font></strong>;

<strong><font color="#228B22">VAR</font></strong> pG,pB, pcell, ptime, predsum, prednum: POINTER <font color="#4169E1">TO</font> LIST;


<strong><font color="#228B22">CONST</font></strong> rcsidi = "$Id: DIPAGB.mi,v 1.5 1995/11/04 20:39:35 pesch Exp $";
<strong><font color="#228B22">CONST</font></strong> copyrighti = "Copyright (c) 1989 - 1994 Universitaet Passau";



<font color="#B22222">(****************************************************************************
 * 1. General Procedures                                                    *
 ****************************************************************************)</font>


<font color="#B22222">(* ------------------------------------------------------------------------ *
 * 1.1 The main function DIPAGB                                             *
 *     Given a finite subset F of a multivariate polynomial ring            *
 *     K[X1,...,Xn] over a computable field K DIPAGB finds a Groebner basis *
 *     G of the ideal in K[X1,...,Xn] generated by F. A call of DIPAGB with *
 *     parameter F performs the computation of G as given by GROEBNERNEW2   *
 *     in                                                                   *
 *        Becker, T. and Weispfenning, V., In Cooperation with Heinz Kredel,*
 *        Groebner Bases, A Computational Approach to Commutative Algebra,  *
 *        Springer 1993,                                                    *
 *     with the exception that the algorithm stops with the ideal basis     *
 *     G={1} if a constant non-zero polynomial would be added to the com-   *
 *     puted ideal basis.                                                   *
 * ------------------------------------------------------------------------ *)</font>


<strong><font color="#4169E1">PROCEDURE DIPAGB</font></strong>(F: LIST): LIST;
<font color="#B22222">(* Distributive polynomial arbitrary domain Groebner basis.
   F is a list of polynomials in distributive representation.
   G=DIPAGB(F) is a (not reduced) Groebner basis with Id(G)=Id(F). *)</font>

<strong><font color="#228B22">VAR</font></strong> G,B, g1g2, f,g1,g2,h, g, W, V,v, cell,time, redtime,redsum,rednum: LIST;
    ProperId: BOOLEAN;
    sighandleold: Action;

<strong><font color="#4169E1">BEGIN</font></strong>
   cell:=CELLS(); pcell:=ADR(cell); time:=TIME(); ptime:=ADR(time); redtime:=0;
   redsum:=0; predsum:=ADR(redsum); rednum:=0; prednum:=ADR(rednum);
   ProperId:=TRUE;
   UpdateVariableWeight;
   G:=SIL; B:=SIL;
   <font color="#4169E1">WHILE</font> F&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(F, f,F);
      INITUPDATE(DIPEXTEND(f), G,B);
   <strong><font color="#4169E1">END</font></strong>;
   pG:=ADR(G); pB:=ADR(B);
   sighandleold:=signal(SIGUSR1,SigUsr1HandleDIPAGB);
   <font color="#4169E1">WHILE</font> B&lt;&gt;SIL <font color="#4169E1">DO</font>
      ECPSELECT(B, g1g2,B);
      g1:=ECPPOLY1(g1g2); g2:=ECPPOLY2(g1g2);
      f:=EDIPSP(g1,g2);
      rednum:=rednum+1;
      <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 4 <font color="#4169E1">THEN</font>
         AWRITE(rednum);
         <font color="#4169E1">CASE</font> rednum <font color="#4169E1">OF</font>
              1: SWRITE("st polynomial <font color="#4169E1">to</font> reduce <font color="#4169E1">to</font> normalform: ") |
              2: SWRITE("nd polynomial <font color="#4169E1">to</font> reduce <font color="#4169E1">to</font> normalform: ") |
              3: SWRITE("rd polynomial <font color="#4169E1">to</font> reduce <font color="#4169E1">to</font> normalform: ")
            <font color="#4169E1">ELSE</font> SWRITE("th polynomial <font color="#4169E1">to</font> reduce <font color="#4169E1">to</font> normalform: ");
         <strong><font color="#4169E1">END</font></strong>;
         BLINES(0); SWRITE("  "); DIWRIT(EDIPUNEXTEND(f),VALIS); BLINES(1);
      <strong><font color="#4169E1">END</font></strong>;
      redtime:=TIME();
      h:=EDIPNOR(G,f);
      redsum:=redsum+TIME()-redtime;
      g:=EDIPUNEXTEND(h);
      <font color="#4169E1">IF</font> g&lt;&gt;0 <font color="#4169E1">THEN</font>
         <font color="#4169E1">IF</font> <font color="#4169E1">NOT</font>(DIPCNST(g))
            <font color="#4169E1">THEN</font> <font color="#B22222">(* g ist not constant *)</font>
                 DIPAGBOpt.Update(h, G,B);
            <font color="#4169E1">ELSE</font> ProperId:=FALSE;
                 <font color="#B22222">(* G should contain the single constant polynomial 1 *)</font>
                    G:=LIST1(DIPONE(ADDDFDIP(g)));
                 <font color="#B22222">(* Leave the while loop *)</font>
                    B:=SIL;
         <strong><font color="#4169E1">END</font></strong>;
      <strong><font color="#4169E1">END</font></strong>;
   <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 2 <font color="#4169E1">THEN</font>
      AWRITE(rednum); SWRITE(" normalform computations in ");
      AWRITE(redsum); SWRITE(" milliseconds. "); BLINES(1);
   <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">IF</font> ProperId <font color="#4169E1">THEN</font> G:=LEDIPUNEXTEND(G); <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 1 <font color="#4169E1">THEN</font>
      BLINES(0);
      SWRITE("Total time: "); AWRITE(TIME()-time); SWRITE(" milliseconds.");
      BLINES(0);
      SWRITE("     Cells: "); AWRITE(CELLS()-cell); SWRITE("."); BLINES(1);
   <strong><font color="#4169E1">END</font></strong>;
   sighandleold:=signal(SIGUSR1,sighandleold);
   RETURN(G);
<strong><font color="#4169E1">END</font></strong> DIPAGB;



<font color="#B22222">(* ------------------------------------------------------------------------ *
 * 1.2 The procedure UPDATE                                                 *
 *     The extended ideal basis G and the extended critical pair list B are *
 *     updated as required by DIPAGB (see 1.3 and 1.4 for information about *
 *     extended polynomials and extended critical pairs). The subalgorithm  *
 *     UPDATE of DIPAGB eliminates superfluous critical pairs according to  *
 *     Buchberger's criteria as implemented by Gebauer and Moeller, see     *
 *        - Becker, T. and Weispfenning, V., In Cooperation with Heinz      *
 *          Kredel, Groebner Bases, A Computational Approach to Commutative *
 *          Algebra, Springer 1993,                                         *
 *        - Gebauer, R. and Moeller, H.M., On an installation of Buch-      *
 *          berger's algorithm, J. Symb. Comp 6/2/3, pp. 275-286.           *
 * ------------------------------------------------------------------------ *)</font>


<strong><font color="#4169E1">PROCEDURE UPDATE</font></strong>(h: LIST; <strong><font color="#228B22">VAR</font></strong> G,B: LIST);
<font color="#B22222">(* Update of extended ideal basis and extended critical pair list as required
   by DIPAGB.
   h is an extended distributive polynomial, G is a list of extended
   distributive polynomials. B is a list of extended critical pairs. *)</font>

<strong><font color="#228B22">VAR</font></strong> Bnew,Gnew, C,D,E,CC,DD, CP, hg,hg1,hg2,g1g2, g,g1,g2,
    HTg,HTg1,HTg2,HTh, FL: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   C:=SIL; D:=G;
   <font color="#4169E1">WHILE</font> D&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(D,g1,D);
      C:=ECPINSERT(CPEXTEND(h,g1),C);
   <strong><font color="#4169E1">END</font></strong>;
   HTh:=EDIPEVL(h);
   <font color="#4169E1">WHILE</font> C&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(C,hg1,C); g1:=ECPPOLY2(hg1); HTg1:=EDIPEVL(g1);
      <font color="#4169E1">IF</font> EVNNZE(EVGCD(HTh,HTg1))=0
         <font color="#4169E1">THEN</font> D:=COMP(hg1,D);
         <font color="#4169E1">ELSE</font> CC:=C; FL:=0;
              <font color="#4169E1">WHILE</font> (CC&lt;&gt;SIL) <font color="#4169E1">AND</font> (FL=0) <font color="#4169E1">DO</font>
                 ADV(CC,hg2,CC);
                 FL:=EVMT(ECPLCMHT(hg1),ECPLCMHT(hg2));
              <strong><font color="#4169E1">END</font></strong>;
              <font color="#4169E1">IF</font> FL=0 <font color="#4169E1">THEN</font>
                 DD:=D;
                 <font color="#4169E1">WHILE</font> (DD&lt;&gt;SIL) <font color="#4169E1">AND</font> (FL=0) <font color="#4169E1">DO</font>
                    ADV(DD,hg2,DD);
                    FL:=EVMT(ECPLCMHT(hg1),ECPLCMHT(hg2));
                 <strong><font color="#4169E1">END</font></strong>;
              <strong><font color="#4169E1">END</font></strong>;
              <font color="#4169E1">IF</font> FL=0 <font color="#4169E1">THEN</font> D:=COMP(hg1,D); <strong><font color="#4169E1">END</font></strong>;
      <strong><font color="#4169E1">END</font></strong>;
   <strong><font color="#4169E1">END</font></strong>;
   E:=SIL;
   <font color="#4169E1">WHILE</font> D&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(D,hg,D); g:=ECPPOLY2(hg); HTg:=EDIPEVL(g);
      <font color="#4169E1">IF</font> EVNNZE(EVGCD(HTh,HTg))&gt;0 <font color="#4169E1">THEN</font> E:=COMP(hg,E); <strong><font color="#4169E1">END</font></strong>;
   <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">WHILE</font> B&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(B,g1g2,B);
      g1:=ECPPOLY1(g1g2); g2:=ECPPOLY2(g1g2);
      HTg1:=EDIPEVL(g1); HTg2:=EDIPEVL(g2);
      <font color="#4169E1">IF</font> (EVMT(ECPLCMHT(g1g2),HTh)=0)
            <font color="#4169E1">OR</font> (EVCOMP(EVLCM(HTg1,HTh),ECPLCMHT(g1g2))=0)
            <font color="#4169E1">OR</font> (EVCOMP(EVLCM(HTh,HTg2),ECPLCMHT(g1g2))=0)
         <font color="#4169E1">THEN</font> E:=ECPINSERT(g1g2,E);
      <strong><font color="#4169E1">END</font></strong>;
   <strong><font color="#4169E1">END</font></strong>;
   Bnew:=E; Gnew:=SIL;
   <font color="#4169E1">WHILE</font> G&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(G,g,G); HTg:=EDIPEVL(g);
      <font color="#4169E1">IF</font> EVMT(HTg,HTh)=0 <font color="#4169E1">THEN</font> Gnew:=COMP(g,Gnew); <strong><font color="#4169E1">END</font></strong>;
   <strong><font color="#4169E1">END</font></strong>;
   Gnew:=COMP(h,Gnew);
   G:=Gnew; B:=Bnew;
<strong><font color="#4169E1">END</font></strong> UPDATE;



<font color="#B22222">(* ------------------------------------------------------------------------ *
 * 1.3 Procedures for extended distributive polynomials                     *
 *     In this module there are different strategies implemented to choose  *
 *     one of the critical pairs in the DIPAGB function for the process of  *
 *     reduction ("selection strategies"). Certain selection strategies     *
 *     make it necessary to carry along some information with each poly-    *
 *     nomial. This fact leads to a new data structure called "extended     *
 *     distributive polynomial". It's a tuple (f,i1,...,ik) where f is a    *
 *     distributive polynomial and i1,...,ik are informations on f. The     *
 *     informations depend on the current selection strategy.               *
 * ------------------------------------------------------------------------ *)</font>


<strong><font color="#4169E1">PROCEDURE DIPEXTEND</font></strong>(f: LIST): LIST;
<font color="#B22222">(* Distributive polynomial extension.
   f is a polynomial in distributive representation.
   DIPEXTEND(f) is the extended distributive polynomial appropriate to f. *)</font>

<strong><font color="#228B22">VAR</font></strong> Ef: LIST;
    i: CARDINAL;

<strong><font color="#4169E1">BEGIN</font></strong>
   Ef:=DIPAGBOpt.DIPExtend(f);
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 8
      <font color="#4169E1">THEN</font> SWRITE("Extending the polynomial"); BLINES(0);
           SWRITE("    "); EDIPWRITE(Ef);
           <font color="#4169E1">FOR</font> i:=1 <font color="#4169E1">TO</font> 79 <font color="#4169E1">DO</font> SWRITE("-"); <strong><font color="#4169E1">END</font></strong>; BLINES(1);
   <strong><font color="#4169E1">END</font></strong>;
   RETURN(Ef);
<strong><font color="#4169E1">END</font></strong> DIPEXTEND;



<strong><font color="#4169E1">PROCEDURE LDIPEXTEND</font></strong>(P: LIST): LIST;
<font color="#B22222">(* List of distributive polynomials extend.
   P is a list of distributive polynomials.
   LDIPEXTEND(P) is the list of the appropriate extended distributive
   polynomials. *)</font>

<strong><font color="#228B22">VAR</font></strong> p,Q: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   Q:=SIL;
   <font color="#4169E1">WHILE</font> P&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(P, p,P);
      Q:=COMP(DIPEXTEND(p),Q);
   <strong><font color="#4169E1">END</font></strong>;
   RETURN(Q);
<strong><font color="#4169E1">END</font></strong> LDIPEXTEND;



<strong><font color="#4169E1">PROCEDURE EDIPEVL</font></strong>(f: LIST): LIST;
<font color="#B22222">(* Extended distributive polynomial exponent vector of the leading monomial.
   f is an extended distributive polynomial.
   EDIPEVL(f) is the exponent vector of the leading monomial of f. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(DIPEVL(EDIPUNEXTEND(f)));
<strong><font color="#4169E1">END</font></strong> EDIPEVL;



<strong><font color="#4169E1">PROCEDURE EDIPNOR</font></strong>(P,f: LIST): LIST;
<font color="#B22222">(* Extended distributive polynomial normal form.
   P is a list of non-zero extended distributive polynomials.
   f is an extended distributive polynomial.
   EDIPNOR(P,f) is an extended distributive polynomial such that f is reducible
   to EDIPNOR(P,f) modulo P and EDIPNOR(P,f) is in normalform w.r.t. P. *)</font>

<strong><font color="#228B22">VAR</font></strong> g: LIST;
    i: CARDINAL;

<strong><font color="#4169E1">BEGIN</font></strong>
   g:=DIPAGBOpt.EDIPNormalform(P,f);
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 5
      <font color="#4169E1">THEN</font> SWRITE("The normalform is"); BLINES(0);
           SWRITE("  "); EDIPWRITE(g);
           <font color="#4169E1">FOR</font> i:=1 <font color="#4169E1">TO</font> 79 <font color="#4169E1">DO</font> SWRITE("-"); <strong><font color="#4169E1">END</font></strong>; BLINES(1);
   <strong><font color="#4169E1">END</font></strong>;
   RETURN(g);
<strong><font color="#4169E1">END</font></strong> EDIPNOR;



<strong><font color="#4169E1">PROCEDURE EDIPSP</font></strong>(f,g: LIST): LIST;
<font color="#B22222">(* Extended distributive polynomial S-polynomial.
   f and g are extended distributive polynomials.
   EDIPSP(f,g) is the extended S-polynomial of f and g. *)</font>

<strong><font color="#228B22">VAR</font></strong> SP: LIST;
     i: CARDINAL;

<strong><font color="#4169E1">BEGIN</font></strong>
   SP:=DIPAGBOpt.EDIPSPolynomial(f,g);
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 9
      <font color="#4169E1">THEN</font> SWRITE("Computing the S-polynomial <font color="#4169E1">of</font> the following two ");
           SWRITE("distributive polynomials:"); BLINES(0);
           SWRITE("f = "); EDIPWRITE(f);
           SWRITE("g = "); EDIPWRITE(g);
           SWRITE("==&gt; Spol(f,g) = "); EDIPWRITE(SP);
           <font color="#4169E1">FOR</font> i:=1 <font color="#4169E1">TO</font> 79 <font color="#4169E1">DO</font> SWRITE("-"); <strong><font color="#4169E1">END</font></strong>; BLINES(1);
   <strong><font color="#4169E1">END</font></strong>;
   RETURN(SP);
<strong><font color="#4169E1">END</font></strong> EDIPSP;



<strong><font color="#4169E1">PROCEDURE EDIPUNEXTEND</font></strong>(f: LIST): LIST;
<font color="#B22222">(* Extended distributive polynomial un-extend.
   f is an extended distributive polynomial.
   EDIPUNEXTEND(f) is the distributive polynomial appropriate to f. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(DIPAGBOpt.EDIPUnExtend(f));
<strong><font color="#4169E1">END</font></strong> EDIPUNEXTEND;



<strong><font color="#4169E1">PROCEDURE LEDIPUNEXTEND</font></strong>(P: LIST): LIST;
<font color="#B22222">(* List of extended distributive polynomials un-extend.
   P is a list of extended distributive polynomials.
   LEDIPUNEXTEND(P) is the list of the appropriate distributive polynomials. *)</font>

<strong><font color="#228B22">VAR</font></strong> p,Q: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   Q:=SIL;
   <font color="#4169E1">WHILE</font> P&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(P, p,P);
      Q:=COMP(EDIPUNEXTEND(p),Q);
   <strong><font color="#4169E1">END</font></strong>;
   RETURN(Q);
<strong><font color="#4169E1">END</font></strong> LEDIPUNEXTEND;



<strong><font color="#4169E1">PROCEDURE EDIPWRITE</font></strong>(f: LIST);
<font color="#B22222">(* Extended distributive polynomial write.
   The extended distributive polynomial f is written in the output stream. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.EDIPWrite(f);
<strong><font color="#4169E1">END</font></strong> EDIPWRITE;



<strong><font color="#4169E1">PROCEDURE LEDIPWRITE</font></strong>(P: LIST);
<font color="#B22222">(* List of extended distributive polynomials write.
   The list P of extended distributive polynomials is written in the output
   stream. *)</font>

<strong><font color="#228B22">VAR</font></strong> p,i: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   i:=0;
   <font color="#4169E1">WHILE</font> P&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(P, p,P);
      i:=i+1; AWRITE(i);
      <font color="#4169E1">CASE</font> i <font color="#4169E1">OF</font>
           1: SWRITE("st polynomial: ") |
           2: SWRITE("nd polynomial: ") |
           3: SWRITE("rd polynomial: ");
         <font color="#4169E1">ELSE</font> SWRITE("th polynomial: ");
      <strong><font color="#4169E1">END</font></strong>;
      EDIPWRITE(p);
   <strong><font color="#4169E1">END</font></strong>; 
<strong><font color="#4169E1">END</font></strong> LEDIPWRITE;



<font color="#B22222">(* ------------------------------------------------------------------------ *
 * 1.4 Procedures for extended critical pairs                               *
 *     An extended critical pair is a pair of extended distributive poly-   *
 *     nomials together with some information which depends on the chosen   *
 *     selection strategy.                                                  *
 * ------------------------------------------------------------------------ *)</font>


<strong><font color="#4169E1">PROCEDURE CPEXTEND</font></strong>(f,g: LIST): LIST;
<font color="#B22222">(* Critical pair extend.
   f and g are distributive polynomials such that (f,g) is a critical pair.
   CPEXTEND(f,g) is the appropriate extended critical pair, i.e. the list of
   f, g and further components which depend on the chosen extended critical
   pair selection strategy. *)</font>

<strong><font color="#228B22">VAR</font></strong> ECP: LIST;
    i: CARDINAL;

<strong><font color="#4169E1">BEGIN</font></strong>
   ECP:=DIPAGBOpt.CPExtend(f,g);
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 8
      <font color="#4169E1">THEN</font> SWRITE("Extending the following critical pair:"); BLINES(0);
           ECPWRITE(ECP); BLINES(1);
           <font color="#4169E1">FOR</font> i:=1 <font color="#4169E1">TO</font> 79 <font color="#4169E1">DO</font> SWRITE("-"); <strong><font color="#4169E1">END</font></strong>; BLINES(1);
   <strong><font color="#4169E1">END</font></strong>;
   RETURN(ECP);
<strong><font color="#4169E1">END</font></strong> CPEXTEND;



<strong><font color="#4169E1">PROCEDURE ECPINSERT</font></strong>(CP,P: LIST): LIST;
<font color="#B22222">(* Extended critical pair insertion.
   The extended critical pair CP is to be inserted into the extended critical
   pair list P.
   ECPINSERT(CP,P) is the list P with the additional pair CP. *)</font>

<strong><font color="#228B22">VAR</font></strong> i: CARDINAL;

<strong><font color="#4169E1">BEGIN</font></strong>
   P:=DIPAGBOpt.ECPInsert(CP,P);
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 7
      <font color="#4169E1">THEN</font> SWRITE("Inserting the following extended critical pair:");
           BLINES(0); ECPWRITE(CP); BLINES(1);
           SWRITE("==&gt; New extended critical pair list:"); BLINES(0);
           LECPWRITE(P);
           <font color="#4169E1">FOR</font> i:=1 <font color="#4169E1">TO</font> 79 <font color="#4169E1">DO</font> SWRITE("-"); <strong><font color="#4169E1">END</font></strong>; BLINES(1);
   <strong><font color="#4169E1">END</font></strong>;
   RETURN(P);
<strong><font color="#4169E1">END</font></strong> ECPINSERT;



<strong><font color="#4169E1">PROCEDURE ECPLCMHT</font></strong>(CP: LIST): LIST;
<font color="#B22222">(* Extended critical pair select the least common multiple of head terms.
   ECPLCMHT(CP) is the extended least common multiple of the leadings terms
   of the two extended polynomials in the extended critical pair CP. *)</font>

<font color="#B22222">(* This selector function has to be modified if a new extended critical pair
   data structure is chosen in this implementation module. In the current
   revision the extended critical pair is implemented as a list where the third
   component is the extended least common multiple of the leading terms. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(THIRD(CP));
<strong><font color="#4169E1">END</font></strong> ECPLCMHT;



<strong><font color="#4169E1">PROCEDURE ECPPOLY1</font></strong>(CP: LIST): LIST;
<font color="#B22222">(* Extended critical pair select the first extended distributive polynomial. *)</font>

<font color="#B22222">(* This selector function has to be modified if a new extended critical pair
   data structure is chosen in this implementation module. In the current
   revision the extended critical pair is implemented as a list where the first
   component is the first extended distributive polynomial. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(FIRST(CP));
<strong><font color="#4169E1">END</font></strong> ECPPOLY1;



<strong><font color="#4169E1">PROCEDURE ECPPOLY2</font></strong>(CP: LIST): LIST;
<font color="#B22222">(* Extended critical pair select the second extended distributive
   polynomial. *)</font>

<font color="#B22222">(* This selector function has to be modified if a new extended critical pair
   data structure is chosen in this implementation module. In the current
   revision the extended critical pair is implemented as a list where the
   second component is the second extended distributive polynomial. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(SECOND(CP));
<strong><font color="#4169E1">END</font></strong> ECPPOLY2;



<strong><font color="#4169E1">PROCEDURE ECPSELECT</font></strong>(P: LIST; <strong><font color="#228B22">VAR</font></strong> CP,Q: LIST);
<font color="#B22222">(* Select an extended critical pair from the extended critical pair list.
   The extended critical pair list is modified. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.ECPSelect(P, CP,Q);
<strong><font color="#4169E1">END</font></strong> ECPSELECT;



<strong><font color="#4169E1">PROCEDURE ECPUNEXTEND</font></strong>(CP: LIST): LIST;
<font color="#B22222">(* Extended critical pair un-extend.
   CP is an extended critical pair.
   ECPUNEXTEND(CP) is the appropriate critical pair, i.e. CP without the
   extensions which depend on the chosen extended critical pair selection
   strategy. *)</font>

<strong><font color="#228B22">VAR</font></strong> f,g: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   f:=ECPPOLY1(CP); g:=ECPPOLY2(CP);
   RETURN(CPCON(EDIPUNEXTEND(f),EDIPUNEXTEND(g)));
<strong><font color="#4169E1">END</font></strong> ECPUNEXTEND;



<strong><font color="#4169E1">PROCEDURE LECPUNEXTEND</font></strong>(P: LIST): LIST;
<font color="#B22222">(* List of extended critical pairs un-extend.
   P is a list of extended critical pairs.
   LECPUNEXTEND(P) is the list of the appropriate critical pairs. *)</font>

<strong><font color="#228B22">VAR</font></strong> CP,Q: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   Q:=SIL;
   <font color="#4169E1">WHILE</font> P&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(P, CP,P);
      Q:=COMP(ECPUNEXTEND(CP),Q);
   <strong><font color="#4169E1">END</font></strong>;
   RETURN(Q);
<strong><font color="#4169E1">END</font></strong> LECPUNEXTEND;



<strong><font color="#4169E1">PROCEDURE ECPWRITE</font></strong>(CP: LIST);
<font color="#B22222">(* Extended critical pair write.
   The extended critical pair CP is written in the output stream. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.ECPWrite(CP);
<strong><font color="#4169E1">END</font></strong> ECPWRITE;



<strong><font color="#4169E1">PROCEDURE LECPWRITE</font></strong>(P: LIST);
<font color="#B22222">(* List of extended critical pairs write.
   The list P of extended critical pairs is written in the output stream. *)</font>

<strong><font color="#228B22">VAR</font></strong> CP,i: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   i:=0;
   <font color="#4169E1">WHILE</font> P&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(P, CP,P);
      i:=i+1; AWRITE(i);
      <font color="#4169E1">CASE</font> i <font color="#4169E1">OF</font>
           1: SWRITE("st critical pair: ") |
           2: SWRITE("nd critical pair: ") |
           3: SWRITE("rd critical pair: ");
         <font color="#4169E1">ELSE</font> SWRITE("th critical pair: ");
      <strong><font color="#4169E1">END</font></strong>;
      BLINES(0); ECPWRITE(CP); BLINES(1);
   <strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> LECPWRITE;



<font color="#B22222">(* ------------------------------------------------------------------------ *
 * 1.5 Further general procedures                                           *
 * ------------------------------------------------------------------------ *)</font>


<strong><font color="#4169E1">PROCEDURE ADDNFEDIP</font></strong>(f: LIST): LIST;
<font color="#B22222">(* Arbitrary domain domain number from extended distributive polynomial.
   f is an extended distributive polynomial over an arbitrary domain polynomial
   ring. The domain number of the arbitrary domain is returned. If the
   unextended distributive polynomial appropriate to f is the zero polynomial
   then 0 is returned. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(ADDNFDIP(EDIPUNEXTEND(f)));
<strong><font color="#4169E1">END</font></strong> ADDNFEDIP;



<strong><font color="#4169E1">PROCEDURE CPCON</font></strong>(f,g: LIST): LIST;
<font color="#B22222">(* Critical pair constructor.
   f and g are distributive polynomials.
   CPCON(f,g) is the critical pair (f,g). *)</font>

<font color="#B22222">(* This constructor function has to be modified if a new critical pair
   data structure is chosen in this implementation module. In the current
   revision the critical pair is implemented as a list of length two. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(LIST2(f,g));
<strong><font color="#4169E1">END</font></strong> CPCON;



<strong><font color="#4169E1">PROCEDURE DIPRWTDG</font></strong>(f,W: LIST): LIST;
<font color="#B22222">(* Distributive polynomial rational-weighted total degree.
   f is a polynomial in distributive representation in r variables.
   W=(W1,...,Wr) is a list of rational numbers, where Wi, 1 le i le r, is the
   weight of the (r-i+1)-th variable in the variable list VALIS, i.e. of the
   variable w.r.t. the i-th component in each exponent vector of f.
   DIPRWTDG(f,W) is the rational-weighted total degree of f, defined by the
   maximal rational-weighted total degree of the exponent vectors of the terms
   of f. *)</font>

<strong><font color="#228B22">VAR</font></strong> TD, g, A,EV: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   <font color="#4169E1">IF</font> f=0 <font color="#4169E1">THEN</font> RETURN(0); <strong><font color="#4169E1">END</font></strong>;
   g:=f; TD:=0;
   <font color="#4169E1">WHILE</font> g&lt;&gt;SIL <font color="#4169E1">DO</font>
      DIPMAD(g, A,EV,g);
      TD:=RNMAX(TD,EVRWTDEG(EV,W));
   <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 6
      <font color="#4169E1">THEN</font> SWRITE("The rational-weighted total degree <font color="#4169E1">of</font> the polynomial");
           BLINES(0);
           SWRITE("  "); DIWRIT(f,VALIS); BLINES(0);
           SWRITE("w.r.t. the variable list"); BLINES(0);
           SWRITE("  "); VLWRIT(VALIS); BLINES(0);
           SWRITE("<font color="#4169E1">and</font> the variable weight list"); BLINES(0);
           SWRITE("  "); LRNWRIT(CINV(W)); BLINES(0);
           SWRITE("is "); RNWRIT(TD); SWRITE("."); BLINES(1);
   <strong><font color="#4169E1">END</font></strong>;
   RETURN(TD);
<strong><font color="#4169E1">END</font></strong> DIPRWTDG;



<strong><font color="#4169E1">PROCEDURE EVRWTDEG</font></strong>(U,W: LIST): LIST;
<font color="#B22222">(* Exponent vector rational-weighted total degree.
   U=(U1,...,Ur) is an exponent vector.
   W=(W1,...,Wr) is a list of rational numbers, where Wi, 1 le i le r, is the
   weight of the (r-i+1)-th variable in the variable list VALIS, i.e. of the
   variable w.r.t. the i-th component of U.
   TD=EVRWTDEG(U,W) is the rational-weighted total degree of U, defined by
   TD = W1U1+...+WrUr. *)</font>

<strong><font color="#228B22">VAR</font></strong> TD, Ui,Wi: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   TD:=0;
   <font color="#4169E1">WHILE</font> U&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(U, Ui,U); ADV(W, Wi,W);
      <font color="#4169E1">IF</font> Ui &gt;= BETA <font color="#4169E1">THEN</font>
         ERROR(severe,"EVRWTDEG: exponent out <font color="#4169E1">of</font> range");
         RETURN(SIL);
      <strong><font color="#4169E1">END</font></strong>;
      TD:=RNSUM(TD,RNPROD(Wi,RNINT(Ui)));
   <strong><font color="#4169E1">END</font></strong>;
   RETURN(TD);
<strong><font color="#4169E1">END</font></strong> EVRWTDEG;



<strong><font color="#4169E1">PROCEDURE IDF1</font></strong>(L: LIST): LIST;
<font color="#B22222">(* Identity. IDF1(L)=L. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(L)
<strong><font color="#4169E1">END</font></strong> IDF1;



<strong><font color="#4169E1">PROCEDURE INITUPDATE</font></strong>(f: LIST; <strong><font color="#228B22">VAR</font></strong> G,B: LIST);
<font color="#B22222">(* The initialization function as a first call of UPDATE. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.InitUpdate(f, G,B);
<strong><font color="#4169E1">END</font></strong> INITUPDATE;



<strong><font color="#4169E1">PROCEDURE LRNWRIT</font></strong>(LRN: LIST);
<font color="#B22222">(* List of rational numbers write.
   The list LRN of rational numbers is written in the output stream. *)</font>

<strong><font color="#228B22">VAR</font></strong> RN: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   SWRITE("(");
   <font color="#4169E1">IF</font> LRN&lt;&gt;SIL <font color="#4169E1">THEN</font> ADV(LRN, RN,LRN); RNWRIT(RN); <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">WHILE</font> LRN&lt;&gt;SIL <font color="#4169E1">DO</font>
      ADV(LRN, RN,LRN);
      SWRITE(","); RNWRIT(RN);
   <strong><font color="#4169E1">END</font></strong>;
   SWRITE(")");
<strong><font color="#4169E1">END</font></strong> LRNWRIT;


<strong><font color="#4169E1">PROCEDURE NOP</font></strong>;
<font color="#B22222">(* No operation. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
<strong><font color="#4169E1">END</font></strong> NOP;



<strong><font color="#4169E1">PROCEDURE UpdateVariableWeight</font></strong>;
<font color="#B22222">(* Update of the DIPAGB variable weight list. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.UpdateVariableWeight;
<strong><font color="#4169E1">END</font></strong> UpdateVariableWeight;



<strong><font color="#4169E1">PROCEDURE SigUsr1HandleDIPAGB</font></strong>(signo: INTEGER);
<font color="#B22222">(* Handler for sigusr1 in DIPAGB. *)</font>

<strong><font color="#228B22">VAR</font></strong> dummy: Action;
    Dummy: LIST;
    i: CARDINAL;

<strong><font color="#4169E1">BEGIN</font></strong>
   dummy:=signal(SIGUSR1,SIG_IGN);
   Dummy:=SOUNIT("CON:x");
   BLINES(0); <font color="#4169E1">FOR</font> i:=1 <font color="#4169E1">TO</font> 79 <font color="#4169E1">DO</font> SWRITE("-"); <strong><font color="#4169E1">END</font></strong>; BLINES(1);
   SWRITE("SIGUSR1 received in DIPAGB:"); BLINES(1);
   AWRITE(prednum^); SWRITE(" normalform computations in ");
   AWRITE(predsum^); SWRITE(" milliseconds up <font color="#4169E1">to</font> now. "); BLINES(1);
   SWRITE("Total time up <font color="#4169E1">to</font> now:      ");
   AWRITE(TIME()-ptime^); SWRITE(" milliseconds."); BLINES(0);
   SWRITE("Number <font color="#4169E1">of</font> cells up <font color="#4169E1">to</font> now: ");
   AWRITE(CELLS()-pcell^); SWRITE("."); BLINES(1);
   SWRITE("Already computed polynomials <font color="#4169E1">of</font> the Groebner Basis:"); BLINES(1);
   LEDIPWRITE(pG^); BLINES(1);
   SWRITE("Actual extended critical pair list:"); BLINES(1);
   LECPWRITE(pB^); BLINES(1);
   <font color="#4169E1">FOR</font> i:=1 <font color="#4169E1">TO</font> 79 <font color="#4169E1">DO</font> SWRITE("-"); <strong><font color="#4169E1">END</font></strong>; BLINES(1);
   Dummy:= CUNIT("CON:x");
   dummy:=signal(SIGUSR1,SigUsr1HandleDIPAGB);
<strong><font color="#4169E1">END</font></strong> SigUsr1HandleDIPAGB;



<font color="#B22222">(*****************************************************************************
 * 2. Procedures w.r.t. the normal strategy                                  *
 *    In case of the normal strategy a critical pair of polynomials is       *
 *    chosen if the least common multiple of their leading terms is minimal  *
 *    in the current term order.                                             *
 *****************************************************************************)</font>


<font color="#B22222">(* ------------------------------------------------------------------------ *
 * 2.1 Procedures for extended distributive polynomials                     *
 *     In case of the normal strategy an extended distributive polynomial   *
 *     simply is the same as a distributive polynomial.                     *
 * ------------------------------------------------------------------------ *)</font>


<strong><font color="#4169E1">PROCEDURE EDIPNORWRITE</font></strong>(f: LIST);
<font color="#B22222">(* Extended distributive polynomial write in case of the normal strategy.
   The (extended) distributive polynomial f is written in the output stream. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIWRIT(EDIPUNEXTEND(f),VALIS); BLINES(1);
<strong><font color="#4169E1">END</font></strong> EDIPNORWRITE;



<font color="#B22222">(* ------------------------------------------------------------------------ *
 * 2.2 Procedures for extended critical pairs                               *
 *     In case of the normal strategy an extended critical pair is a triple *
 *     (f,g,lcm) of two (extended) distributive polynomials f,g and the     *
 *     least common multiple lcm of the leading terms of f and g, whenever  *
 *     (f,g) defines a critical pair of polynomials.                        *
 * ------------------------------------------------------------------------ *)</font>


<strong><font color="#4169E1">PROCEDURE ECPNORCON</font></strong>(f,g: LIST): LIST;
<font color="#B22222">(* Critical pair normal strategy extension constructor.
   f and g are (extended) distributive polynomials such that (f,g) is a
   critical pair.
   The extended critical pair ECPNORCON(f,g) is the extension of (f,g) by a
   third component, namely the exponent vector of the least common multiple of
   the leading term of f and the leading term of g. *)</font>

<font color="#B22222">(* This constructor function has to be modified if a new extended critical pair
   data structure w.r.t. the normal strategy is chosen in this implementation
   module. In the current revision the extended critical pair is implemented
   as a list of length three. *)</font>

<strong><font color="#228B22">VAR</font></strong> HTf,HTg: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   HTf:=EDIPEVL(f); HTg:=EDIPEVL(g);
   RETURN(LIST3(f,g,EVLCM(HTf,HTg)));
<strong><font color="#4169E1">END</font></strong> ECPNORCON;



<strong><font color="#4169E1">PROCEDURE ECPNORINS</font></strong>(CP,P: LIST): LIST;
<font color="#B22222">(* Extended critical pair normal strategy insertion.
   The extended critical pair CP is to be inserted into the extended critical
   pair list P w.r.t. the normal strategy.
   P and ECPNORINS(CP,P) are ordered lists with increasing least common
   multiple of the leading terms w.r.t. the given term order. *)</font>

<strong><font color="#228B22">VAR</font></strong> PP,PPR, LCMCP: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   <font color="#B22222">(* P is the empty list. *)</font>  
      <font color="#4169E1">IF</font> P=SIL <font color="#4169E1">THEN</font> RETURN(LIST1(CP)); <strong><font color="#4169E1">END</font></strong>;
   LCMCP:=ECPLCMHT(CP);
   <font color="#B22222">(* LCMCP is minimal among all the lcm's. *)</font>
      <font color="#4169E1">IF</font> EVCOMP(ECPLCMHT(FIRST(P)),LCMCP)&gt;=0 <font color="#4169E1">THEN</font> RETURN(COMP(CP,P)); <strong><font color="#4169E1">END</font></strong>;
   <font color="#B22222">(* Else look for the first element of P with lcm &gt;= LCMCP. *)</font>
      PP:=P; PPR:=RED(PP);
      <font color="#4169E1">WHILE</font> (PPR&lt;&gt;SIL) <font color="#4169E1">AND</font> (EVCOMP(ECPLCMHT(FIRST(PPR)),LCMCP)=-1) <font color="#4169E1">DO</font>
         PP:=PPR; PPR:=RED(PP);
      <strong><font color="#4169E1">END</font></strong>;
   <font color="#B22222">(* Insert CP. *)</font>
      SRED(PP,COMP(CP,PPR)); RETURN(P);
<strong><font color="#4169E1">END</font></strong> ECPNORINS;



<strong><font color="#4169E1">PROCEDURE ECPNORWRITE</font></strong>(CP: LIST);
<font color="#B22222">(* Extended critical pair write in case of the normal strategy.
   The extended critical pair CP is written in the output stream. *)</font>

<strong><font color="#228B22">VAR</font></strong> f,g, Cf,Ef,Rf: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   f:=EDIPUNEXTEND(ECPPOLY1(CP)); g:=EDIPUNEXTEND(ECPPOLY2(CP));
   SWRITE("1st polynomial: "); DIWRIT(f,VALIS); BLINES(0);
   SWRITE("2nd polynomial: "); DIWRIT(g,VALIS); BLINES(0);
   DIPMAD(f, Cf,Ef,Rf);
   SWRITE("LCM <font color="#4169E1">of</font> their leading terms:");
   DIWRIT(DIPFMO(ADFI(Cf,1),ECPLCMHT(CP)),VALIS); BLINES(0);
<strong><font color="#4169E1">END</font></strong> ECPNORWRITE;



<font color="#B22222">(*****************************************************************************
 * 3. Procedures w.r.t. the normal with sugar strategy                       *
 *    In case of the normal with sugar strategy a critical pair of poly-     *
 *    nomials is chosen if the the sugar of their S-polynomial is minimal    *
 *    and, in order to break ties, if the least common multiple of their     *
 *    S-polynomial is minimal in the current term order among all critical   *
 *    pairs with the same sugar of their S-polynomial, see                   *
 *       Giovini, A., Mora, T., Niesi, G., Robbiano, L. and Traverso, C.,    *
 *       "One sugar cube, please" or Selection strategies in the Buchberger  *
 *       algorithm, J. of the ACM 1991, pp. 49-54.                           *
 *****************************************************************************)</font>



<font color="#B22222">(* ------------------------------------------------------------------------ *
 * 3.1 Procedures for extended distributive polynomials                     *
 *     In case of the normal with sugar strategy an extended distributive   *
 *     polynomial is a pair (f,Sf) of a polynomial f in distributive        * 
 *     representation and its sugar Sf.                                     *
 * ------------------------------------------------------------------------ *)</font>


<strong><font color="#4169E1">PROCEDURE DIPSUGEXT</font></strong>(f: LIST): LIST;
<font color="#B22222">(* Distributive polynomial normal with sugar strategy extension.
   f is a distributive polynomial.
   The extended distributive polynomial DIPSUGEXT(f) is the extension of f
   by a second component, namely the sugar of f. *)</font>

<strong><font color="#228B22">VAR</font></strong> W: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   W:=DIPAGBOpt.VariableWeight;
   RETURN(EDIPSUGCON(f,DIPRWTDG(f,W)));
<strong><font color="#4169E1">END</font></strong> DIPSUGEXT;



<strong><font color="#4169E1">PROCEDURE EDIIFSUGNF</font></strong>(P,f: LIST): LIST;
<font color="#B22222">(* Extended distributive integral function polynomial normal with sugar
   strategy normal form.
   P is a list of non-zero extended distributive integral function polynomials.
   f is an extended distributive integral function polynomial.
   EDIIFSUGNF(P,f) is an extended distributive integral function polynomial
   such that f is reducible to EDIIFSUGNF(P,f) modulo P and EDIIFSUGNF(P,f) is
   in normalform w.r.t. P. *)</font>

<strong><font color="#228B22">VAR</font></strong> PP, g,h,p,q, Ag,Eg,Ap,Ep, gcd,CoAg,CoAp, Sh,Sp, W,Mult: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   g:=EDIPUNEXTEND(f);
   <font color="#B22222">(* trivial cases *)</font>
      <font color="#4169E1">IF</font> (g=0) <font color="#4169E1">OR</font> (P=SIL) <font color="#4169E1">THEN</font> RETURN(f); <strong><font color="#4169E1">END</font></strong>;
   <font color="#B22222">(* Initialization *)</font>
      h:=0;
      Sh:=EDIPSUGAR(f);
      W:=DIPAGBOpt.VariableWeight;
   <font color="#4169E1">REPEAT</font>
      <font color="#B22222">(* Look at the leading monomial of g *)</font>
         DIPMAD(g, Ag,Eg,g);
         <font color="#4169E1">IF</font> g=SIL <font color="#4169E1">THEN</font> g:=0; <strong><font color="#4169E1">END</font></strong>;
      <font color="#B22222">(* Look for a polynomial p in P such that the leading monomial above
         is a multiple of the leading monomial of p *)</font> 
         PP:=P;
         <font color="#4169E1">REPEAT</font>
            ADV(PP, p,PP);
            Sp:=EDIPSUGAR(p);
            p:=EDIPUNEXTEND(p);
            DIPMAD(p, Ap,Ep,q);
            Mult:=EVMT(Eg,Ep);
         <font color="#4169E1">UNTIL</font> (PP=SIL) <font color="#4169E1">OR</font> (Mult=1);
      <font color="#4169E1">IF</font> Mult=0
         <font color="#4169E1">THEN</font> <font color="#B22222">(* No polynomial p as above was found *)</font>
              <font color="#4169E1">IF</font> h=0 <font color="#4169E1">THEN</font> h:=DIPFMO(Ag,Eg);
                     <font color="#4169E1">ELSE</font> h:=DIPMCP(Ag,Eg,h);
              <strong><font color="#4169E1">END</font></strong>;
         <font color="#4169E1">ELSE</font> <font color="#4169E1">IF</font> q&lt;&gt;SIL <font color="#4169E1">THEN</font>
                 ADGCDC(Ag,Ap, gcd,CoAg,CoAp);
                 g:=DIPDIF(DIPBCP(g,CoAp),DIPROD(q,DIPFMO(CoAg,EVDIF(Eg,Ep))));
                 h:=DIPBCP(h,CoAp);
              <strong><font color="#4169E1">END</font></strong>;
              Sh:=RNMAX(Sh,RNSUM(Sp,EVRWTDEG(EVDIF(Eg,Ep),W)));
      <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">UNTIL</font> g=0;
   RETURN(EDIPSUGCON(DIPIMO(h),Sh));
<strong><font color="#4169E1">END</font></strong> EDIIFSUGNF;



<strong><font color="#4169E1">PROCEDURE EDIIFSUGSP</font></strong>(f,g: LIST): LIST;
<font color="#B22222">(* Extended distributive integral function polynomial normal with sugar
   strategy S-polynomial.
   f and g are extended distributive integral function polynomials.
   EDIIFSUGSP(f,g) is the extended S-polynomial of f and g w.r.t. the normal
   with sugar strategy. *)</font>

<strong><font color="#228B22">VAR</font></strong> SP,SUG, W,HTf,HTg: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   SP:=DIIFSP(EDIPUNEXTEND(f),EDIPUNEXTEND(g));
   W:=DIPAGBOpt.VariableWeight;
   HTf:=EDIPEVL(f); HTg:=EDIPEVL(g);
   SUG:=RNSUM(RNMAX(RNDIF(EDIPSUGAR(f),EVRWTDEG(HTf,W)),
                    RNDIF(EDIPSUGAR(g),EVRWTDEG(HTg,W))),
              EVRWTDEG(EVLCM(HTf,HTg),W));
   RETURN(EDIPSUGCON(SP,SUG));
<strong><font color="#4169E1">END</font></strong> EDIIFSUGSP;



<strong><font color="#4169E1">PROCEDURE EDIPSUGAR</font></strong>(f: LIST): LIST;
<font color="#B22222">(* Extended distributive polynomial sugar.
   EDIPSUGAR(f) is the sugar of the extended distributive polynomial f. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(SECOND(f));
<strong><font color="#4169E1">END</font></strong> EDIPSUGAR;



<strong><font color="#4169E1">PROCEDURE EDIPSUGCON</font></strong>(f,S: LIST): LIST;
<font color="#B22222">(* Extended distributive polynomial normal with sugar strategy constructor.
   f is a distributive polynomial.
   S is the sugar of f.
   EDIPSUGCON(f,S) is the extended distributive polynomial appropriate to f
   with sugar S. *)</font>

<font color="#B22222">(* This constructor function has to be modified if a new extended distributive
   polynomial data structure w.r.t. the normal with sugar strategy is chosen in
   this implementation module. In the current revision the extended distribu-
   tive polynomial is implemented as a list of length 2. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(LIST2(f,S));
<strong><font color="#4169E1">END</font></strong> EDIPSUGCON;



<strong><font color="#4169E1">PROCEDURE EDIPSUGNOR</font></strong>(P,f: LIST): LIST;
<font color="#B22222">(* Extended distributive polynomial normal with sugar strategy normal form.
   P is a list of non-zero extended distributive polynomials.
   f is an extended distributive polynomial.
   EDIPSUGNOR(P,f) is an extended distributive polynomial such that f is
   reducible to EDIPSUGNOR(P,f) modulo P and EDIPSUGNOR(P,f) is in normalform
   w.r.t. P. *)</font>

<strong><font color="#228B22">VAR</font></strong> PP, g,h,p,q, Ag,Eg,Ap,Ep, Sh,Sp, W,Mult: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   g:=EDIPUNEXTEND(f);
   <font color="#B22222">(* trivial cases *)</font>
      <font color="#4169E1">IF</font> (g=0) <font color="#4169E1">OR</font> (P=SIL) <font color="#4169E1">THEN</font> RETURN(f); <strong><font color="#4169E1">END</font></strong>;
   <font color="#B22222">(* Initialization *)</font>
      h:=0;
      Sh:=EDIPSUGAR(f);
      W:=DIPAGBOpt.VariableWeight;
   <font color="#4169E1">REPEAT</font>
      <font color="#B22222">(* Look at the leading monomial of g *)</font>
         DIPMAD(g, Ag,Eg,g);
         <font color="#4169E1">IF</font> g=SIL <font color="#4169E1">THEN</font> g:=0; <strong><font color="#4169E1">END</font></strong>;
      <font color="#B22222">(* Look for a polynomial p in P such that the leading monomial above
         is a multiple of the leading monomial of p *)</font> 
         PP:=P;
         <font color="#4169E1">REPEAT</font>
            ADV(PP, p,PP);
            Sp:=EDIPSUGAR(p);
            p:=EDIPUNEXTEND(p);
            DIPMAD(p, Ap,Ep,q);
            Mult:=EVMT(Eg,Ep);
         <font color="#4169E1">UNTIL</font> (PP=SIL) <font color="#4169E1">OR</font> (Mult=1);
      <font color="#4169E1">IF</font> Mult=0
         <font color="#4169E1">THEN</font> <font color="#B22222">(* No polynomial p as above was found *)</font>
              <font color="#4169E1">IF</font> h=0 <font color="#4169E1">THEN</font> h:=DIPFMO(Ag,Eg);
                     <font color="#4169E1">ELSE</font> h:=DIPMCP(Ag,Eg,h);
              <strong><font color="#4169E1">END</font></strong>;
         <font color="#4169E1">ELSE</font> <font color="#4169E1">IF</font> q&lt;&gt;SIL <font color="#4169E1">THEN</font>
                 g:=DIPDIF(g,DIPROD(q,DIPFMO(ADQUOT(Ag,Ap),EVDIF(Eg,Ep))));
              <strong><font color="#4169E1">END</font></strong>;
              Sh:=RNMAX(Sh,RNSUM(Sp,EVRWTDEG(EVDIF(Eg,Ep),W)));
      <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">UNTIL</font> g=0;
   RETURN(EDIPSUGCON(DIPIMO(h),Sh));
<strong><font color="#4169E1">END</font></strong> EDIPSUGNOR;



<strong><font color="#4169E1">PROCEDURE EDIPSUGSP</font></strong>(f,g: LIST): LIST;
<font color="#B22222">(* Extended distributive polynomial normal with sugar strategy S-polynomial.
   f and g are extended distributive polynomials.
   EDIPSUGSP(f,g) is the extended S-polynomial of f and g w.r.t. the normal
   with sugar strategy. *)</font>

<strong><font color="#228B22">VAR</font></strong> SP,SUG, W,HTf,HTg: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   SP:=DIPSP(EDIPUNEXTEND(f),EDIPUNEXTEND(g));
   W:=DIPAGBOpt.VariableWeight;
   HTf:=EDIPEVL(f); HTg:=EDIPEVL(g);
   SUG:=RNSUM(RNMAX(RNDIF(EDIPSUGAR(f),EVRWTDEG(HTf,W)),
                    RNDIF(EDIPSUGAR(g),EVRWTDEG(HTg,W))),
              EVRWTDEG(EVLCM(HTf,HTg),W));
   RETURN(EDIPSUGCON(SP,SUG));
<strong><font color="#4169E1">END</font></strong> EDIPSUGSP;
 


<strong><font color="#4169E1">PROCEDURE EDIPSUGWRITE</font></strong>(f: LIST);
<font color="#B22222">(* Extended distributive polynomial write in case of the normal with sugar
   strategy.
   The extended distributive polynomial f is written in the output stream. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIWRIT(EDIPUNEXTEND(f),VALIS); BLINES(0);
   SWRITE("with sugar "); RNWRIT(EDIPSUGAR(f));
   SWRITE("."); BLINES(1);
<strong><font color="#4169E1">END</font></strong> EDIPSUGWRITE;



<font color="#B22222">(* ------------------------------------------------------------------------ *
 * 3.2 Procedures for extended critical pairs                               *
 *     In case of the normal with sugar strategy an extended critical pair  *
 *     is a quadruple ((f,Sf),(g,Sg),lcm,S) where (f,g) is a critical pair, *
 *     lcm is the exponent vector of the least common multiple of the       *
 *     leading terms of f and g and S is the sugar of the S-polynomial of f *
 *     and g.                                                               *
 * ------------------------------------------------------------------------ *)</font>


<strong><font color="#4169E1">PROCEDURE ECPSUGCON</font></strong>(f,g: LIST): LIST;
<font color="#B22222">(* Critical pair normal with sugar strategy extension constructor.
   f and g are extended distributive polynomials such that the distributive
   polynomial appropriate to f,g define a critical pair.
   The extended critical pair ECPSUGCON(f,g) is the extension of (f,g) by two
   further components: a third component is given by the exponent vector of the
   least common multiple of the leading term of f and the leading term of g, a
   fourth component is given by the sugar of the S-polynomial of f and g. *)</font>

<font color="#B22222">(* This constructor function has to be modified if a new extended critical pair
   data structure w.r.t. the normal with sugar strategy is chosen in this
   implementation module. In the current revision the extended critical pair
   is implemented as a list of length four. *)</font>


<strong><font color="#228B22">VAR</font></strong> W, HTf,HTg, LCM,SUG: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   HTf:=EDIPEVL(f); HTg:=EDIPEVL(g);
   LCM:=EVLCM(HTf,HTg);
   W:=DIPAGBOpt.VariableWeight;
   SUG:=RNSUM(RNMAX(RNDIF(EDIPSUGAR(f),EVRWTDEG(HTf,W)),
                    RNDIF(EDIPSUGAR(g),EVRWTDEG(HTg,W))),
              EVRWTDEG(LCM,W));
   RETURN(LIST4(f,g,LCM,SUG));
<strong><font color="#4169E1">END</font></strong> ECPSUGCON;



<strong><font color="#4169E1">PROCEDURE ECPSUGAR</font></strong>(CP: LIST): LIST;
<font color="#B22222">(* Extended critical pair select sugar.
   ECPSUGAR(CP) is the sugar of the S-polynomial of the polynomials in the
   extended critical pair CP. *)</font>

<font color="#B22222">(* This selector function has to be modified if a new extended critical pair
   data structure w.r.t. the normal with sugar strategy is chosen in this
   implementation module. In the current revision the extended critical pair
   is implemented as a list of length four where the fourth component is the
   sugar of the S-polynomial. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   RETURN(FOURTH(CP));
<strong><font color="#4169E1">END</font></strong> ECPSUGAR;



<strong><font color="#4169E1">PROCEDURE ECPSUGINS</font></strong>(CP,P: LIST): LIST;
<font color="#B22222">(* Extended critical pair normal with sugar strategy insertion.
   The extended critical pair CP is to be inserted into the extended critical
   pair list P w.r.t. the normal with sugar strategy.
   P and ECPSUGINS(CP,P) are ordered lists with increasing sugar of the
   S-polynomial and then increasing least common multiple of the leading terms
   w.r.t. the given term order. *)</font>

<strong><font color="#228B22">VAR</font></strong> PP,PPR, LCMCP,SUGCP, SUGCompare: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   <font color="#B22222">(* P is the empty list. *)</font>
      <font color="#4169E1">IF</font> P=SIL <font color="#4169E1">THEN</font> RETURN(LIST1(CP)); <strong><font color="#4169E1">END</font></strong>;
   SUGCP:=ECPSUGAR(CP);
   LCMCP:=ECPLCMHT(CP);
   <font color="#B22222">(* SUGCP is minimal among all sugar. *)</font>
      SUGCompare:=RNCOMP(ECPSUGAR(FIRST(P)),SUGCP);
      <font color="#4169E1">IF</font> SUGCompare=1 <font color="#4169E1">THEN</font> RETURN(COMP(CP,P)); <strong><font color="#4169E1">END</font></strong>;
      <font color="#4169E1">IF</font> (SUGCompare=0) <font color="#4169E1">AND</font> (EVCOMP(ECPLCMHT(FIRST(P)),LCMCP)&gt;=0)
         <font color="#4169E1">THEN</font> RETURN(COMP(CP,P));
      <strong><font color="#4169E1">END</font></strong>;
   <font color="#B22222">(* Look for the first element of P with sugar &gt;= SUGCP. *)</font>
      PP:=P; PPR:=RED(PP);
      <font color="#4169E1">WHILE</font> (PPR&lt;&gt;SIL) <font color="#4169E1">AND</font> (RNCOMP(ECPSUGAR(FIRST(PPR)),SUGCP)=-1) <font color="#4169E1">DO</font>
         PP:=PPR; PPR:=RED(PP);
      <strong><font color="#4169E1">END</font></strong>;
   <font color="#B22222">(* The end of PP is reached or sugar(FIRST(PPR)) &gt; SUGCP. *)</font>
      <font color="#4169E1">IF</font> (PPR=SIL) <font color="#4169E1">OR</font> (RNCOMP(ECPSUGAR(FIRST(PPR)),SUGCP)=1) <font color="#4169E1">THEN</font>
         SRED(PP,COMP(CP,PPR)); RETURN(P);
      <strong><font color="#4169E1">END</font></strong>;
   <font color="#B22222">(* sugar(FIRST(PPR)) = SUGCP holds. *)</font>
      <font color="#B22222">(* Look for the first element of PPR with sugar &gt; SUGCP or
         (sugar = SUGCP and lcm &gt;= LCMCP). *)</font>
         <font color="#4169E1">WHILE</font> (PPR&lt;&gt;SIL)
               <font color="#4169E1">AND</font> (RNCOMP(ECPSUGAR(FIRST(PPR)),SUGCP)=0)
               <font color="#4169E1">AND</font> (EVCOMP(ECPLCMHT(FIRST(PPR)),LCMCP)=-1) <font color="#4169E1">DO</font>
            PP:=PPR; PPR:=RED(PP);
         <strong><font color="#4169E1">END</font></strong>;
      <font color="#B22222">(* Insert CP. *)</font>
      SRED(PP,COMP(CP,PPR)); RETURN(P);
<strong><font color="#4169E1">END</font></strong> ECPSUGINS;



<strong><font color="#4169E1">PROCEDURE ECPSUGWRITE</font></strong>(CP: LIST);
<font color="#B22222">(* Extended critical pair write in case of the normal with sugar strategy.
   The extended critical pair CP is written in the output stream. *)</font>

<strong><font color="#228B22">VAR</font></strong> f,g, Cf,Ef,Rf, F,G: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   F:=ECPPOLY1(CP); G:=ECPPOLY2(CP);
   f:=EDIPUNEXTEND(F); g:=EDIPUNEXTEND(G);
   SWRITE("1st polynomial: "); DIWRIT(f,VALIS); BLINES(0);
   SWRITE("    with sugar "); RNWRIT(EDIPSUGAR(F)); BLINES(0);
   SWRITE("2nd polynomial: "); DIWRIT(g,VALIS); BLINES(0);
   SWRITE("    with sugar "); RNWRIT(EDIPSUGAR(G)); BLINES(0);
   DIPMAD(f, Cf,Ef,Rf);
   SWRITE("LCM <font color="#4169E1">of</font> their leading terms:");
   DIWRIT(DIPFMO(ADFI(Cf,1),ECPLCMHT(CP)),VALIS); BLINES(0);
   SWRITE("Sugar <font color="#4169E1">of</font> their S-polynomial: "); RNWRIT(ECPSUGAR(CP)); BLINES(0);
<strong><font color="#4169E1">END</font></strong> ECPSUGWRITE;



<font color="#B22222">(* ------------------------------------------------------------------------ *
 * 3.3 Further procedures w.r.t. the normal with sugar strategy             *
 * ------------------------------------------------------------------------ *)</font>


<strong><font color="#4169E1">PROCEDURE SugarUpdateVariableWeight</font></strong>;
<font color="#B22222">(* Update of the DIPAGB variable weight list in case of the normal with
   sugar strategy.
   If the actual DIPAGB variable weight list W is of the form W=(1,...,1)
   or W=SIL then W is replaced by the list W'=(1,...,1) such that W' and the
   variable list VALIS are of the same length. If W, however, has components
   different to 1 then it is tested whether W and VALIS are of the same length
   and in case this test is false an error message will occur. *)</font>

<strong><font color="#228B22">VAR</font></strong> V,W, v,w: LIST;
    OnlyOneSeen: BOOLEAN;

<strong><font color="#4169E1">BEGIN</font></strong>
   V:=VALIS;
   W:=DIPAGBOpt.VariableWeight;
   OnlyOneSeen:=TRUE;
   <font color="#4169E1">WHILE</font> (V&lt;&gt;SIL) <font color="#4169E1">AND</font> (W&lt;&gt;SIL) <font color="#4169E1">DO</font>
      ADV(V, v,V); ADV(W, w,W);
      <font color="#4169E1">IF</font> RNCOMP(RNINT(1),w)&lt;&gt;0 <font color="#4169E1">THEN</font> OnlyOneSeen:=FALSE; <strong><font color="#4169E1">END</font></strong>;
   <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">IF</font> OnlyOneSeen
      <font color="#4169E1">THEN</font> <font color="#B22222">(* All components of W up to now were 1. *)</font>
              <font color="#4169E1">IF</font> (V&lt;&gt;SIL) <font color="#4169E1">AND</font> (W=SIL)
              <font color="#4169E1">THEN</font> <font color="#B22222">(* Add (1,...,1) to the DIPAGB variable weight list until
                      it is of the same length as VALIS. *)</font>
                   W:=DIPAGBOpt.VariableWeight;
                   <font color="#4169E1">WHILE</font> V&lt;&gt;SIL <font color="#4169E1">DO</font>
                      ADV(V, v,V);
                      W:=COMP(RNINT(1),W);
                   <strong><font color="#4169E1">END</font></strong>;
                   SetDIPAGBVariableWeight(W); BLINES(1);
              <font color="#4169E1">ELSE</font> <font color="#4169E1">IF</font> <font color="#B22222">(* V=SIL AND *)</font> W&lt;&gt;SIL
                      <font color="#4169E1">THEN</font> <font color="#B22222">(* Test whether the rest of the DIPAGB variable
                              weight list is of the form (1,...,1) *)</font>
                           <font color="#4169E1">WHILE</font> OnlyOneSeen <font color="#4169E1">AND</font> (W&lt;&gt;SIL) <font color="#4169E1">DO</font>
                              ADV(W, w,W);
                              <font color="#4169E1">IF</font> RNCOMP(RNINT(1),w)&lt;&gt;0
                                 <font color="#4169E1">THEN</font> OnlyOneSeen:=FALSE;
                              <strong><font color="#4169E1">END</font></strong>;
                           <strong><font color="#4169E1">END</font></strong>;
                           <font color="#4169E1">IF</font> OnlyOneSeen
                              <font color="#4169E1">THEN</font> <font color="#B22222">(* The test above is true. So the new DIPAGB
                                      variable weight list should be the list
                                      (1,...,1) of the length |VALIS|. *)</font>
                                   V:=VALIS; W:=SIL;
                                   <font color="#4169E1">WHILE</font> V&lt;&gt;SIL <font color="#4169E1">DO</font>
                                      ADV(V, v,V);
                                      W:=COMP(RNINT(1),W);
                                   <strong><font color="#4169E1">END</font></strong>;
                                   SetDIPAGBVariableWeight(W); BLINES(1);
                              <font color="#4169E1">ELSE</font> <font color="#B22222">(* The test above is false. *)</font>
                                   WriteDIPAGBVariableWeight;
                                   ERROR(fatal,
                                      "DIPAGB: no valid variable weight list");
                           <strong><font color="#4169E1">END</font></strong>;
                   <strong><font color="#4169E1">END</font></strong>;
           <strong><font color="#4169E1">END</font></strong>;
      <font color="#4169E1">ELSE</font> <font color="#B22222">(* At least one component of W was different to 1. *)</font>
           <font color="#4169E1">IF</font> ((V=SIL) <font color="#4169E1">AND</font> (W&lt;&gt;SIL)) <font color="#4169E1">OR</font> ((V&lt;&gt;SIL) <font color="#4169E1">AND</font> (W=SIL))
              <font color="#4169E1">THEN</font> WriteDIPAGBVariableWeight;
                   ERROR(fatal,"DIPAGB: no valid variable weight list");
           <strong><font color="#4169E1">END</font></strong>;
   <strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> SugarUpdateVariableWeight;



<font color="#B22222">(*****************************************************************************
 * 4. Option Handling                                                        *
 *****************************************************************************)</font>


<strong><font color="#4169E1">PROCEDURE InitDIPAGB</font></strong>;
<font color="#B22222">(* Initialization of the DIPAGB options. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.TraceFlag            := 0;
   DIPAGBOpt.Strategy             := Normal;
   DIPAGBOpt.VariableWeight       := SIL;
   DIPAGBOpt.UpdateVariableWeight := NOP;
   DIPAGBOpt.Update               := UPDATE;
   DIPAGBOpt.InitUpdate           := UPDATE;
   DIPAGBOpt.CPExtend             := ECPNORCON;
   DIPAGBOpt.DIPExtend            := IDF1;
   DIPAGBOpt.ECPInsert            := ECPNORINS;
   DIPAGBOpt.ECPSelect            := ADV;
   DIPAGBOpt.ECPWrite             := ECPNORWRITE;
   DIPAGBOpt.EDIPNormalform       := ADPNF;
   DIPAGBOpt.EDIPSPolynomial      := ADPSP;
   DIPAGBOpt.EDIPUnExtend         := IDF1;
   DIPAGBOpt.EDIPWrite            := EDIPNORWRITE;
<strong><font color="#4169E1">END</font></strong> InitDIPAGB;



<strong><font color="#4169E1">PROCEDURE SetCPExtend</font></strong>(EXT: PROCF2);
<font color="#B22222">(* Set the critical pair extension function. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.CPExtend:=EXT;
<strong><font color="#4169E1">END</font></strong> SetCPExtend;



<strong><font color="#4169E1">PROCEDURE SetDIPAGBOptions</font></strong>(OPT: LIST);
<font color="#B22222">(* Set the trace flag, the strategy and the variable weight list in the
   DIPAGB option record. *)</font>

<strong><font color="#228B22">VAR</font></strong> L: GAMMAINT;

<strong><font color="#4169E1">BEGIN</font></strong>
   L:=LENGTH(OPT);
   <font color="#4169E1">IF</font> L&gt;=1  <font color="#4169E1">THEN</font> SetDIPAGBTraceFlag(FIRST(OPT)); BLINES(1); <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">IF</font> L&gt;=2  <font color="#4169E1">THEN</font> SetDIPAGBStrategy(SECOND(OPT)); BLINES(1); <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">IF</font> L&gt;=3  <font color="#4169E1">THEN</font> SetDIPAGBVariableWeight(THIRD(OPT)); BLINES(1); <strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> SetDIPAGBOptions;



<strong><font color="#4169E1">PROCEDURE SetDIPAGBStrategy</font></strong>(st: LIST);
<font color="#B22222">(* Set the DIPAGB strategy option for the extended critical pair selection.
   st=0 (= normal) and st=1 (= normal with sugar) are supported. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.Strategy := st;
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 3 <font color="#4169E1">THEN</font>
      SWRITE("New strategy: "); AWRITE(st);
      <font color="#4169E1">CASE</font> st <font color="#4169E1">OF</font>
         0: SWRITE("  (= normal)           ") |
         1: SWRITE("  (= normal with sugar)")
         <font color="#4169E1">ELSE</font> ERROR(fatal, "SetDIPAGBStrategy: No valid strategy.");
      <strong><font color="#4169E1">END</font></strong>;
   <strong><font color="#4169E1">END</font></strong>;
   <font color="#4169E1">CASE</font> st <font color="#4169E1">OF</font>
      0: SetUpdateVariableWeight(NOP);
         SetCPExtend(ECPNORCON);
         SetDIPExtend(IDF1);
         SetECPInsert(ECPNORINS);
         SetECPWrite(ECPNORWRITE);
         SetEDIPNormalform(ADPNF);
         SetEDIPSPolynomial(ADPSP);
         SetEDIPUnExtend(IDF1);
         SetEDIPWrite(EDIPNORWRITE)
         |
      1: SetUpdateVariableWeight(SugarUpdateVariableWeight);
         SetCPExtend(ECPSUGCON);
         SetDIPExtend(DIPSUGEXT);
         SetECPInsert(ECPSUGINS);
         SetECPWrite(ECPSUGWRITE);
         SetEDIPNormalform(ADPSUGNF);
         SetEDIPSPolynomial(ADPSUGSP);
         SetEDIPUnExtend(FIRST);
         SetEDIPWrite(EDIPSUGWRITE)	
   <strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> SetDIPAGBStrategy;



<strong><font color="#4169E1">PROCEDURE SetDIPAGBTraceFlag</font></strong>(tf: LIST);
<font color="#B22222">(* Set the DIPAGB trace flag.
   tf is a non-negative integer level for interactive documentations. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.TraceFlag := tf;
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 3 <font color="#4169E1">THEN</font>
      SWRITE("New documentation level: "); AWRITE(tf);
   <strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> SetDIPAGBTraceFlag;



<strong><font color="#4169E1">PROCEDURE SetDIPAGBVariableWeight</font></strong>(VW: LIST);
<font color="#B22222">(* Set the DIPAGB variable weight list for the normal with sugar strategy.
   VW is a list of r non-negative rational components where r is the number of
   variables in the distributive polynomials handled with. The i-th component
   is the weight of the i-th variable in the variable list VALIS. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   <font color="#4169E1">IF</font> DIPAGBOpt.TraceFlag &gt;= 3 <font color="#4169E1">THEN</font>
      SWRITE("New variable weight list: "); LRNWRIT(VW);
   <strong><font color="#4169E1">END</font></strong>;
   DIPAGBOpt.VariableWeight := INV(VW);
<strong><font color="#4169E1">END</font></strong> SetDIPAGBVariableWeight;



<strong><font color="#4169E1">PROCEDURE SetDIPExtend</font></strong>(EXT: PROCF1);
<font color="#B22222">(* Set the distributive polynomial extension function. *)</font> 

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.DIPExtend:=EXT;
<strong><font color="#4169E1">END</font></strong> SetDIPExtend;



<strong><font color="#4169E1">PROCEDURE SetECPInsert</font></strong>(INS: PROCF2);
<font color="#B22222">(* Set the extended critical pair insertion function. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.ECPInsert:=INS;
<strong><font color="#4169E1">END</font></strong> SetECPInsert;



<strong><font color="#4169E1">PROCEDURE SetECPSelect</font></strong>(SEL: PROCP1V2);
<font color="#B22222">(* Set the extended critical pair selection procedure. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.ECPSelect:=SEL;
<strong><font color="#4169E1">END</font></strong> SetECPSelect;



<strong><font color="#4169E1">PROCEDURE SetECPWrite</font></strong>(WR: PROCP1);
<font color="#B22222">(* Set the extended critical pair write procedure. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.ECPWrite:=WR;
<strong><font color="#4169E1">END</font></strong> SetECPWrite;



<strong><font color="#4169E1">PROCEDURE SetEDIPNormalform</font></strong>(NF: PROCF2);
<font color="#B22222">(* Set the extended distributive polynomial normalform function. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.EDIPNormalform:=NF;
<strong><font color="#4169E1">END</font></strong> SetEDIPNormalform;



<strong><font color="#4169E1">PROCEDURE SetEDIPSPolynomial</font></strong>(SP: PROCF2);
<font color="#B22222">(* Set the extended distributive S-polynomial function. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.EDIPSPolynomial:=SP;
<strong><font color="#4169E1">END</font></strong> SetEDIPSPolynomial;


 
<strong><font color="#4169E1">PROCEDURE SetEDIPUnExtend</font></strong>(UEXT: PROCF1);
<font color="#B22222">(* Set the extended distributive polynomial un-extension function. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.EDIPUnExtend:=UEXT;
<strong><font color="#4169E1">END</font></strong> SetEDIPUnExtend;



<strong><font color="#4169E1">PROCEDURE SetEDIPWrite</font></strong>(WR: PROCP1);
<font color="#B22222">(* Set the extended distributive polynomial write procedure. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.EDIPWrite:=WR;
<strong><font color="#4169E1">END</font></strong> SetEDIPWrite;



<strong><font color="#4169E1">PROCEDURE SetInit</font></strong>(INIT: PROCP1V2);
<font color="#B22222">(* Set the initialization procedure. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.InitUpdate:=INIT;
<strong><font color="#4169E1">END</font></strong> SetInit;



<strong><font color="#4169E1">PROCEDURE SetUpdate</font></strong>(UPD: PROCP1V2);
<font color="#B22222">(* Set the update procedure. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.Update:=UPD;
<strong><font color="#4169E1">END</font></strong> SetUpdate;



<strong><font color="#4169E1">PROCEDURE SetUpdateVariableWeight</font></strong>(UPD: PROCP0);
<font color="#B22222">(* Set the DIPAGB variable weight update procedure. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   DIPAGBOpt.UpdateVariableWeight:=UPD;
<strong><font color="#4169E1">END</font></strong> SetUpdateVariableWeight;



<strong><font color="#4169E1">PROCEDURE WriteDIPAGBOptions</font></strong>;
<font color="#B22222">(* Write the current trace flag, strategy and variable weight list of the
   DIPAGB option record in the output stream. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   WriteDIPAGBTraceFlag;      BLINES(0);
   WriteDIPAGBStrategy;       BLINES(0);
   WriteDIPAGBVariableWeight; BLINES(0);
<strong><font color="#4169E1">END</font></strong> WriteDIPAGBOptions;



<strong><font color="#4169E1">PROCEDURE WriteDIPAGBStrategy</font></strong>;
<font color="#B22222">(* Write the DIPAGB strategy option for the extended critical pair selection
   in the output stream. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   SWRITE("Actual strategy: "); AWRITE(DIPAGBOpt.Strategy);
   <font color="#4169E1">CASE</font> DIPAGBOpt.Strategy <font color="#4169E1">OF</font>
      0: SWRITE("  (= normal)           ") |
      1: SWRITE("  (= normal with sugar)")
   <strong><font color="#4169E1">END</font></strong>;
   BLINES(0);
<strong><font color="#4169E1">END</font></strong> WriteDIPAGBStrategy;



<strong><font color="#4169E1">PROCEDURE WriteDIPAGBTraceFlag</font></strong>;
<font color="#B22222">(* Write the DIPAGB trace flag in the output stream. *)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
   SWRITE("Actual documentation level: "); AWRITE(DIPAGBOpt.TraceFlag);
   BLINES(0);
<strong><font color="#4169E1">END</font></strong> WriteDIPAGBTraceFlag;



<strong><font color="#4169E1">PROCEDURE WriteDIPAGBVariableWeight</font></strong>;
<font color="#B22222">(* Write the DIPAGB variable weight list in the output stream. *)</font>

<strong><font color="#228B22">VAR</font></strong> WL, RN: LIST;

<strong><font color="#4169E1">BEGIN</font></strong>
   SWRITE("Actual variable weight list: ");
   LRNWRIT(CINV(DIPAGBOpt.VariableWeight));
   BLINES(0);
<strong><font color="#4169E1">END</font></strong> WriteDIPAGBVariableWeight;



<font color="#B22222">(*****************************************************************************
 * 5. Main Program                                                           *
 *****************************************************************************)</font>


<strong><font color="#4169E1">BEGIN</font></strong>
   LISTVAR(DIPAGBOpt.VariableWeight);
   InitDIPAGB;
<strong><font color="#4169E1">END</font></strong> DIPAGB.

<font color="#B22222">(* -EOF- *)</font>
</pre>
</body>

</html>
