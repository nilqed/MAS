
<html>
<head>
<title>./maslog/PQSMPL.mi</title>
<meta name="generator" content="pas2html 0.9.2">
<meta name="date" content="1995-11-04T18:00:28+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80"><font color="#B22222">(* ----------------------------------------------------------------------------
 * $Id: PQSMPL.mi,v 1.3 1995/11/04 18:00:28 pesch Exp $
 * ----------------------------------------------------------------------------
 * Copyright (c) 1993 Universitaet Passau
 * ----------------------------------------------------------------------------
 * This file is part of MAS.
 * ----------------------------------------------------------------------------
 * $Log: PQSMPL.mi,v $
 * Revision 1.3  1995/11/04 18:00:28  pesch
 * Changed comments violating documentation rules. Should be rewritten.
 *
 * Revision 1.2  1994/11/28  21:12:09  dolzmann
 * Moved procedures from PQSMPL into PQBASE.
 *
 * Revision 1.1  1993/12/18  20:12:20  dolzmann
 * System for the simplification of boolean combinations of polynomial 
 * equations.
 * 
 * ----------------------------------------------------------------------------
 *)</font>

IMPLEMENTATION MODULE PQSMPL;
<font color="#B22222">(* Polynomial Equation Simplification Implementation Module. *)</font>

<font color="#B22222">(******************************************************************************
*    P O L Y N O M I A L   E Q U A T I O N   S I M P L I F I C A T I O N      *
*-----------------------------------------------------------------------------*
* Author:   Andreas Dolzmann                                                  *
* Language: Modula II                                                         *
* System:   This program is written for the computer algebra system MAS by    *
*           Heinz Kredel.                                                     *
* Remark:   Libraries maskern, maslisp and maslog, masdom, maspoly, ...       *
*           are used.                                                         *
* Abstract: A program for simplification of polynomial equations and          *
*           inequations in the field of the complex numbers.                  *
******************************************************************************)</font>

FROM MASELEM	IMPORT	GAMMAINT;
FROM MASSTOR	IMPORT	ADV, COMP, FIRST, INV, LENGTH, LIST, LIST1, LISTVAR,
			RED, SFIRST, SIL, SRED;
FROM MASBIOS	IMPORT	BKSP, BLINES, CREAD, CREADB, CWRITE, DIBUFF, DIGIT,
			LETTER, LISTS, MASORD, SWRITE;
FROM SACLIST	IMPORT	ADV2, ADV3, ADV4, AWRITE, CCONC, CINV, CLOUT, COMP2,
			CONC, EQUAL, LIST10, LIST2, LIST3, LIST4, LIST5,
			MEMBER, SECOND, THIRD; 
FROM MASERR	IMPORT	ERROR, confusion, fatal, harmless, severe, spotless;
FROM MASSYM	IMPORT	ATOM, MEMQ;
FROM MASSYM2	IMPORT	ASSOC, ASSOCQ, EXPLOD, SREAD1, SYMBOL, UREAD, UWRIT1,
			UWRITE;
FROM MASLISPU	IMPORT	Declare;
FROM MLOGBASE	IMPORT	ET, FALSUM, FORGARGS, FORGOP, FORMKBINOP, FORMKFOR,
			FORMKUNOP, FORPARGS, FORPBINOP, FORPFOR, FORPUNOP,
			FORPUNOPA, IMP, NON, TVAR, VEL, VERUM;
FROM MASLOG	IMPORT	FORAPPLYAT, FORELIMXOPS, FORMKCNF, FORMKDNF,
			FORMKPOS, FORSMPL, FORMKPRENEX, FORMKPRENEX1; 
FROM MLOGIO	IMPORT	FORIREAD, FORPPRT, FORPREAD, FORTEXW, KEYREAD;
FROM DIPADOM	IMPORT	DILWR, DIPNEG, DIPROD, DIPSUM, DIREAD, DIWRIT;
FROM DIPC	IMPORT	DILBSO, DIPBSO, DIPFMO, DIPINV, DIPLPM, DIPMAD,
			DIPNOV, EVORD, EVSIGN, GRLEX, IGRLEX, INVLEX, LEX,
			REVILEX, REVITDG, REVLEX, REVTDEG, VALIS;
FROM DIPGB	IMPORT	DIIFGB, DIIFNF, DILIS, DIPGB, DIPNOR;
FROM MASADOM	IMPORT	ADDDWRIT, ADFI, ADDDREAD;
FROM SACSET	IMPORT	LBIBMS;
FROM SACPOL	IMPORT	VLREAD, VLWRIT; 
FROM PQBASE	IMPORT	DOMAIN, PQMKCNF, PQMKDNF, PQSMPL, PQMKPRENEX,
			PQELIMXOPS, pqmkaf, pqpaf, PQIREAD, PQPPRT, EQU, NEQ;
FROM DIPTOOLS	IMPORT	ADDDFDIP, DILINV, DILPROD, DIPONE, DIPPOWER,
			EvordPop, EvordPush, ValisPop, ValisPush; 


<strong><font color="#228B22">TYPE</font></strong> SetRel=(subset,superset,setequal,setnorel); 

<strong><font color="#228B22">CONST</font></strong> rcsidi = "$Id: PQSMPL.mi,v 1.3 1995/11/04 18:00:28 pesch Exp $";
<strong><font color="#228B22">CONST</font></strong> copyrighti = "Copyright (c) 1993 Universitaet Passau";

<font color="#B22222">(******************************************************************************
*                       G L O B A L   V A R I A B L E S                       *
******************************************************************************)</font>

<strong><font color="#228B22">VAR</font></strong> PQTRACE: LIST;	<font color="#B22222">(* This variable determines, how many tracing 
			   output is printed. *)</font> 
<strong><font color="#228B22">VAR</font></strong> PQRMSTest: LIST; 	<font color="#B22222">(* This variable determines the method for the radical
			   mebership test. (Radical Membership Test)*)</font>
<strong><font color="#228B22">VAR</font></strong> PQPOWERS: LIST;     <font color="#B22222">(* A list of powers for a pseudo radical membership
			   test. *)</font>
<strong><font color="#228B22">VAR</font></strong> PQIBREP: LIST;	<font color="#B22222">(* This variable determines whether a ideal basis is 
			   replaced by another or not. (Ideal Basis REPlace) *)</font>
<strong><font color="#228B22">VAR</font></strong> PQREDCON: LIST;	<font color="#B22222">(* This variable determines wheter the conclusions
			   are reduced. *)</font>

<font color="#B22222">(******************************************************************************
*                         S I M P L I F I C A T I O N                         *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE PQSCNF</font></strong>(phi: LIST):LIST;
<font color="#B22222">(* polynomial equation simplification normal form. phi is an arbitrary 
quantifier-free formula. A equivalent formula in SCNF is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> nf: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	nf:=SimplifyNf(PQMKCNF(PQSMPL(phi)));
	<font color="#4169E1">IF</font> (nf=VERUM) <font color="#4169E1">OR</font> (nf=FALSUM) <font color="#4169E1">THEN</font>
		RETURN nf;
	<strong><font color="#4169E1">END</font></strong>;
	RETURN PQscnf(PQGetDataCnf(nf));
<strong><font color="#4169E1">END</font></strong> PQSCNF;

<strong><font color="#4169E1">PROCEDURE PQSDNF</font></strong>(phi: LIST):LIST;
<font color="#B22222">(* polynomial equation simplification normal form. phi is an arbitrary 
quantifier-free formula. A equivalent formula in SDNF is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> nf: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	nf:=SimplifyNf(PQMKCNF(PQSMPL(phi)));
	<font color="#4169E1">IF</font> (nf=VERUM) <font color="#4169E1">OR</font> (nf=FALSUM) <font color="#4169E1">THEN</font>
		RETURN nf;
	<strong><font color="#4169E1">END</font></strong>;
	RETURN PQsdnf(PQGetDataDnf(nf));
<strong><font color="#4169E1">END</font></strong> PQSDNF;

<strong><font color="#4169E1">PROCEDURE PQCnfSimplify</font></strong>(nu:LIST):LIST;
<font color="#B22222">(* polynomial equation cnf based simplification. nu is an quantifier free
formula. The formula nu is simplified. Consult the documentation for a 
description of the rules which are applied *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	DLSWRITE("starting cnf based simplification",1);
<font color="#B22222">(*	DLPQPRT("Input formula",nu,2); *)</font>
	RETURN PQSimplify1(SimplifyNf(PQMKCNF(PQSMPL(nu))),1); 
<strong><font color="#4169E1">END</font></strong> PQCnfSimplify;

<strong><font color="#4169E1">PROCEDURE PQDnfSimplify</font></strong>(nu:LIST):LIST;
<font color="#B22222">(* polynomial equation dnf based simplification. nu is an quantifier free
formula. The formula nu is simplified. Consult the documentation for a 
description of the rules which are applied *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	DLSWRITE("starting cnf based simplification",1);
<font color="#B22222">(*	DLPQPRT("Input formula",nu,2); *)</font>
	RETURN PQSimplify1(SimplifyNf(PQMKDNF(PQSMPL(nu))),2);
<strong><font color="#4169E1">END</font></strong> PQDnfSimplify;


<strong><font color="#4169E1">PROCEDURE PQSimplify1</font></strong>(nf,<strong><font color="#228B22">type</font></strong>: LIST):LIST;
<font color="#B22222">(* polynomial equation simplification. nf is a quantifier free formula
in cnf (type=1) or dnf (type=2). Consult the documentation for a description
of the rules which are applied. The formula is divided in two parts:
Implications of the form "(AND PHI=0) =&gt; gamma=0" and a conjunction of
the form "AND PSI=0". PHI=0 denotes a set of polynomial equations phi=0 and
PSI=0 denotes a set of polynomial equations psi=0. *)</font>
	<strong><font color="#228B22">VAR</font></strong> POLS, PSI, GB1, GBi2, PHI, GAMMA, gamma, phi: LIST;
	<strong><font color="#228B22">VAR</font></strong> gamma1: LIST;
	<strong><font color="#228B22">VAR</font></strong> GAMMA1, PHI1, phi1, B: LIST;
	<strong><font color="#228B22">VAR</font></strong> domain: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> (nf=VERUM) <font color="#4169E1">OR</font> (nf=FALSUM) <font color="#4169E1">THEN</font>
		DLPQPRT("Input formula in SNF",nf,2);
		RETURN nf;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> <strong><font color="#228B22">type</font></strong>=1 <font color="#4169E1">THEN</font>
		POLS:=PQGetData1(nf,1);	
		DLPQPRT("Input formula in SCNF",PQscnf(POLS),2);
	<font color="#4169E1">ELSE</font> 
		POLS:=PQGetData1(nf,2);	
		DLPQPRT("Input formula in SDNF",PQsdnf(POLS),2);
	<strong><font color="#4169E1">END</font></strong>;
	PSI:=THIRD(POLS);
	DLSWRITE("1.) consistency test over psi",1);
	GB1:=SIL;
	<font color="#4169E1">IF</font> PSI&lt;&gt;SIL <font color="#4169E1">THEN</font>
		domain:=ADDDFDIP(FIRST(PSI));
		GB1:=DIPADGB(PSI); <font color="#B22222">(* This computation is not necceary
					in the case of PQRMSTest&lt;=3 *)</font>
		<font color="#4169E1">IF</font> IdealMember(GB1,DIPONE(domain)) <font color="#4169E1">THEN</font>
			<font color="#4169E1">IF</font> <strong><font color="#228B22">type</font></strong>=1 <font color="#4169E1">THEN</font>
				RETURN FALSUM;
			<font color="#4169E1">ELSE</font>
				RETURN VERUM;
			<strong><font color="#4169E1">END</font></strong>
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">CASE</font> INTEGER(PQIBREP) <font color="#4169E1">OF</font>
		0:				|
		1: 	PSI:=DIPADIRSET(PSI);	|
		2:	PSI:=DIPADIRSET(GB1);
		<font color="#4169E1">ELSE</font> ERROR(severe,"PQIBREP unknown code!");
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	PHI:=FIRST(POLS);
	GAMMA:=SECOND(POLS);
	GAMMA1:=SIL;
	PHI1:=SIL;
	DLSWRITE("2.) simplification <font color="#4169E1">of</font> the implications",1);
	<font color="#4169E1">WHILE</font> PHI&lt;&gt;SIL <font color="#4169E1">DO</font>
		ADV(GAMMA,gamma,GAMMA);
		ADV(PHI,phi,PHI);
		<font color="#4169E1">IF</font> <font color="#4169E1">NOT</font> TestRMember(phi,GB1,gamma,B,gamma1) <font color="#4169E1">THEN</font> 
			GAMMA1:=COMP(gamma1,GAMMA1);
			PHI1:=COMP(B,PHI1);
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> <strong><font color="#228B22">type</font></strong>=1 <font color="#4169E1">THEN</font>
		RETURN PQSMPL(PQscnf(LIST3(INV(PHI1),INV(GAMMA1),PSI)));
	<font color="#4169E1">ELSE</font>
		RETURN PQSMPL(PQsdnf(LIST3(INV(PHI1),INV(GAMMA1),PSI)));
	<strong><font color="#4169E1">END</font></strong>
<strong><font color="#4169E1">END</font></strong> PQSimplify1;

<strong><font color="#4169E1">PROCEDURE SimplifyNf</font></strong>(nf: LIST):LIST;
<font color="#B22222">(* simplify normal form. nf is a formula in disjunctive normal form or
conjunctive normal form. A simplification of nf is returned.
Following rules are applied: Equal literals in clauses are contracted,
atomic formulas with identical polynomials are contracted to TRUE or FALSE. *)</font>
<font color="#B22222">(* Note: identical clauses are not contracted. This happens in the
GetDataXXX Procedures. In this procedure equal implications are contracted. *)</font>
	<strong><font color="#228B22">VAR</font></strong> literal, clause, lhs, rel, op1, op2, Literals, Clauses: LIST;
	<strong><font color="#228B22">VAR</font></strong>  PolRel, ResLits, ResClaus, assoc, s: LIST;
	<strong><font color="#228B22">VAR</font></strong> exit: BOOLEAN;
<strong><font color="#4169E1">BEGIN</font></strong>
	s:=PQSMPL(nf);    <font color="#B22222">(* To strong ! *)</font>
	<font color="#4169E1">IF</font> (s=VERUM) <font color="#4169E1">OR</font> (s=FALSUM) <font color="#4169E1">THEN</font> RETURN s; <strong><font color="#4169E1">END</font></strong>;
	FORPFOR(nf,op1,Clauses);
	ResClaus:=SIL;
	<font color="#4169E1">WHILE</font> Clauses&lt;&gt;SIL <font color="#4169E1">DO</font>
		ResLits:=SIL;
		PolRel:=SIL;
		FORPARGS(Clauses, clause, Clauses);
		FORPFOR(clause,op2,Literals);
		exit:=FALSE;
		<font color="#4169E1">WHILE</font> (Literals&lt;&gt;SIL) <font color="#4169E1">AND</font> <font color="#4169E1">NOT</font> exit <font color="#4169E1">DO</font>
			FORPFOR(Literals,literal,Literals);
			pqpaf(literal,rel,lhs);
			assoc:=ASSOCQ(lhs,PolRel);
			<font color="#4169E1">IF</font> assoc=SIL <font color="#4169E1">THEN</font>
				PolRel:=COMP2(lhs,rel,PolRel);
				ResLits:=COMP(literal,ResLits);
			ELSIF FIRST(assoc)&lt;&gt;rel <font color="#4169E1">THEN</font>
				DLSWRITE("smart simplify successful",3);
				ResLits:=SIL;
				exit:=TRUE;
			<font color="#4169E1">ELSE</font>
				DLSWRITE("identical atomic formulas deleted",
					3);
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> ResLits&lt;&gt;SIL <font color="#4169E1">THEN</font>
			ResClaus:=COMP(FORMKFOR(op2,INV(ResLits)),ResClaus);
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> (ResClaus=SIL) <font color="#4169E1">AND</font> (op1=ET) <font color="#4169E1">THEN</font>
		RETURN VERUM;
	ELSIF (ResClaus=SIL) <font color="#4169E1">AND</font> (op1=VEL) <font color="#4169E1">THEN</font>
		RETURN FALSUM;
	<font color="#4169E1">ELSE</font> <font color="#B22222">(* ResClaus&lt;&gt;SIL *)</font>
		RETURN FORMKFOR(op1,INV(ResClaus));
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> SimplifyNf;


<font color="#B22222">(******************************************************************************
*                          P R E P R O Z E S S I N G                          *
******************************************************************************)</font>

<font color="#B22222">(******************************************************************************
* data structure SNFC ("Simplification Normal Form Content")                  *
*                                                                             *
* This datastructure represents the important datas from a formula in SCNF    *
* or SDNF. A variable of the type SNFC is a list with three elements.         *
* The first and second elemts represents the first part of the S?NF and the   *
* third element the second part of the S?NF.                                  *
* The first and the second element are lists with one element for each        *
* implikation in the S?NF. Each element in the first list is a list of all    *
* polynomials in the premise of the implication. Each element in the second   *
* list is the polynomial in the conclusion. The third element is a list of    *
* all polynomials in the second part of the S?NF.                             *
******************************************************************************)</font>
 
<strong><font color="#4169E1">PROCEDURE PQGetDataCnf</font></strong>(cnf: LIST): LIST;
<font color="#B22222">(* polynomial equation get data from cnf. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	RETURN PQGetData1(cnf,1);
<strong><font color="#4169E1">END</font></strong> PQGetDataCnf;

<strong><font color="#4169E1">PROCEDURE PQGetDataDnf</font></strong>(dnf: LIST): LIST;
<font color="#B22222">(* polynomial equation get data from dnf. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	RETURN PQGetData1(dnf,2);
<strong><font color="#4169E1">END</font></strong> PQGetDataDnf;

<strong><font color="#4169E1">PROCEDURE PQGetData1</font></strong>(nf,<strong><font color="#228B22">type</font></strong>: LIST):LIST;
<font color="#B22222">(* polynomial equation get data. nf is a cnf (type=1) or a dnf (type=2).
The polynomials which occurs in the formula nf are extracted. 
The formula is  transformed in a formula with a structure 
similar to (OP (AND PHI_j=0) =&gt; gamma_i=0) OP (AND PSI=0). 
PHI_j=0 denotes a set of polynomial equations phi_ij=0 and PSI=0
denotes a set of polynomial equations psi=0. A list with the following 
format is returned. (PHI,GAMMA,PSI), where PHI is a list of a list of 
the polynomials in PHI_j, GAMMA is a list of the polynomials gamma_j, and 
PSI is a list of the polynomials on PSI=0. *)</font>
	<strong><font color="#228B22">VAR</font></strong> clause,atomic:LIST;
	<strong><font color="#228B22">VAR</font></strong> POS,NEG:LIST;
	<strong><font color="#228B22">VAR</font></strong> PHI,GAMMA,PSI: LIST;
	<strong><font color="#228B22">VAR</font></strong> dummy,HLP: LIST;
	<strong><font color="#228B22">VAR</font></strong> rel,pol,domain,af: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	PHI:=SIL; PSI:=SIL; GAMMA:=SIL;
	FORPFOR(nf,dummy,nf);
	<font color="#B22222">(* extract the domain descriptor *)</font>
	af:=FIRST(FORGARGS(FIRST(nf)));	<font color="#B22222">(* The first atomic formula of the 
					   first clause. *)</font>
	pqpaf(af,dummy,pol);
	domain:=ADDDFDIP(pol);
	<font color="#B22222">(* *** *)</font>
	<font color="#4169E1">WHILE</font> nf&lt;&gt;SIL <font color="#4169E1">DO</font>
		FORPARGS(nf,clause,nf);
		FORPFOR(clause,dummy,clause);
		POS:=SIL; NEG:=SIL;
		<font color="#4169E1">WHILE</font> clause&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(clause,atomic,clause);
			pqpaf(atomic,rel,pol);
			<font color="#4169E1">IF</font> rel=NEQ <font color="#4169E1">THEN</font>
				NEG:=COMP(pol,NEG);
			ELSIF rel=EQU <font color="#4169E1">THEN</font>
				POS:=COMP(pol,POS);
			<font color="#4169E1">ELSE</font>
				ERROR(severe,"unknown relation symbol");
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> <strong><font color="#228B22">type</font></strong>&lt;&gt;1 <font color="#4169E1">THEN</font>		<font color="#B22222">(* a logical negation is necessary *)</font>
			HLP:=NEG;
			NEG:=POS;
			POS:=HLP;
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> NEG=SIL <font color="#4169E1">THEN</font>		
			PSI:=SETADD(DILPROD(POS,domain),PSI);
		<font color="#4169E1">ELSE</font>
			NEG:=INV(NEG);
			POS:=DILPROD(POS,domain);
			<font color="#4169E1">IF</font> <font color="#4169E1">NOT</font> SeqPair(NEG,PHI,POS,GAMMA) <font color="#4169E1">THEN</font>
				PHI:=COMP(NEG,PHI);
				GAMMA:=COMP(POS,GAMMA);
			<font color="#4169E1">ELSE</font>
				DLSWRITE("identical implications deleted", 3);
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	RETURN LIST3(INV(PHI),INV(GAMMA),INV(PSI));
<strong><font color="#4169E1">END</font></strong> PQGetData1;

<font color="#B22222">(******************************************************************************
*                         P O S T P R O C E S S I N G                         *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE PQscnf</font></strong>(POLS: LIST):LIST;
<font color="#B22222">(* polynomial equation simplification conjunctive normal form. 
POLS is a list in the format, that PQGetDataCnf returns.
The SCNF associated with the list POLS is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> fst,snd: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	PQsnf1(POLS,1,fst,snd);
	<font color="#4169E1">IF</font> (fst=SIL) <font color="#4169E1">AND</font> (snd=SIL) <font color="#4169E1">THEN</font>
		RETURN VERUM;
	ELSIF fst=SIL <font color="#4169E1">THEN</font>
		RETURN FORMKFOR(ET,INV(snd));
	ELSIF snd=SIL <font color="#4169E1">THEN</font>
		RETURN FORMKFOR(ET,INV(fst));
	<font color="#4169E1">ELSE</font>
		RETURN FORMKBINOP(ET,FORMKFOR(ET,INV(fst)),
				     FORMKFOR(ET,INV(snd)));
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> PQscnf;

<strong><font color="#4169E1">PROCEDURE PQsdnf</font></strong>(POLS: LIST):LIST;
<font color="#B22222">(* polynomial equation simplification disjunctive normal form. 
POLS is a list in the format, that PQGetDataCnf returns.
The SDNF associated with the list POLS is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> fst, snd: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	PQsnf1(POLS,2,fst,snd);
	<font color="#4169E1">IF</font> (fst=SIL) <font color="#4169E1">AND</font> (snd=SIL) <font color="#4169E1">THEN</font>
		RETURN FALSUM;
	ELSIF fst=SIL <font color="#4169E1">THEN</font>
		RETURN FORMKUNOP(NON,FORMKFOR(ET,INV(snd)));
	ELSIF snd=SIL <font color="#4169E1">THEN</font>
		RETURN FORMKFOR(VEL,INV(fst));
	<font color="#4169E1">ELSE</font>
		RETURN FORMKBINOP(VEL,FORMKFOR(VEL,INV(fst)),
				     FORMKUNOP(NON,FORMKFOR(ET,INV(snd))));
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> PQsdnf;

<strong><font color="#4169E1">PROCEDURE PQsnf1</font></strong>(POLS,<strong><font color="#228B22">type</font></strong>:LIST;<strong><font color="#228B22">VAR</font></strong> fst,snd: LIST);
<font color="#B22222">(* polynomial equation simplification normal form. 
POLS is a list in the format, that PQGetDataCnf returns.
The first and the second part of the SCNF (type=1) or SDNF (type=2) 
is returned. fst=SIL or snd=sil indicates, that this part can be omitted. *)</font> 
	<strong><font color="#228B22">VAR</font></strong> PHIij, PHIj, phi, GAMMAi, gamma, PHIj1, PSIi, psi: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	ADV3(POLS,PHIij,GAMMAi,PSIi,POLS);
	fst:=SIL;
	<font color="#4169E1">WHILE</font> PHIij&lt;&gt;SIL <font color="#4169E1">DO</font>
		ADV(PHIij,PHIj,PHIij);
		ADV(GAMMAi,gamma,GAMMAi);
		PHIj1:=SIL;
		<font color="#4169E1">WHILE</font> PHIj&lt;&gt;SIL <font color="#4169E1">DO</font>
			ADV(PHIj,phi,PHIj);
			PHIj1:=COMP(pqmkaf(EQU,phi),PHIj1)
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> <strong><font color="#228B22">type</font></strong>=1 <font color="#4169E1">THEN</font>
			fst:=COMP(FORMKBINOP(IMP,FORMKFOR(ET,INV(PHIj1)),
				pqmkaf(EQU,gamma)),fst);
		<font color="#4169E1">ELSE</font>
			fst:=COMP(FORMKUNOP(NON,FORMKBINOP(IMP,FORMKFOR(ET,
				INV(PHIj1)),pqmkaf(EQU,gamma))),fst);
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	snd:=SIL;
	<font color="#4169E1">WHILE</font> PSIi&lt;&gt;SIL <font color="#4169E1">DO</font>
		ADV(PSIi,psi,PSIi);
		snd:=COMP(pqmkaf(EQU,psi),snd);
	<strong><font color="#4169E1">END</font></strong>;
	RETURN;
<strong><font color="#4169E1">END</font></strong> PQsnf1;


<font color="#B22222">(******************************************************************************
*                       I D E A L   P R O C E D U R E S                       *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE TestRMember</font></strong>(F,G,p:LIST; <strong><font color="#228B22">VAR</font></strong> B,p1: LIST):BOOLEAN;
<font color="#B22222">(* test radical membership. F is a final radical basis, 
G is a Groebner basis. p is a polynomial. If true is 
returned then p in RAD(F join G). Note: If p is in the radical
then true is not necessary returned! 
A new ideal basis of Id(F) is assigned to B. *)</font>
	<strong><font color="#228B22">VAR</font></strong> result:BOOLEAN;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">CASE</font> INTEGER(PQIBREP) <font color="#4169E1">OF</font>
	0:	result:=TestRMember1(F,G,p,p1);
		B:=F;						|	
	1:	B:=DIPADIRSET(F);	
		result:=TestRMember1(F,G,p,p1);			|
	2:	B:=DIPADGB(F);
		result:=TestRMember1(SIL,DIPADGBunion(B,G),p,p1);
	<font color="#4169E1">ELSE</font> 	ERROR(severe,"PQIBREP unknown code!");
	<strong><font color="#4169E1">END</font></strong>;		
	RETURN result;
<strong><font color="#4169E1">END</font></strong> TestRMember;

<strong><font color="#4169E1">PROCEDURE TestRMember1</font></strong>(F,G,p:LIST;<strong><font color="#228B22">VAR</font></strong> p1: LIST):BOOLEAN;
<font color="#B22222">(* test radical membership 1. F is a final radical basis, 
G is a Groebner basis. p is a polynomial. If true is 
returned then p in RAD(F join G). Note: If p is in the radical
then true is not necessary returned! *)</font>
	<strong><font color="#228B22">VAR</font></strong> GB, F1, F0, RGB, power, POWERS: LIST;
	<strong><font color="#228B22">VAR</font></strong> result: BOOLEAN;
	<strong><font color="#228B22">VAR</font></strong> domain:LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> p=0 <font color="#4169E1">THEN</font> RETURN TRUE; <strong><font color="#4169E1">END</font></strong>;
	domain:=ADDDFDIP(p);
	result:=FALSE;
	<font color="#4169E1">CASE</font> INTEGER(PQRMSTest) <font color="#4169E1">OF</font>
	1:	result:=MEMBER(p,CCONC(G,F))=1; 		|
	2: 	F1:=CCONC(G,F);
		result:=(MEMBER(p,F1)=1) <font color="#4169E1">OR</font> (DIPADNF(F1,p)=0);	|
	3:	F0:=CCONC(G,F);
		F1:=DIPADIRSET(F0);	
		result:=(MEMBER(p,F0)=1) <font color="#4169E1">OR</font> (MEMBER(p,F1)=1)
			<font color="#4169E1">OR</font> (DIPADNF(F1,p)=0);	|
	4: 	GB:=DIPADGBext(G,F);
		result:=IdealMember(GB,p) 			|
	5:	POWERS:=PQPOWERS;
		<font color="#4169E1">IF</font> EQUAL(DIPONE(domain),p)=1 <font color="#4169E1">THEN</font>
			POWERS:=LIST1(1);
		<strong><font color="#4169E1">END</font></strong>;
		GB:=DIPADGBext(G,F);	
		<font color="#4169E1">WHILE</font> (POWERS&lt;&gt;SIL) <font color="#4169E1">AND</font> <font color="#4169E1">NOT</font> result <font color="#4169E1">DO</font>
			ADV(POWERS,power,POWERS);
			<font color="#4169E1">IF</font> IdealMember(GB,DIPPOWER(p,power)) <font color="#4169E1">THEN</font>
				result:=TRUE;
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>; 						|
	6: 	GB:=DIPADGBext(G,F);
		result:= (IdealMember(GB,p) <font color="#4169E1">OR</font>
			RadicalMember(GB,p)) 			|
	7: 	<font color="#B22222">(* GB:=DIPADGBext(G,F); 
		result:=RadicalMember(GB,p); *)</font>
		result:=RadicalMember(CCONC(G,F),p); 
	<font color="#4169E1">ELSE</font>
		ERROR(severe,"TestRMember: unknown code");
		RETURN FALSE;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> (PQRMSTest&gt;3) <font color="#4169E1">AND</font> (PQREDCON=1) <font color="#4169E1">THEN</font>
		DLSWRITE("computing the normal form <font color="#4169E1">of</font> the conclusion",2);
		p1:=DIPADNF(GB,p);
		DLSWRITE("... finished.",2);
	<font color="#4169E1">ELSE</font>
		p1:=p;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> PQTRACE&gt;=1 <font color="#4169E1">THEN</font>
		<font color="#4169E1">IF</font> result <font color="#4169E1">THEN</font>
			SWRITE("Radical membership test ");
			AWRITE(PQRMSTest);
			SWRITE(" succeed.");
			BLINES(0); 
		<font color="#4169E1">ELSE</font>
			SWRITE("Radical membership test ");
			AWRITE(PQRMSTest);
			SWRITE(" failed.");
			BLINES(0); 
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	RETURN result;
<strong><font color="#4169E1">END</font></strong> TestRMember1;

<strong><font color="#4169E1">PROCEDURE IdealMember</font></strong>(G,p:LIST):BOOLEAN;
<font color="#B22222">(* ideal membership test. G is groebner basis. Iff p in ID(g) then 1 
is returned otherwise 0. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	RETURN DIPADNF(G,p)=0;
<strong><font color="#4169E1">END</font></strong> IdealMember;

<strong><font color="#4169E1">PROCEDURE RadicalMember</font></strong>(G,p:LIST):BOOLEAN;
<font color="#B22222">(* radical membership test. G is an ideal basis. Iff p in RAD(G) then 1 is
returned otherwise 0. The new variable Rw is introduced. *)</font>
	<strong><font color="#228B22">VAR</font></strong> G1, G2: LIST;
	<strong><font color="#228B22">VAR</font></strong> result: BOOLEAN;
	<strong><font color="#228B22">VAR</font></strong> p1: LIST;
	<strong><font color="#228B22">VAR</font></strong> domain: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> p=0 <font color="#4169E1">THEN</font> RETURN TRUE; <strong><font color="#4169E1">END</font></strong>;
	domain:=ADDDFDIP(p);
	G1:=DILINV(G,0,1);
	p1:=DIPINV(p,0,1);
	ValisPush(COMP(LIST2(45,54),VALIS));
<font color="#B22222">(*	G2:=DIPADGBext(G1,LIST1(rabinowitsch(p1)));*)</font>
	G2:=DIPADGB(COMP(rabinowitsch(p1),G1));
	result:=DIPADNF(G2,DIPONE(domain))=0;
	ValisPop();
	RETURN result;
<strong><font color="#4169E1">END</font></strong> RadicalMember;

<strong><font color="#4169E1">PROCEDURE rabinowitsch</font></strong>(p:LIST):LIST;
<font color="#B22222">(* rabinowitsch. p is a non zero polynomial.
The polynomial 1-Zp is returned. Z denotes the variable with the exponent
vector (0,...,0,1). *)</font>
	<strong><font color="#228B22">VAR</font></strong> z,zexp,nov,dipone: LIST;
	<strong><font color="#228B22">VAR</font></strong> domain: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	domain:=ADDDFDIP(p);
	nov:=DIPNOV(p);
	dipone:=DIPFMO(ADFI(domain,1),GenEV(0,nov));
	zexp:=GenEV(0,nov-1);
	zexp:=INV(COMP(1,zexp));
	z:=DIPFMO(ADFI(domain,1),zexp);
	RETURN DIPSUM(dipone,DIPNEG(DIPROD(z,p)));
<strong><font color="#4169E1">END</font></strong> rabinowitsch;


<font color="#B22222">(******************************************************************************
*                       D I P A D - P R O C E D U R E S                       *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE DIPADGB</font></strong>(P:LIST):LIST;
<font color="#B22222">(* distributive polynomial arbitrary domain groebner basis. P is a list of
polynomials (over the ring of integers). A groebner basis of P is returned.
This procedure is at moment only a dummy procedure. It should
calculate a groebner basis in respect to the coefficient ring of the
polynomials. *)</font>
	<strong><font color="#228B22">VAR</font></strong> g:LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	DLSWRITE("Computing a Groebner Base ...",2);
	g:=DIPGB(P,0);
	DLSWRITE("... finished!",2);
	RETURN g;
<strong><font color="#4169E1">END</font></strong> DIPADGB;

<strong><font color="#4169E1">PROCEDURE DIPADNF</font></strong>(P,S:LIST):LIST;
<font color="#B22222">(* distributive polynomial arbitrary domain normal form. P is a list of
polynomials. The normal form of the polynomial
S w.r.t. P is returned. This procedure is at moment only a dummy. Is should
work on Polynomials over arbitrary fields and rings. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	RETURN DIPNOR(P,S);
<strong><font color="#4169E1">END</font></strong> DIPADNF;

<strong><font color="#4169E1">PROCEDURE DILADNF</font></strong>(P,S:LIST):LIST;
<font color="#B22222">(* distributive polynomial list arbitrary domain normal form. P is a list of
polynomials. S is a list of polynomials.
The list of normal forms of the polynomials of 
S w.r.t. P is returned. This procedure is at moment only a dummy. Is should
work on Polynomials over arbitrary fields and rings. *)</font>
	<strong><font color="#228B22">VAR</font></strong> s,result: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	result:=SIL;
	<font color="#4169E1">WHILE</font> S&lt;&gt;SIL <font color="#4169E1">DO</font>
		ADV(S,s,S);
		result:=COMP(DIPADNF(P,s),result);
	<strong><font color="#4169E1">END</font></strong>;
	RETURN INV(result);
<strong><font color="#4169E1">END</font></strong> DILADNF;

<strong><font color="#4169E1">PROCEDURE DIPADGBext</font></strong>(gb,pols:LIST):LIST;
<font color="#B22222">(* distributive polynomial arbitrary domain groebner basis extension.
gb is a groebner basis, pols is a list of polynomials.
A groebner basis of the ideal basis gb join pols is calculated and
returned. This procedure is at moment only a dummy. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> pols=SIL <font color="#4169E1">THEN</font> RETURN gb; <strong><font color="#4169E1">END</font></strong>;
	RETURN DIPADGB(CCONC(gb,pols));
<strong><font color="#4169E1">END</font></strong> DIPADGBext;

<strong><font color="#4169E1">PROCEDURE DIPADGBunion</font></strong>(gb1,gb2:LIST):LIST;
<font color="#B22222">(* distributive polynomial arbitrary domain groebner basis union. gb1 and
gb2 are groebner basis. A groebner basis of the ideal basis gb1 join gb2
is calculated and returned. This procedure is at moment only a dummy. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> gb2=SIL <font color="#4169E1">THEN</font> RETURN gb1; <strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> gb1=SIL <font color="#4169E1">THEN</font> RETURN gb2; <strong><font color="#4169E1">END</font></strong>;
	RETURN DIPADGB(CCONC(gb1,gb2));
<strong><font color="#4169E1">END</font></strong> DIPADGBunion;

<strong><font color="#4169E1">PROCEDURE DIPADIRSET</font></strong>(P:LIST):LIST;
<font color="#B22222">(* distributive polynomial arbitrary domain irreducible set. P is a list
of polynomials. A set PP of polynomials is returned. PP is the result of 
reducing each element p modulo P - {p} until no further reductions are 
possible. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	RETURN DILIS(P);
<strong><font color="#4169E1">END</font></strong> DIPADIRSET;

<strong><font color="#4169E1">PROCEDURE DIPADGBRED</font></strong>(gb: LIST):LIST;
<font color="#B22222">(* distributive polynomial groebner basis reduction. gb is a groebner basis
of distributive polynomials over an arbitrary domain. 
The unique reduced and ordered groebner basis to gp is returned. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> (gb=SIL) <font color="#4169E1">OR</font> (RED(gb)=SIL) <font color="#4169E1">THEN</font> RETURN gb; <strong><font color="#4169E1">END</font></strong>;
	RETURN DIPLPM(DILIS(gb));
<strong><font color="#4169E1">END</font></strong> DIPADGBRED;


<font color="#B22222">(******************************************************************************
*                   A U X I L I A R Y   P R O C E D U R E S                   *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE SETADD</font></strong>(elem,set: LIST):LIST;
<font color="#B22222">(* set add element. If the element elem is not in the set set, then
{elem} join set is returned else set is returned. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> MEMBER(elem,set)=1 <font color="#4169E1">THEN</font>
DLSWRITE("SETADD: element already in the set!",3);
		RETURN set;
	<font color="#4169E1">ELSE</font>
		RETURN COMP(elem,set);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> SETADD;

<strong><font color="#4169E1">PROCEDURE GenEV</font></strong>(value,length:LIST):LIST;
<font color="#B22222">(* generate exponent vector. A exponent vector of the length length with
entries value is generated. *)</font>
	<strong><font color="#228B22">VAR</font></strong> i: INTEGER;
	<strong><font color="#228B22">VAR</font></strong> result:LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	result:=SIL;
	<font color="#4169E1">FOR</font> i:=1 <font color="#4169E1">TO</font> length <font color="#4169E1">DO</font>
		result:=COMP(value,result);
	<strong><font color="#4169E1">END</font></strong>;
	RETURN result;
<strong><font color="#4169E1">END</font></strong> GenEV;

<strong><font color="#4169E1">PROCEDURE SeqPair</font></strong>(elem1,SEQ1,elem2,SEQ2:LIST): BOOLEAN;
<font color="#B22222">(* sequence pair. elem1 and elem2 are elements, SEQ1, SEQ2 are final sequences
with the same length.
1 is returned iff there is a n in Nat such that elem1=SEQ1_n and elem2=SEQ2_n.
*)</font>
	<strong><font color="#228B22">VAR</font></strong> seq1,seq2: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">WHILE</font> SEQ1&lt;&gt;SIL <font color="#4169E1">DO</font>
		ADV(SEQ1,seq1,SEQ1);
		ADV(SEQ2,seq2,SEQ2);
		<font color="#4169E1">IF</font> (EQUAL(seq1,elem1)=1) <font color="#4169E1">AND</font> (EQUAL(seq2,elem2)=1) <font color="#4169E1">THEN</font>
			RETURN TRUE;
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	RETURN FALSE;
<strong><font color="#4169E1">END</font></strong> SeqPair;

<font color="#B22222">(******************************************************************************
*                                O P T I O N S                                *
******************************************************************************)</font>
			
<strong><font color="#4169E1">PROCEDURE PQOPT</font></strong>(O:LIST):LIST;
<font color="#B22222">(* polynomial equation options. The options of the PQ-System are set.
The list O is of the following format: The first entry
is the trace level of the system, the second entry determines the method for 
the radical membership test, the third entry is a list of powers for the 
pseudo radical membership test, the fourth entry controls the replacement
of the premises of the implications, and the fifth entry controls the 
You can omit an entry of O 
by writing a -1 on the place of the entry. You need not specify all entries.
The old parameters are returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> old: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	old:=LIST5(PQTRACE,PQRMSTest,PQPOWERS,PQIBREP,PQREDCON);
	<font color="#4169E1">IF</font> O&lt;&gt;SIL <font color="#4169E1">THEN</font> 
		<font color="#4169E1">IF</font> FIRST(O)&lt;&gt;-1 <font color="#4169E1">THEN</font> ADV(O,PQTRACE,O);	<font color="#4169E1">ELSE</font> O:=RED(O); <strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> O&lt;&gt;SIL <font color="#4169E1">THEN</font> 
		<font color="#4169E1">IF</font> FIRST(O)&lt;&gt;-1 <font color="#4169E1">THEN</font> ADV(O,PQRMSTest,O);<font color="#4169E1">ELSE</font> O:=RED(O); <strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> O&lt;&gt;SIL <font color="#4169E1">THEN</font> 
		<font color="#4169E1">IF</font> FIRST(O)&lt;&gt;-1 <font color="#4169E1">THEN</font> ADV(O,PQPOWERS,O);	<font color="#4169E1">ELSE</font> O:=RED(O); <strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> O&lt;&gt;SIL <font color="#4169E1">THEN</font> 
		<font color="#4169E1">IF</font> FIRST(O)&lt;&gt;-1 <font color="#4169E1">THEN</font> ADV(O,PQIBREP,O);	<font color="#4169E1">ELSE</font> O:=RED(O); <strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> O&lt;&gt;SIL <font color="#4169E1">THEN</font> 
		<font color="#4169E1">IF</font> FIRST(O)&lt;&gt;-1 <font color="#4169E1">THEN</font> ADV(O,PQREDCON,O);	<font color="#4169E1">ELSE</font> O:=RED(O); <strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	RETURN old;
<strong><font color="#4169E1">END</font></strong> PQOPT;

<strong><font color="#4169E1">PROCEDURE PQOPTWR</font></strong>();
<font color="#B22222">(* polynomial options write. The options of the PQ-System are printed in the
output stream. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	SWRITE("The setting <font color="#4169E1">of</font> the options <font color="#4169E1">of</font> the PQ-System:");
	BLINES(0);
	SWRITE("  The trace level is "); AWRITE(PQTRACE);
	SWRITE(".");BLINES(0);
	SWRITE("  Radical memebership test using ");
	BLINES(0);
	<font color="#4169E1">CASE</font> INTEGER(PQRMSTest) <font color="#4169E1">OF</font>
	1:	SWRITE("    element test.");				|
	2:	SWRITE("    reduction with the ideal basis."); 		|
	3: 	SWRITE("    reduction with the interreduced ideal basis.");|
	4:	SWRITE("    ideal membership test.");			|
	5:	SWRITE("    ideal membership test with the ");
		<font color="#4169E1">IF</font> RED(PQPOWERS)=SIL <font color="#4169E1">THEN</font>
			SWRITE("power "); AWRITE(FIRST(PQPOWERS));
		<font color="#4169E1">ELSE</font>
			SWRITE("powers "); UWRIT1(PQPOWERS);
		<strong><font color="#4169E1">END</font></strong>;
		SWRITE(".");						|
	6:	SWRITE("    radical membership test after ideal membership test."); |
	7:	SWRITE("    radical membership test."); 		|
	<font color="#4169E1">ELSE</font>	SWRITE("    unknown test method specified!");
	<strong><font color="#4169E1">END</font></strong>;
	BLINES(0);
	<font color="#4169E1">CASE</font> INTEGER(PQIBREP) <font color="#4169E1">OF</font>
	0: 	SWRITE("  Conjunctions over polynomial equations are <font color="#4169E1">not</font> replaced."); |
	1:	SWRITE("  Reducing conjunctions over polynomial equations with the"); 
		BLINES(0);
		SWRITE("    interreduction-method.");	|
	2:	SWRITE("  Reducing conjunctions over polynomial equations with the");
		BLINES(0);
		SWRITE("    Groebner-Basis-method.");
	<font color="#4169E1">ELSE</font> 	SWRITE("WARNING: unknown code <font color="#4169E1">for</font> PQIBREP");
	<strong><font color="#4169E1">END</font></strong>;
	BLINES(0);
	<font color="#4169E1">IF</font> PQREDCON=0 <font color="#4169E1">THEN</font>
		SWRITE("  The conclusions in the implications are <font color="#4169E1">not</font> reduced.");
	<font color="#4169E1">ELSE</font>
		SWRITE("  The conclusions in the implications are reduced.");
	<strong><font color="#4169E1">END</font></strong>;
	BLINES(0);
<strong><font color="#4169E1">END</font></strong> PQOPTWR;

<font color="#B22222">(******************************************************************************
*                             D E B U G L E V E L                             *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE PQSetTrace</font></strong>(level:LIST):LIST;
<font color="#B22222">(* polynomial equation set debug level. The debug level is set to level.
The old value is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> old:LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	old:=PQTRACE;
	PQTRACE:=level;
	RETURN old;
<strong><font color="#4169E1">END</font></strong> PQSetTrace;

<strong><font color="#4169E1">PROCEDURE PQGetTrace</font></strong>():LIST;
<font color="#B22222">(* polynomial equation get debug level. The actual debug level is returned. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	RETURN PQTRACE;
<strong><font color="#4169E1">END</font></strong> PQGetTrace;

<strong><font color="#4169E1">PROCEDURE DLSWRITE</font></strong>(S: ARRAY <font color="#4169E1">OF</font> CHAR;level:LIST);
<font color="#B22222">(* debug level SWRITE. The string S is in dependency of the debug level
written to the output stream. In contrast to MAS a blank line is added.
(analogous to UWRITE and UWRIT1) *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> PQTRACE &gt;= level <font color="#4169E1">THEN</font>
		SWRITE(S);
		BLINES(0);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> DLSWRITE;

<strong><font color="#4169E1">PROCEDURE DLSWRIT1</font></strong>(S: ARRAY <font color="#4169E1">OF</font> CHAR;level:LIST);
<font color="#B22222">(* debug level SWRITE. The string S is in dependency of the debug level
written to the output stream. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> PQTRACE &gt;= level <font color="#4169E1">THEN</font>
		SWRITE(S);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> DLSWRIT1;

<strong><font color="#4169E1">PROCEDURE DLUWRITE</font></strong>(L,level:LIST);
<font color="#B22222">(* debug level UWRITE. The list L is in dependency of the debug level
written to the output stream. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> PQTRACE &gt;= level <font color="#4169E1">THEN</font>
		UWRITE(L);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> DLUWRITE;

<strong><font color="#4169E1">PROCEDURE DLUWRIT1</font></strong>(L,level:LIST);
<font color="#B22222">(* debug level UWRIT1. The list L is in dependency of the debug level
written to the output stream. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> PQTRACE &gt;= level <font color="#4169E1">THEN</font>
		UWRIT1(L);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> DLUWRIT1;

<strong><font color="#4169E1">PROCEDURE DLBLINES</font></strong>(n:LIST;level:LIST);
<font color="#B22222">(* debug level BLINES. n blank lines are in dependency of the debug level
written to the output stream. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> PQTRACE &gt;= level <font color="#4169E1">THEN</font>
		BLINES(n);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> DLBLINES;

<strong><font color="#4169E1">PROCEDURE DLPQPRT</font></strong>(S:ARRAY <font color="#4169E1">OF</font> CHAR; phi: LIST; level:LIST);
<font color="#B22222">(* debug level polynomial equation print. The string S is written to the
output stream, the the formula phi is written to the output stream. As the
final step a blank lines is written to the output stream. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> PQTRACE&gt;= level <font color="#4169E1">THEN</font>
		SWRITE(S);
		BLINES(0);
		PQPPRT(phi);
		BLINES(0);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> DLPQPRT;

<strong><font color="#4169E1">PROCEDURE PQDEMO</font></strong>();
<font color="#B22222">(* Demonstration for this package. *)</font>
	<strong><font color="#228B22">VAR</font></strong> V, phi: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	SWRITE("           ");
	SWRITE("D E M O N S T R A T I O N   O F   T H E   P Q - S Y S T E M");
	BLINES(2);
	SWRITE("Enter the list <font color="#4169E1">of</font> variables, please!");
	BLINES(1);
	V:=UREAD();
	VALIS:=V;
	BLINES(0);
	SWRITE("Enter the formula, please!");
	BLINES(1);
	phi:=PQIREAD();
	phi:=PQCnfSimplify(phi);
	BLINES(1);
	SWRITE("The result is:");
	PQPPRT(phi);
	BLINES(2);
<strong><font color="#4169E1">END</font></strong> PQDEMO;

<font color="#B22222">(******************************************************************************
*                                   M A I N                                   *
******************************************************************************)</font>

<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#B22222">(* *** listvar declarations for global variables. *** *)</font>
	LISTVAR(PQRMSTest);
	LISTVAR(PQPOWERS);
	LISTVAR(PQTRACE);
	LISTVAR(PQIBREP);
	LISTVAR(PQREDCON);
	<font color="#B22222">(* *** initialize the global variables. ***  *)</font>
	PQTRACE:=0;
	PQPOWERS:=LIST1(1);;
	PQRMSTest:=6;
	PQIBREP:=1;
	PQREDCON:=0;
<strong><font color="#4169E1">END</font></strong> PQSMPL.

<font color="#B22222">(* -EOF- *)</font>
</pre>
</body>

</html>
