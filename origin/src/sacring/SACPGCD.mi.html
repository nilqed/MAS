
<html>
<head>
<title>./sacring/SACPGCD.mi</title>
<meta name="generator" content="pas2html 0.9.2">
<meta name="date" content="1993-05-11T13:40:57+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80">
<font color="#B22222">(* ----------------------------------------------------------------------------
 * $Id: SACPGCD.mi,v 1.3 1992/10/15 16:29:05 kredel Exp $
 * ----------------------------------------------------------------------------
 * This file is part of MAS.
 * ----------------------------------------------------------------------------
 * Copyright (c) 1989 - 1992 Universitaet Passau
 * ----------------------------------------------------------------------------
 * $Log: SACPGCD.mi,v $
 * Revision 1.3  1992/10/15  16:29:05  kredel
 * Changed rcsid variable
 *
 * Revision 1.2  1992/02/12  17:35:02  pesch
 * Moved CONST definition to the right place
 *
 * Revision 1.1  1992/01/22  15:16:13  kredel
 * Initial revision
 *
 * ----------------------------------------------------------------------------
 *)</font>

IMPLEMENTATION MODULE SACPGCD;

<font color="#B22222">(* SAC Polynomial GCD and RES System Implementation Module. *)</font>



<font color="#B22222">(* Import lists and declarations. *)</font>

FROM MASELEM IMPORT MASMAX, MASODD, MASEVEN;

FROM MASSTOR IMPORT LIST, BETA, SIL,
                    ADV, FIRST, RED, SRED, SFIRST, COMP, INV;

FROM MASERR IMPORT ERROR, fatal;

FROM MASBIOS IMPORT SWRITE, BLINES;

FROM SACLIST IMPORT CONC, SECOND, FIRST2, LIST4, COMP2, 
                    OWRITE, EQUAL, LIST2, ADV2, CLOUT;

FROM SACI IMPORT ISIGNF, IEXP, IDPR, IGCD, ILCM, ILOG2, IMAX, 
                 ICOMP, IABSF, IMP2, IPROD, IQ; 

FROM SACM IMPORT MDHOM, MDINV, MDPROD, MDNEG;

FROM SACCOMB IMPORT IFACTL;

FROM SACPOL IMPORT PRIME, PDEG, PDEGV, PDEGSV, PINV, PLDCF, PLBCF, PFDP,
                   VCOMP, VMIN;

FROM SACIPOL IMPORT IPABS, IPCRA, IPIP, IPIQ, IPMAXN, IPFCB, 
                    IPPSR, IPFRP, IPEXP, IPNEG, IPPROD, IPQ, 
                    IPONE, IPSIGN, IPSUMN, IPDMV;

FROM SACMPOL IMPORT MPHOM, MPMDP, MPEMV, MPEVAL, MPINT, MPMON, 
                    MPPROD, MPPSR, MUPDER, MPQR, MPDIF, MPEXP, 
                    MPNEG, MPQ, MPUP, MPUQ; 

FROM SACRPOL IMPORT RPRNP;

FROM SACDPOL IMPORT DMUPNR, DPFP;

<strong><font color="#228B22">CONST</font></strong> rcsidi = "$Id: SACPGCD.mi,v 1.3 1992/10/15 16:29:05 kredel Exp $";
<strong><font color="#228B22">CONST</font></strong> copyrighti = "Copyright (c) 1989 - 1992 Universitaet Passau";



<strong><font color="#4169E1">PROCEDURE IPC</font></strong>(RL,A: LIST): LIST; 
<font color="#B22222">(*Integral polynomial content.  A is an integral polynomial in r
variables.  C is the content of A.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AP, C, C1, CP, CP1, RLP: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*a=0.*)</font> 
      <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> C:=0; RETURN(C); <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*a ne 0.*)</font> AP:=RED(A); ADV(AP, C,AP); RLP:=RL-1; 
      <font color="#4169E1">WHILE</font> AP &lt;&gt; SIL <font color="#4169E1">DO</font> AP:=RED(AP); ADV(AP, C1,AP); 
            IPGCDC(RLP,C,C1, C,CP,CP1); 
            <font color="#4169E1">IF</font> IPONE(RLP,C) = 1 <font color="#4169E1">THEN</font> RETURN(C); <strong><font color="#4169E1">END</font></strong>; 
            <strong><font color="#4169E1">END</font></strong>; 
      C:=IPABS(RLP,C); RETURN(C); 
<font color="#B22222">(*5*)</font> <strong><font color="#4169E1">END</font></strong> IPC; 


<strong><font color="#4169E1">PROCEDURE IPCPP</font></strong>(RL,A: LIST;  <strong><font color="#228B22">VAR</font></strong> C,AB: LIST); 
<font color="#B22222">(*Integral polynomial content and primitive part.  A is an integral
polynomial in r variables.  C is the content of A and AB is the
primitive part of A.*)</font>
<strong><font color="#228B22">VAR</font></strong>  SL: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> IPSCPP(RL,A, SL,C,AB); RETURN; 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> IPCPP; 


<strong><font color="#4169E1">PROCEDURE IPGCDC</font></strong>(RL,A,B: LIST;  <strong><font color="#228B22">VAR</font></strong> C,AB,BB: LIST); 
<font color="#B22222">(*Integral polynomial greatest common divisor and cofactors.  A and B
are integral polynomials in r variables, r ge 0.  C=GCD(A,B).
If C is non-zero then AB=A/C and BB=B/C.  Otherwise AB=0 and BB=0.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AH, AHS, AL, ALB, ALH, ALP, AP, AS, BH, BHS, BL, BLB, BLH, BLP,
     BP, BS, CHS, CL, CLH, CLHP, CLP, CLPP, CLS, CP, CS, DL, DLB, EL,
     ELB, FL, FLB, GL, GLB, GLH, J1Y, J2Y, P, PL,
     Q, QL, QLP, TL, U, US, V, VS, W, WL, WP, WS: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*a=b=0.*)</font> 
      <font color="#4169E1">IF</font> (A = 0) <font color="#4169E1">AND</font> (B = 0) <font color="#4169E1">THEN</font> C:=0; AB:=0; BB:=0; RETURN; 
         <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*rl=0.*)</font> 
      <font color="#4169E1">IF</font> RL = 0 <font color="#4169E1">THEN</font> C:=IGCD(A,B); AB:=IQ(A,C); BB:=IQ(B,C); 
         RETURN; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*3*)</font> <font color="#B22222">(*a=0 or b=0.*)</font> 
      <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> C:=IPABS(RL,B); AB:=0; J1Y:=IPSIGN(RL,B); 
         BB:=PINV(0,J1Y,RL); RETURN; <strong><font color="#4169E1">END</font></strong>; 
      <font color="#4169E1">IF</font> B = 0 <font color="#4169E1">THEN</font> C:=IPABS(RL,A); BB:=0; J1Y:=IPSIGN(RL,A); 
         AB:=PINV(0,J1Y,RL); RETURN; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*4*)</font> <font color="#B22222">(*compute integer contents and primitive parts.*)</font> IPICPP(RL,A,
      AL,AH); IPICPP(RL,B, BL,BH); CL:=IGCD(AL,BL); 
<font color="#B22222">(*5*)</font> <font color="#B22222">(*compute normalization factor.*)</font> ALH:=PLBCF(RL,AH); 
      BLH:=PLBCF(RL,BH); CLH:=IGCD(ALH,BLH); 
<font color="#B22222">(*6*)</font> <font color="#B22222">(*compute norms.*)</font> DL:=IPMAXN(RL,AH); EL:=IPMAXN(RL,BH); 
      FL:=IMAX(DL,EL); J1Y:=IPROD(2,CLH); GL:=IPROD(J1Y,FL); 
<font color="#B22222">(*7*)</font> <font color="#B22222">(*compute degree vectors.*)</font> U:=PDEGV(RL,AH); V:=PDEGV(RL,BH); 
<font color="#B22222">(*8*)</font> <font color="#B22222">(*compute factor coefficient bounds.*)</font> J1Y:=IPFCB(U); 
      DLB:=IMP2(DL,J1Y); J1Y:=IPFCB(V); ELB:=IMP2(EL,J1Y); 
      FLB:=IMAX(DLB,ELB); J1Y:=IPROD(8,CLH); GLB:=IPROD(J1Y,FLB); 
<font color="#B22222">(*9*)</font> <font color="#B22222">(*initialize prime list and degree vector.*)</font> P:=PRIME; 
      J1Y:=FIRST(U); J1Y:=J1Y+1; J2Y:=RED(U); W:=COMP(J1Y,J2Y); 

<font color="#4169E1">REPEAT</font> <font color="#4169E1">REPEAT</font> <font color="#4169E1">REPEAT</font> <font color="#4169E1">REPEAT</font> <font color="#4169E1">REPEAT</font> <font color="#4169E1">REPEAT</font>
<font color="#B22222">(*10*)</font> <font color="#B22222">(*obtain next prime.*)</font> 
       <font color="#4169E1">IF</font> P = SIL <font color="#4169E1">THEN</font> ERROR(fatal,"PRIME LIST EXHAUSTED IN IPGCDC."); 
          RETURN <strong><font color="#4169E1">END</font></strong>; 
       ADV(P, PL,P); 

<font color="#B22222">(*11*)</font> <font color="#B22222">(*map normalization factor.*)</font> CLS:=MDHOM(PL,CLH); 
       <font color="#4169E1">UNTIL</font> CLS &lt;&gt; 0; <font color="#B22222">(*then go to 10; end;*)</font>

<font color="#B22222">(*12*)</font> <font color="#B22222">(*map ah and bh.*)</font> AS:=MPHOM(RL,PL,AH); US:=PDEGV(RL,AS); 
       <font color="#4169E1">UNTIL</font> EQUAL(U,US) &lt;&gt; 0; <font color="#B22222">(* then go to 10; end;*)</font>
       BS:=MPHOM(RL,PL,BH); VS:=PDEGV(RL,BS); 
       <font color="#4169E1">UNTIL</font> EQUAL(V,VS) &lt;&gt; 0; <font color="#B22222">(*then go to 10; end;*)</font> 
<font color="#B22222">(*13*)</font> <font color="#B22222">(*compute g.c.d.*)</font> MPGCDC(RL,PL,AS,BS, CS,AHS,BHS); 
<font color="#B22222">(*14*)</font> <font color="#B22222">(*test for constant g.c.d.*)</font> 
       <font color="#4169E1">IF</font> IPONE(RL,CS) = 1 <font color="#4169E1">THEN</font> C:=PINV(0,CL,RL); 
          AB:=IPIQ(RL,A,CL); BB:=IPIQ(RL,B,CL); RETURN; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*15*)</font> <font color="#B22222">(*conditional initialization of chinese remainder process.*)</font> 
       WS:=PDEGV(RL,CS); TL:=VCOMP(W,WS); 
       <font color="#4169E1">IF</font> TL &gt;= 2 <font color="#4169E1">THEN</font> Q:=1; AP:=0; BP:=0; CP:=0; W:=VMIN(W,WS); WP:=W; 
          GLH:=GLB; 
          <font color="#4169E1">REPEAT</font> ADV(WP, WL,WP); J1Y:=WL+1; GLH:=IPROD(GLH,J1Y); 
                 <font color="#4169E1">UNTIL</font> WP = SIL; 
          <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*16*)</font> <font color="#B22222">(*test for unlucky prime.*)</font> 
       <font color="#4169E1">UNTIL</font> <font color="#4169E1">NOT</font> ((TL = 1) <font color="#4169E1">OR</font> (TL = 3) <font color="#4169E1">OR</font> 
                  ((TL = 0) <font color="#4169E1">AND</font> (ICOMP(Q,GLH) &gt; 0))
                 ); <font color="#B22222">(*then go to 10; end;*)</font> 

<font color="#B22222">(*17*)</font> <font color="#B22222">(*apply chinese remainder algorithm.*)</font> 
       CHS:=MPMDP(RL,PL,CLS,CS); 
       J1Y:=MDHOM(PL,Q); QLP:=MDINV(PL,J1Y); 
       CP:=IPCRA(Q,PL,QLP,RL,CP,CHS); 
       AP:=IPCRA(Q,PL,QLP,RL,AP,AHS); 
       BP:=IPCRA(Q,PL,QLP,RL,BP,BHS); 
       Q:=IPROD(Q,PL); 
<font color="#B22222">(*18*)</font> <font color="#B22222">(*test for completion.*)</font> 
       <font color="#4169E1">UNTIL</font> ICOMP(Q,GL) &gt; 0; <font color="#B22222">(* then go to 10; end; *)</font>
       QL:=ILOG2(Q); J1Y:=IPSUMN(RL,CP); CLP:=ILOG2(J1Y); 
       J1Y:=IPMAXN(RL,AP); ALP:=ILOG2(J1Y); J1Y:=IPMAXN(RL,BP); 
       BLP:=ILOG2(J1Y); CLPP:=MASMAX(ALP,BLP); 
       <font color="#4169E1">UNTIL</font> QL &gt;= CLP+CLPP+2; <font color="#B22222">(*then go to 10; end;*)</font> 
<font color="#B22222">(*19*)</font> <font color="#B22222">(*remove normalization.*)</font> IPICPP(RL,CP, CLP,C); 
       CLHP:=IQ(CLH,CLP); AB:=IPIQ(RL,AP,CLHP); BB:=IPIQ(RL,BP,CLHP); 
       C:=IPIP(RL,CL,C); ALB:=IQ(AL,CL); AB:=IPIP(RL,ALB,AB); 
       BLB:=IQ(BL,CL); BB:=IPIP(RL,BLB,BB); RETURN; 
<font color="#B22222">(*22*)</font> <strong><font color="#4169E1">END</font></strong> IPGCDC; 


<strong><font color="#4169E1">PROCEDURE IPIC</font></strong>(RL,A: LIST): LIST; 
<font color="#B22222">(*Integral polynomial integer content.  A is an integral polynomial in
r variables.  c is the integer content of A.*)</font>
<strong><font color="#228B22">VAR</font></strong>  CL: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> CL:=0; <font color="#4169E1">ELSE</font> CL:=IPICS(RL,A,0); <strong><font color="#4169E1">END</font></strong>; 
      RETURN(CL); 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> IPIC; 


<strong><font color="#4169E1">PROCEDURE IPICPP</font></strong>(RL,A: LIST;  <strong><font color="#228B22">VAR</font></strong> AL,AB: LIST); 
<font color="#B22222">(*Integral polynomial integer content and primitive part.  A is an
integral polynomial in r variables.  a is the integer content of A.
AB=A/a if A is non-zero and AB=0 if A=0.*)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> AL:=0; AB:=0; <font color="#4169E1">ELSE</font> AL:=IPIC(RL,A); 
         AB:=IPIQ(RL,A,AL); <strong><font color="#4169E1">END</font></strong>; 
      RETURN; 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> IPICPP; 


<strong><font color="#4169E1">PROCEDURE IPICS</font></strong>(RL,A,CL: LIST): LIST; 
<font color="#B22222">(*Integral polynomial integer content subroutine.  A is a non-zero
integral polynomial in r variables.  c is an integer.  d is the
greatest common divisor of c and the integer content of A.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AL, AP, DL, EL, RLP: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> AP:=A; RLP:=RL-1; DL:=CL; 
      <font color="#4169E1">REPEAT</font> ADV2(AP, EL,AL,AP); 
             <font color="#4169E1">IF</font> RLP = 0 <font color="#4169E1">THEN</font> DL:=IGCD(AL,DL); <font color="#4169E1">ELSE</font>
                DL:=IPICS(RLP,AL,DL); <strong><font color="#4169E1">END</font></strong>; 
             <font color="#4169E1">IF</font> DL = 1 <font color="#4169E1">THEN</font> RETURN(DL); <strong><font color="#4169E1">END</font></strong>; 
             <font color="#4169E1">UNTIL</font> AP = SIL; 
      RETURN(DL); 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> IPICS; 


<strong><font color="#4169E1">PROCEDURE IPIPP</font></strong>(RL,A: LIST): LIST; 
<font color="#B22222">(*Integral polynomial integer primitive part.  A is an integral
polynomial in r variables.  If A ne 0 then AB=A/a where a is the
integer content of A.  If A=0 then AB=0.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AB, AL: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> IPICPP(RL,A, AL,AB); RETURN(AB); 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> IPIPP; 


<strong><font color="#4169E1">PROCEDURE IPPGSD</font></strong>(RL,A: LIST): LIST; 
<font color="#B22222">(*Integral polynomial primitive greatest squarefree divisor.  A is an
integral polynomial in r variables.  If A=0 then B=0.  Otherwise B is
the greatest squarefree divisor of the primitive part of A.*)</font>
<strong><font color="#228B22">VAR</font></strong>  B, BP, C, D: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*a=0.*)</font> 
      <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> B:=0; RETURN(B); <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*a ne 0.*)</font> B:=IPPP(RL,A); 
      <font color="#4169E1">IF</font> FIRST(B) &gt; 0 <font color="#4169E1">THEN</font> BP:=IPDMV(RL,B); IPGCDC(RL,B,BP, C,B,D); 
         <strong><font color="#4169E1">END</font></strong>; 
      RETURN(B); 
<font color="#B22222">(*5*)</font> <strong><font color="#4169E1">END</font></strong> IPPGSD; 


<strong><font color="#4169E1">PROCEDURE IPPP</font></strong>(RL,A: LIST): LIST; 
<font color="#B22222">(*Integral polynomial primitive part.  A is an integral polynomial in
r variables.  AB is the primitive part of A.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AB, C: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> IPCPP(RL,A, C,AB); RETURN(AB); 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> IPPP; 


<strong><font color="#4169E1">PROCEDURE IPRES</font></strong>(RL,A,B: LIST): LIST; 
<font color="#B22222">(*Integral polynomial resultant.  A and B are integral polynomials in
r variables, r ge 1, of positive degrees.  C is the resultant of A and
B with respect to the main variable, an integral polynomial in r-1
variables.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AS, BS, C, CS, DL, EL, FL, I, J1Y, ML, NL, PL, Q, QL,
     RLP: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*compute coefficient bound.*)</font> DL:=IPMAXN(RL,A); 
      EL:=IPMAXN(RL,B); ML:=FIRST(A); NL:=FIRST(B); DL:=IEXP(DL,NL); 
      EL:=IEXP(EL,ML); J1Y:=ML+NL; FL:=IFACTL(J1Y); FL:=IPROD(EL,FL); 
      FL:=IPROD(DL,FL); 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*initialize.*)</font> I:=PRIME; Q:=1; C:=0; RLP:=RL-1; 
<font color="#B22222">(*3*)</font> <font color="#B22222">(*loop.*)</font> 
      <font color="#4169E1">WHILE</font> I &lt;&gt; SIL <font color="#4169E1">DO</font> ADV(I, PL,I); AS:=MPHOM(RL,PL,A); 
            <font color="#4169E1">IF</font> PDEG(AS) = ML <font color="#4169E1">THEN</font> BS:=MPHOM(RL,PL,B); 
               <font color="#4169E1">IF</font> PDEG(BS) = NL <font color="#4169E1">THEN</font> CS:=MPRES(RL,PL,AS,BS); 
                  QL:=MDHOM(PL,Q); QL:=MDINV(PL,QL); 
                  C:=IPCRA(Q,PL,QL,RLP,C,CS); Q:=IPROD(Q,PL); 
                  <font color="#4169E1">IF</font> ICOMP(Q,FL) &gt;= 0 <font color="#4169E1">THEN</font> RETURN(C); <strong><font color="#4169E1">END</font></strong>; 
                  <strong><font color="#4169E1">END</font></strong>; 
               <strong><font color="#4169E1">END</font></strong>; 
            <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*4*)</font> <font color="#B22222">(*algorithm fails.*)</font> ERROR(fatal,"ALGORITHM IPRES FAILS.");  
<font color="#B22222">(*7*)</font> RETURN(C); <strong><font color="#4169E1">END</font></strong> IPRES; 


<strong><font color="#4169E1">PROCEDURE IPRPRS</font></strong>(RL,A,B: LIST): LIST; 
<font color="#B22222">(*Integral polynomial reduced polynomial remainder sequence.  A and B
are non-zero integral polynomials in r variables with deg(A) ge deg(B).
S is the reduced polynomial remainder sequence of A and B.*)</font>
<strong><font color="#228B22">VAR</font></strong>  A1, A2, A3, AL1, ALS1, DL, IL, J1Y, NL1, NL2, S: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> A1:=A; A2:=B; S:=LIST2(A2,A1); DL:=-1; 
      LOOP A3:=IPPSR(RL,A1,A2); 
           <font color="#4169E1">IF</font> A3 = 0 <font color="#4169E1">THEN</font> S:=INV(S); RETURN(S); <strong><font color="#4169E1">END</font></strong>; 
           <font color="#4169E1">IF</font> DL &gt;= 0 <font color="#4169E1">THEN</font> AL1:=PLDCF(A1); ALS1:=AL1; 
              <font color="#4169E1">FOR</font> IL:=1 <font color="#4169E1">TO</font> DL <font color="#4169E1">DO</font>
                  <font color="#4169E1">IF</font> RL = 1 <font color="#4169E1">THEN</font> ALS1:=IPROD(ALS1,AL1); <font color="#4169E1">ELSE</font>
                     J1Y:=RL-1; ALS1:=IPPROD(J1Y,ALS1,AL1); <strong><font color="#4169E1">END</font></strong>; 
                  <strong><font color="#4169E1">END</font></strong>; 
              ALS1:=LIST2(0,ALS1); A3:=IPQ(RL,A3,ALS1); <strong><font color="#4169E1">END</font></strong>; 
           S:=COMP(A3,S); NL1:=PDEG(A1); NL2:=PDEG(A2); DL:=NL1-NL2; 
           A1:=A2; A2:=A3; 
           <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*4*)</font> RETURN(S); <strong><font color="#4169E1">END</font></strong> IPRPRS; 


<strong><font color="#4169E1">PROCEDURE IPSCPP</font></strong>(RL,A: LIST;  <strong><font color="#228B22">VAR</font></strong> SL,C,AB: LIST); 
<font color="#B22222">(*Integral polynomial sign, content, and primitive part.  A is
an integral polynomial in R ge 1 variables.  s is
the sign of A, C is the content of A, and AB is the primitive
part of A.*)</font>
<strong><font color="#228B22">VAR</font></strong>  A1, AP, C1, EL, RLP: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*a eq 0.*)</font> 
      <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> SL:=0; C:=0; AB:=0; RETURN; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*a ne 0.*)</font> SL:=IPSIGN(RL,A); AP:=IPABS(RL,A); RLP:=RL-1; 
      C:=IPC(RL,AP); 
      <font color="#4169E1">IF</font> IPONE(RLP,C) = 1 <font color="#4169E1">THEN</font> AB:=AP; <font color="#4169E1">ELSE</font> AB:=BETA; 
         <font color="#4169E1">REPEAT</font> ADV2(AP, EL,A1,AP); C1:=IPQ(RLP,A1,C); 
                AB:=COMP2(C1,EL,AB); 
                <font color="#4169E1">UNTIL</font> AP = SIL; 
         AB:=INV(AB); <strong><font color="#4169E1">END</font></strong>; 
      RETURN; 
<font color="#B22222">(*5*)</font> <strong><font color="#4169E1">END</font></strong> IPSCPP; 


<strong><font color="#4169E1">PROCEDURE IPSF</font></strong>(RL,A: LIST): LIST; 
<font color="#B22222">(*Integral polynomial squarefree factorization.  A is a positive pri-
mitive integral polynomial in r variables of positive degree.  L is
the list ((e sub 1,A sub 1), ...,(e sub l,A sub l)) where A equal to
the product of (A sub i)**(e sub i) for i = 1, ...,k is the
squarefree factorization of A in which 1 le e sub 1 lt e sub 2 lt  ...
lt e sub k and each A sub i is a positive squarefree polynomial of
positive degree.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AP, B, BP, C, CP, D, J1Y, JL, L: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> L:=BETA; AP:=IPDMV(RL,A); IPGCDC(RL,A,AP,
      B,C,CP); JL:=1; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*compute factors.*)</font> 
      <font color="#4169E1">WHILE</font> PDEG(B) &gt; 0 <font color="#4169E1">DO</font> IPGCDC(RL,B,C, D,BP,CP); 
            <font color="#4169E1">IF</font> PDEG(CP) &gt; 0 <font color="#4169E1">THEN</font> J1Y:=LIST2(JL,CP); L:=COMP(J1Y,L); 
               <strong><font color="#4169E1">END</font></strong>; 
            B:=BP; C:=D; JL:=JL+1; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*3*)</font> <font color="#B22222">(*finish.*)</font> J1Y:=LIST2(JL,C); L:=COMP(J1Y,L); L:=INV(L); 
      RETURN(L); 
<font color="#B22222">(*6*)</font> <strong><font color="#4169E1">END</font></strong> IPSF; 


<strong><font color="#4169E1">PROCEDURE IPSPRS</font></strong>(RL,A,B: LIST): LIST; 
<font color="#B22222">(*Integral polynomial subresultant polynomial remainder sequence.
A and B are non-zero integral polynomials in r variables with
deg(A) ge deg(B).  S is the subresultant p.r.s. of the first kind
of A and B.*)</font>
<strong><font color="#228B22">VAR</font></strong>  DL0, DL1, G1, G2, G3, GH3, GL1, HL0, HL1, HLS0, HLS1, IL, J1Y,
     NL1, NL2, NL3, RLP, S: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> G1:=A; G2:=B; S:=LIST2(G2,G1); NL1:=PDEG(G1); 
      NL2:=PDEG(G2); DL0:=0; DL1:=NL1-NL2; RLP:=RL-1; IL:=1; 
LOOP
<font color="#B22222">(*2*)</font> <font color="#B22222">(*compute gh(il+2).*)</font> GH3:=IPPSR(RL,G1,G2); 
      <font color="#4169E1">IF</font> GH3 = 0 <font color="#4169E1">THEN</font> S:=INV(S); RETURN(S); <strong><font color="#4169E1">END</font></strong>; 
      <font color="#4169E1">IF</font> MASEVEN(DL1)<font color="#B22222">(*=1*)</font> <font color="#4169E1">THEN</font> GH3:=IPNEG(RL,GH3); <strong><font color="#4169E1">END</font></strong>; 
      NL3:=PDEG(GH3); 
<font color="#B22222">(*3*)</font> <font color="#B22222">(*compute hl(il).*)</font> 
      <font color="#4169E1">IF</font> IL &gt; 1 <font color="#4169E1">THEN</font> GL1:=PLDCF(G1); HL1:=IPEXP(RLP,GL1,DL0); 
         <font color="#4169E1">IF</font> IL &gt; 2 <font color="#4169E1">THEN</font> J1Y:=DL0-1; HLS0:=IPEXP(RLP,HL0,J1Y); 
            HL1:=IPQ(RLP,HL1,HLS0); HLS0:=0; <strong><font color="#4169E1">END</font></strong>; 
         <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*4*)</font> <font color="#B22222">(*compute g(il+2).*)</font> 
      <font color="#4169E1">IF</font> IL = 1 <font color="#4169E1">THEN</font> G3:=GH3; <font color="#4169E1">ELSE</font> HLS1:=IPEXP(RLP,HL1,DL1); 
         HLS1:=IPPROD(RLP,GL1,HLS1); HLS1:=LIST2(0,HLS1); 
         G3:=IPQ(RL,GH3,HLS1); HLS1:=0; GH3:=0; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*5*)</font> <font color="#B22222">(*update.*)</font> S:=COMP(G3,S); NL1:=NL2; NL2:=NL3; DL0:=DL1; 
      DL1:=NL1-NL2; G1:=G2; G2:=G3; 
      <font color="#4169E1">IF</font> IL &gt; 1 <font color="#4169E1">THEN</font> HL0:=HL1; <strong><font color="#4169E1">END</font></strong>; 
      IL:=IL+1; 
      <strong><font color="#4169E1">END</font></strong>; <font color="#B22222">(* loop go to 2*)</font> 
<font color="#B22222">(*8*)</font> RETURN(S); <strong><font color="#4169E1">END</font></strong> IPSPRS;

 
<strong><font color="#4169E1">PROCEDURE IPSRP</font></strong>(RL,A: LIST;  <strong><font color="#228B22">VAR</font></strong> AL,AB: LIST); 
<font color="#B22222">(*Integral polynomial similiar to rational polynomial.  A is a
rational polynomial in r variables, r ge 0.  a is a
rational number, and AB is an integral polynomial such that A=a*AB. If
A eq 0 then a=AB=0. Otherwise AB is integer primitive and positive.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AS, SL, UL, ULP, VL: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*a eq 0.*)</font> 
      <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> AL:=0; AB:=0; RETURN; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*a ne 0.*)</font> RPBLGS(RL,A, UL,VL,SL); ULP:=IDPR(UL,SL); 
      AL:=LIST2(ULP,VL); AS:=RPRNP(RL,AL,A); AB:=IPFRP(RL,AS); RETURN; 
<font color="#B22222">(*5*)</font> <strong><font color="#4169E1">END</font></strong> IPSRP; 


<strong><font color="#4169E1">PROCEDURE MPGCDC</font></strong>(RL,PL,A,B: LIST;  <strong><font color="#228B22">VAR</font></strong> C,AB,BB: LIST); 
<font color="#B22222">(*Modular polynomial greatest common divisor and cofactors.  p is a
prime beta-integer.  A and B are polynomials in r variables over
Z sub p.  C=gcd(A,B).  If C is non-zero then AB=A/C and BB=B/C.
Otherwise AB=0 and BB=0.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AH, AHS, AL, ALB, ALH, ALP, AP, AS, BH, BHS, BL, BLB, BLH, BLP,
     BP, BS, CHS, CL, CLH, CLHP, CLP, CLPP, CLS, CP, CS, DL, EL, 
     FL, GL, J1Y, J2Y, Q, QLP, RLP, TL, U, US, V, VS, W, WS:
     LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*a=b=0.*)</font> 
      <font color="#4169E1">IF</font> (A = 0) <font color="#4169E1">AND</font> (B = 0) <font color="#4169E1">THEN</font> C:=0; AB:=0; BB:=0; RETURN; 
         <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*a=0 or b=0.*)</font> 
      <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> BL:=PLBCF(RL,B); C:=MPMON(RL,PL,B); AB:=0; 
         BB:=PINV(0,BL,RL); RETURN; <strong><font color="#4169E1">END</font></strong>; 
      <font color="#4169E1">IF</font> B = 0 <font color="#4169E1">THEN</font> AL:=PLBCF(RL,A); C:=MPMON(RL,PL,A); BB:=0; 
         AB:=PINV(0,AL,RL); RETURN; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*3*)</font> <font color="#B22222">(*rl=1.*)</font> 
      <font color="#4169E1">IF</font> RL = 1 <font color="#4169E1">THEN</font> C:=MUPGCD(PL,A,B); AB:=MPQ(RL,PL,A,C); 
         BB:=MPQ(RL,PL,B,C); RETURN; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*4*)</font> <font color="#B22222">(*compute univariate contents and primitive parts.*)</font> 
      MPUCPP(RL,PL,A, AL,AH); MPUCPP(RL,PL,B, BL,BH); 
      CL:=MUPGCD(PL,AL,BL); 
<font color="#B22222">(*5*)</font> <font color="#B22222">(*compute normalization factor.*)</font> RLP:=RL-1; ALH:=PLBCF(RLP,AH); 
      BLH:=PLBCF(RLP,BH); CLH:=MUPGCD(PL,ALH,BLH); 
<font color="#B22222">(*6*)</font> <font color="#B22222">(*compute degrees.*)</font> U:=PDEGV(RLP,AH); V:=PDEGV(RLP,BH); 
      EL:=PDEGSV(RL,AH,1); FL:=PDEGSV(RL,BH,1); J1Y:=PDEG(CLH); 
      J2Y:=MASMAX(EL,FL); GL:=J1Y+J2Y; 
<font color="#B22222">(*7*)</font> <font color="#B22222">(*initialize element and degree vector.*)</font> DL:=-1; J1Y:=FIRST(U); 
      J1Y:=J1Y+1; J2Y:=RED(U); W:=COMP(J1Y,J2Y); 

<font color="#4169E1">REPEAT</font> <font color="#4169E1">REPEAT</font> <font color="#4169E1">REPEAT</font> <font color="#4169E1">REPEAT</font> <font color="#4169E1">REPEAT</font> <font color="#4169E1">REPEAT</font>
<font color="#B22222">(*8*)</font> <font color="#B22222">(*obtain next element.*)</font> DL:=DL+1; 
      <font color="#4169E1">IF</font> DL = PL <font color="#4169E1">THEN</font>
         ERROR(fatal,"ELEMENTS <font color="#4169E1">OF</font> Z SUB P EXHAUSTED IN MPGCDC."); 
         RETURN <strong><font color="#4169E1">END</font></strong>; 

<font color="#B22222">(*9*)</font> <font color="#B22222">(*map normalization factor.*)</font> CLS:=MPEMV(1,PL,CLH,DL); 
      <font color="#4169E1">UNTIL</font> CLS &lt;&gt; 0; <font color="#B22222">(*then go to 8; end;*)</font> 

<font color="#B22222">(*10*)</font> <font color="#B22222">(*map ah and bh.*)</font> AS:=MPEVAL(RL,PL,AH,1,DL); US:=PDEGV(RLP,AS); 
       <font color="#4169E1">UNTIL</font> EQUAL(U,US) &lt;&gt; 0; <font color="#B22222">(*then go to 8; end;*)</font> 
       BS:=MPEVAL(RL,PL,BH,1,DL); VS:=PDEGV(RLP,BS); 
       <font color="#4169E1">UNTIL</font> EQUAL(V,VS) &lt;&gt; 0; <font color="#B22222">(*then go to 8; end;*)</font> 

<font color="#B22222">(*11*)</font> <font color="#B22222">(*compute g.c.d.*)</font> MPGCDC(RLP,PL,AS,BS, CS,AHS,BHS); 
<font color="#B22222">(*12*)</font> <font color="#B22222">(*test for constant g.c.d.*)</font> 
       <font color="#4169E1">IF</font> IPONE(RLP,CS) = 1 <font color="#4169E1">THEN</font> C:=PINV(0,CL,RLP); 
          AB:=MPUQ(RL,PL,A,CL); BB:=MPUQ(RL,PL,B,CL); RETURN; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*13*)</font> <font color="#B22222">(*conditional initialization of interpolation process.*)</font> 
       WS:=PDEGV(RLP,CS); TL:=VCOMP(W,WS); 
       <font color="#4169E1">IF</font> TL &gt;= 2 <font color="#4169E1">THEN</font> Q:=LIST2(0,1); AP:=0; BP:=0; CP:=0; 
          W:=VMIN(W,WS); <strong><font color="#4169E1">END</font></strong>; 

<font color="#B22222">(*14*)</font> <font color="#B22222">(*test for unlucky element.*)</font> 
       <font color="#4169E1">UNTIL</font> <font color="#4169E1">NOT</font> ( (TL = 1) <font color="#4169E1">OR</font> (TL = 3) <font color="#4169E1">OR</font> 
                   (TL = 0) <font color="#4169E1">AND</font> (PDEG(Q) &gt; GL) ); 
             <font color="#B22222">(*then go to 8; end;*)</font> 

<font color="#B22222">(*15*)</font> <font color="#B22222">(*interpolate.*)</font> CHS:=MPMDP(RLP,PL,CLS,CS); 
       J1Y:=MPEMV(1,PL,Q,DL); QLP:=MDINV(PL,J1Y); 
       CP:=MPINT(PL,Q,DL,QLP,RL,CP,CHS); 
       AP:=MPINT(PL,Q,DL,QLP,RL,AP,AHS); 
       BP:=MPINT(PL,Q,DL,QLP,RL,BP,BHS); J1Y:=MDNEG(PL,DL); 
       J1Y:=LIST4(1,1,0,J1Y); Q:=MPPROD(1,PL,Q,J1Y); 
<font color="#B22222">(*16*)</font> <font color="#B22222">(*test for completion.*)</font> 
       <font color="#4169E1">UNTIL</font> PDEG(Q) &gt; GL; <font color="#B22222">(*then go to 8; end;*)</font> 
       CLP:=PDEGSV(RL,CP,1); ALP:=PDEGSV(RL,AP,1); BLP:=PDEGSV(RL,BP,1); 
       CLPP:=MASMAX(ALP,BLP); 
       <font color="#4169E1">UNTIL</font> PDEG(Q) &gt; CLP+CLPP; <font color="#B22222">(*then go to 8; end;*)</font> 

<font color="#B22222">(*17*)</font> <font color="#B22222">(*remove normalization.*)</font> MPUCPP(RL,PL,CP, CLP,C); 
       CLHP:=MPQ(1,PL,CLH,CLP); AB:=MPUQ(RL,PL,AP,CLHP); 
       BB:=MPUQ(RL,PL,BP,CLHP); C:=MPUP(RL,PL,CL,C); 
       ALB:=MPQ(1,PL,AL,CL); AB:=MPUP(RL,PL,ALB,AB); 
       BLB:=MPQ(1,PL,BL,CL); BB:=MPUP(RL,PL,BLB,BB); RETURN; 
<font color="#B22222">(*20*)</font> <strong><font color="#4169E1">END</font></strong> MPGCDC; 


<strong><font color="#4169E1">PROCEDURE MPRES</font></strong>(RL,PL,A,B: LIST): LIST; 
<font color="#B22222">(*Modular polynomial resultant.  p is a prime beta-digit.  A and B are
polynomials over Z sub p in r variables, r ge 1, of positive degree.
C is the resultant of A and B, a polynomial over Z sub p in r-1
variables.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AS, BL, BS, C, CS, D, DP, IL, J1Y, J2Y, KL, ML, ML1, NL, NL1,
     RLP: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*rl=1.*)</font> 
      <font color="#4169E1">IF</font> RL = 1 <font color="#4169E1">THEN</font> C:=MUPRES(PL,A,B); RETURN(C); <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*initialize.*)</font> ML:=FIRST(A); ML1:=PDEGSV(RL,A,1); NL:=FIRST(B); 
      NL1:=PDEGSV(RL,B,1); J1Y:=ML*NL1; J2Y:=ML1*NL; KL:=J1Y+J2Y; 
      RLP:=RL-1; C:=0; D:=LIST2(0,1); IL:=0; 
<font color="#B22222">(*3*)</font> <font color="#B22222">(*recursion.*)</font> 
      <font color="#4169E1">WHILE</font> IL &lt; PL <font color="#4169E1">DO</font> AS:=MPEVAL(RL,PL,A,1,IL); 
            <font color="#4169E1">IF</font> PDEG(AS) = ML <font color="#4169E1">THEN</font> BS:=MPEVAL(RL,PL,B,1,IL); 
               <font color="#4169E1">IF</font> PDEG(BS) = NL <font color="#4169E1">THEN</font> CS:=MPRES(RLP,PL,AS,BS); 
                  BL:=MPEMV(1,PL,D,IL); BL:=MDINV(PL,BL); 
                  C:=MPINT(PL,D,IL,BL,RLP,C,CS); J1Y:=PL-IL; 
                  DP:=LIST4(1,1,0,J1Y); D:=MPPROD(1,PL,D,DP); 
                  <font color="#4169E1">IF</font> PDEG(D) &gt; KL <font color="#4169E1">THEN</font> RETURN(C); <strong><font color="#4169E1">END</font></strong>; 
                  <strong><font color="#4169E1">END</font></strong>; 
               <strong><font color="#4169E1">END</font></strong>; 
            IL:=IL+1; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*4*)</font> <font color="#B22222">(*algorithm fails.*)</font> ERROR(fatal,"ALGORITHM MPRES FAILS.");  
<font color="#B22222">(*7*)</font> RETURN(C); <strong><font color="#4169E1">END</font></strong> MPRES; 


<strong><font color="#4169E1">PROCEDURE MPSPRS</font></strong>(RL,PL,A,B: LIST): LIST; 
<font color="#B22222">(*Modular polynomial subresultant polynomial remainder sequence.
A and B are non-zero polynomials in r variables over Z sub p,
p a prime beta-integer, with deg(A) ge deg(B).
S is the subresultant p.r.s. of the first kind of A and B.*)</font>
<strong><font color="#228B22">VAR</font></strong>  DL0, DL1, G1, G2, G3, GH3, GL1, HL0, HL1, HLS0, HLS1, IL, J1Y,
     NL1, NL2, NL3, RLP, S: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> G1:=A; G2:=B; S:=LIST2(G2,G1); NL1:=PDEG(G1); 
      NL2:=PDEG(G2); DL0:=0; DL1:=NL1-NL2; RLP:=RL-1; IL:=1; 
LOOP
<font color="#B22222">(*2*)</font> <font color="#B22222">(*compute gh(il+2).*)</font> GH3:=MPPSR(RL,PL,G1,G2); 
      <font color="#4169E1">IF</font> GH3 = 0 <font color="#4169E1">THEN</font> S:=INV(S); RETURN(S); <strong><font color="#4169E1">END</font></strong>; 
      <font color="#4169E1">IF</font> MASEVEN(DL1) <font color="#B22222">(*= 1*)</font> <font color="#4169E1">THEN</font> GH3:=MPNEG(RL,PL,GH3); <strong><font color="#4169E1">END</font></strong>; 
      NL3:=PDEG(GH3); 
<font color="#B22222">(*3*)</font> <font color="#B22222">(*compute hl(il).*)</font> 
      <font color="#4169E1">IF</font> IL &gt; 1 <font color="#4169E1">THEN</font> GL1:=PLDCF(G1); HL1:=MPEXP(RLP,PL,GL1,DL0); 
         <font color="#4169E1">IF</font> IL &gt; 2 <font color="#4169E1">THEN</font> J1Y:=DL0-1; HLS0:=MPEXP(RLP,PL,HL0,J1Y); 
            HL1:=MPQ(RLP,PL,HL1,HLS0); HLS0:=0; <strong><font color="#4169E1">END</font></strong>; 
         <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*4*)</font> <font color="#B22222">(*compute g(il+2).*)</font> 
      <font color="#4169E1">IF</font> IL = 1 <font color="#4169E1">THEN</font> G3:=GH3; <font color="#4169E1">ELSE</font> HLS1:=MPEXP(RLP,PL,HL1,DL1); 
         HLS1:=MPPROD(RLP,PL,GL1,HLS1); HLS1:=LIST2(0,HLS1); 
         G3:=MPQ(RL,PL,GH3,HLS1); HLS1:=0; GH3:=0; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*5*)</font> <font color="#B22222">(*update.*)</font> S:=COMP(G3,S); NL1:=NL2; NL2:=NL3; DL0:=DL1; 
      DL1:=NL1-NL2; G1:=G2; G2:=G3; 
      <font color="#4169E1">IF</font> IL &gt; 1 <font color="#4169E1">THEN</font> HL0:=HL1; <strong><font color="#4169E1">END</font></strong>; 
      IL:=IL+1; 
      <strong><font color="#4169E1">END</font></strong>; <font color="#B22222">(*loop go to 2;*)</font> 
<font color="#B22222">(*8*)</font> RETURN(S); <strong><font color="#4169E1">END</font></strong> MPSPRS; 


<strong><font color="#4169E1">PROCEDURE MPUC</font></strong>(RL,PL,A: LIST): LIST; 
<font color="#B22222">(*Modular polynomial univariate content.  A is a polynomial in r
variables, r ge 2, over Z sub p, p a prime beta-integer.  c is the
univariate content of A.*)</font>
<strong><font color="#228B22">VAR</font></strong>  CL: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> CL:=0; <font color="#4169E1">ELSE</font> CL:=MPUCS(RL,PL,A,0); <strong><font color="#4169E1">END</font></strong>; 
      RETURN(CL); 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> MPUC; 


<strong><font color="#4169E1">PROCEDURE MPUCPP</font></strong>(RL,PL,A: LIST;  <strong><font color="#228B22">VAR</font></strong> AL,AB: LIST); 
<font color="#B22222">(*Modular polynomial univariate content and primitive part.  A is a
polynomial in r variables, r ge 2, over Z sub p, p a prime
beta-integer.  a is the univariate content of A.  AB=A/a if A is
non-zero and AB=0 if A=0.*)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> AL:=0; AB:=0; <font color="#4169E1">ELSE</font> AL:=MPUC(RL,PL,A); 
         AB:=MPUQ(RL,PL,A,AL); <strong><font color="#4169E1">END</font></strong>; 
      RETURN; 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> MPUCPP; 


<strong><font color="#4169E1">PROCEDURE MPUCS</font></strong>(RL,PL,A,CL: LIST): LIST; 
<font color="#B22222">(*Modular polynomial univariate content subroutine.  A is a non-zero
polynomial in r variables, r ge 2, over Z sub p, p a prime
beta-integer.  c is a univariate polynomial over Z sub p.  d is the
greatest common divisor of c and the univariate content of A.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AL, AP, DL, EL, RLP: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> AP:=A; RLP:=RL-1; DL:=CL; 
      <font color="#4169E1">REPEAT</font> ADV2(AP, EL,AL,AP); 
             <font color="#4169E1">IF</font> RLP = 1 <font color="#4169E1">THEN</font> DL:=MUPGCD(PL,AL,DL); <font color="#4169E1">ELSE</font>
                DL:=MPUCS(RLP,PL,AL,DL); <strong><font color="#4169E1">END</font></strong>; 
             <font color="#4169E1">UNTIL</font> (AP = SIL) <font color="#4169E1">OR</font> (PDEG(DL) = 0); 
      RETURN(DL); 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> MPUCS; 


<strong><font color="#4169E1">PROCEDURE MPUPP</font></strong>(RL,PL,A: LIST): LIST; 
<font color="#B22222">(*Modular polynomial univariate primitive part.  A is a polynomial in
r variables, r ge 2, over Z sub p, p a prime beta-integer.  If A is
non-zero then AB=A/a where a is the univariate content of A.  If A=0
then AB=0.*)</font>
<strong><font color="#228B22">VAR</font></strong>  AB, AL: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> MPUCPP(RL,PL,A, AL,AB); RETURN(AB); 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> MPUPP; 


<strong><font color="#4169E1">PROCEDURE MUPEGC</font></strong>(PL,A,B: LIST;  <strong><font color="#228B22">VAR</font></strong> C,U,V: LIST); 
<font color="#B22222">(*Modular univariate polynomial extended greatest common divisor.  p
is a prime beta-integer.  A and B are univariate polynomials over Z sub
p. C=gcd(A,B).  A*U+B*V=C, and, if deg(A/C) gt 0, then deg(V) lt
deg(A/C), else deg(V)=0.  Similarly, if deg(B/C) gt 0, then deg(U) lt
deg(B/C), else deg(U)=0.  If A=0, U=0.  If B=0, V=0.*)</font>
<strong><font color="#228B22">VAR</font></strong>  D: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> MUPHEG(PL,A,B, C,V); 
      <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> U:=0; <font color="#4169E1">ELSE</font> D:=MPPROD(1,PL,B,V); 
         D:=MPDIF(1,PL,C,D); U:=MPQ(1,PL,D,A); <strong><font color="#4169E1">END</font></strong>; 
      RETURN; 
<font color="#B22222">(*4*)</font> <strong><font color="#4169E1">END</font></strong> MUPEGC; 


<strong><font color="#4169E1">PROCEDURE MUPGCD</font></strong>(PL,A,B: LIST): LIST; 
<font color="#B22222">(*Modular univariate polynomial greatest common divisor.  A and B are
univariate polynomials over Z sub p, p a prime beta-integer.
C=gcd(A,B).*)</font>
<strong><font color="#228B22">VAR</font></strong>  A1, A2, A3, C, ML, NL: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*a or b zero.*)</font> 
      <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> C:=MPMON(1,PL,B); RETURN(C); <strong><font color="#4169E1">END</font></strong>; 
      <font color="#4169E1">IF</font> B = 0 <font color="#4169E1">THEN</font> C:=MPMON(1,PL,A); RETURN(C); <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*general case.*)</font> ML:=PDEG(A); NL:=PDEG(B); 
      <font color="#4169E1">IF</font> ML &gt;= NL <font color="#4169E1">THEN</font> A1:=A; A2:=B; <font color="#4169E1">ELSE</font> A1:=B; A2:=A; <strong><font color="#4169E1">END</font></strong>; 
      A1:=DPFP(1,A1); A2:=DPFP(1,A2); 
      <font color="#4169E1">REPEAT</font> A3:=DMUPNR(PL,A1,A2); A1:=A2; A2:=A3; 
             <font color="#4169E1">UNTIL</font> A2 = 0; 
      A1:=PFDP(1,A1); C:=MPMON(1,PL,A1); RETURN(C); 
<font color="#B22222">(*5*)</font> <strong><font color="#4169E1">END</font></strong> MUPGCD; 


<strong><font color="#4169E1">PROCEDURE MUPHEG</font></strong>(PL,A,B: LIST;  <strong><font color="#228B22">VAR</font></strong> C,V: LIST); 
<font color="#B22222">(*Modular univariate polynomial half-extended greatest common divisor.
p is a prime beta-integer.  A and B are univariate polynomials over
Z sub p.  C=gcd(A,B).  There exists a polynomial U such that
A*U+B*V=C, and, if deg(A/C) gt 0, then deg(V) lt deg(A/C).  If
deg(A/C)=0, deg(V) is also 0.  If B=0, V=0.*)</font>
<strong><font color="#228B22">VAR</font></strong>  A1, A2, A3, AL, ALP, J1Y, Q, V1, V2, V3: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*compute remainder sequence.*)</font> V1:=0; V2:=LIST2(0,1); A1:=A; 
      A2:=B; 
      <font color="#4169E1">WHILE</font> A2 &lt;&gt; 0 <font color="#4169E1">DO</font> MPQR(1,PL,A1,A2, Q,A3); 
            J1Y:=MPPROD(1,PL,Q,V2); V3:=MPDIF(1,PL,V1,J1Y); A1:=A2; 
            A2:=A3; V1:=V2; V2:=V3; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*adjust ldcf.*)</font> 
      <font color="#4169E1">IF</font> A1 = 0 <font color="#4169E1">THEN</font> C:=0; V:=0; RETURN; <strong><font color="#4169E1">END</font></strong>; 
      AL:=PLDCF(A1); ALP:=MDINV(PL,AL); C:=MPMDP(1,PL,ALP,A1); 
      V:=MPMDP(1,PL,ALP,V1); RETURN; 
<font color="#B22222">(*5*)</font> <strong><font color="#4169E1">END</font></strong> MUPHEG; 


<strong><font color="#4169E1">PROCEDURE MUPRES</font></strong>(PL,A,B: LIST): LIST; 
<font color="#B22222">(*Modular univariate polynomial resultant.  p is a prime beta-digit.
A and B are univariate polynomials over Z sub p of positive degrees.
C is the resultant of A and B, an element of Z sub p.*)</font>
<strong><font color="#228B22">VAR</font></strong>  A1, A2, A3, CL, CL2, IL, NL1, NL2, NL3, SL, TL: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> CL:=1; A1:=DPFP(1,A); A2:=DPFP(1,B); 
      NL1:=FIRST(A1); NL2:=FIRST(A2); SL:=0; 
      <font color="#4169E1">IF</font> NL1 &lt; NL2 <font color="#4169E1">THEN</font>
         <font color="#4169E1">IF</font> (MASODD(NL1) <font color="#B22222">(*= 1*)</font>) <font color="#4169E1">AND</font> (MASODD(NL2) <font color="#B22222">(*= 1*)</font>) <font color="#4169E1">THEN</font> SL:=1; <strong><font color="#4169E1">END</font></strong>; 
         TL:=A1; A1:=A2; A2:=TL; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*loop.*)</font> 
      <font color="#4169E1">REPEAT</font> A3:=DMUPNR(PL,A1,A2); 
             <font color="#4169E1">IF</font> A3 = 0 <font color="#4169E1">THEN</font> CL:=0; RETURN(CL); <strong><font color="#4169E1">END</font></strong>; 
             NL1:=FIRST(A1); NL2:=FIRST(A2); NL3:=FIRST(A3); 
             <font color="#4169E1">IF</font> (MASODD(NL1) <font color="#B22222">(* = 1*)</font>) <font color="#4169E1">AND</font> (MASODD(NL2) <font color="#B22222">(*= 1*)</font>) <font color="#4169E1">THEN</font>
                SL:=1-SL; <strong><font color="#4169E1">END</font></strong>; 
             CL2:=SECOND(A2); 
             <font color="#4169E1">FOR</font> IL:=1 <font color="#4169E1">TO</font> NL1-NL3 <font color="#4169E1">DO</font> CL:=MDPROD(PL,CL,CL2); <strong><font color="#4169E1">END</font></strong>; 
             A1:=A2; A2:=A3; 
             <font color="#4169E1">UNTIL</font> NL3 = 0; 
<font color="#B22222">(*3*)</font> <font color="#B22222">(*finish.*)</font> CL2:=SECOND(A2); 
      <font color="#4169E1">FOR</font> IL:=1 <font color="#4169E1">TO</font> NL2 <font color="#4169E1">DO</font> CL:=MDPROD(PL,CL,CL2); <strong><font color="#4169E1">END</font></strong>; 
      <font color="#4169E1">IF</font> SL = 1 <font color="#4169E1">THEN</font> CL:=PL-CL; <strong><font color="#4169E1">END</font></strong>; 
      RETURN(CL); 
<font color="#B22222">(*6*)</font> <strong><font color="#4169E1">END</font></strong> MUPRES; 


<strong><font color="#4169E1">PROCEDURE MUPSFF</font></strong>(PL,A: LIST): LIST; 
<font color="#B22222">(*Modular univariate polynomial squarefree factorization.  p is a
prime beta-integer.  A is a monic univariate polynomial over Z sub p
of positive degree.  L is a list ((i(1),A(1)), ...,(i(r),A(r))) with
i(1) lt i(2) lt  ... lt i(r), A(j) a monic squarefree factor of a
of positive degree for 1 le j le r and A the product of A(j)**i(j)
for j=1, ...,r.*)</font>
<strong><font color="#228B22">VAR</font></strong>  A1, AP, B, BP, C, D, EL, J1Y, JL, L, L1, LP, M, M1, MP: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*initialize.*)</font> LP:=SIL; AP:=MUPDER(PL,A); 
      <font color="#4169E1">IF</font> AP = 0 <font color="#4169E1">THEN</font> B:=A; <font color="#B22222">(*go to 3;*)</font> 
         <font color="#4169E1">ELSE</font> 
         B:=MUPGCD(PL,A,AP); C:=MPQ(1,PL,A,B); JL:=1; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*compute a(jl) with jl not divisible by pl.*)</font> 
         <font color="#4169E1">REPEAT</font> D:=MUPGCD(PL,B,C); 
                A1:=MPQ(1,PL,C,D); 
                <font color="#4169E1">IF</font> FIRST(A1) &gt; 0 <font color="#4169E1">THEN</font> J1Y:=LIST2(JL,A1); 
                   LP:=COMP(J1Y,LP); <strong><font color="#4169E1">END</font></strong>; 
                <font color="#4169E1">IF</font> FIRST(D) &gt; 0 <font color="#4169E1">THEN</font> C:=D; B:=MPQ(1,PL,B,C); 
                   JL:=JL+1; <font color="#B22222">(*go to 2;*)</font> <strong><font color="#4169E1">END</font></strong>;
                <font color="#4169E1">UNTIL</font> FIRST(D) = 0; 
         <strong><font color="#4169E1">END</font></strong>; <font color="#B22222">(*goto*)</font>
<font color="#B22222">(*3*)</font> <font color="#B22222">(*compute a(jl) with jl divisible by pl.*)</font> 
      <font color="#4169E1">IF</font> FIRST(B) = 0 <font color="#4169E1">THEN</font> L:=INV(LP); RETURN(L); <strong><font color="#4169E1">END</font></strong>; 
      BP:=BETA; 
      <font color="#4169E1">REPEAT</font> ADV2(B, EL,A1,B); EL:=EL DIV PL; BP:=COMP2(A1,EL,BP); 
             <font color="#4169E1">UNTIL</font> B = SIL; 
      B:=INV(BP); M:=MUPSFF(PL,B); MP:=M; 
      <font color="#4169E1">REPEAT</font> ADV(MP, M1,MP); J1Y:=FIRST(M1); EL:=PL*J1Y; SFIRST(M1,EL); 
             <font color="#4169E1">UNTIL</font> MP = SIL; 
      M:=INV(M); 
<font color="#B22222">(*4*)</font> <font color="#B22222">(*merge.*)</font> L:=SIL; 
      <font color="#4169E1">WHILE</font> (LP &lt;&gt; SIL) <font color="#4169E1">AND</font> (M &lt;&gt; SIL) <font color="#4169E1">DO</font>
            <font color="#4169E1">IF</font> FIRST(FIRST(LP)) &gt; FIRST(FIRST(M)) 
               <font color="#4169E1">THEN</font> ADV(LP,L1,LP); 
               <font color="#4169E1">ELSE</font> ADV(M, L1,M); <strong><font color="#4169E1">END</font></strong>; 
            L:=COMP(L1,L); <strong><font color="#4169E1">END</font></strong>; 
      <font color="#4169E1">IF</font> M = SIL <font color="#4169E1">THEN</font> LP:=INV(LP); <font color="#4169E1">ELSE</font> LP:=INV(M); <strong><font color="#4169E1">END</font></strong>; 
      L:=CONC(LP,L); RETURN(L); 
<font color="#B22222">(*7*)</font> <strong><font color="#4169E1">END</font></strong> MUPSFF; 


<strong><font color="#4169E1">PROCEDURE RPBLGS</font></strong>(RL,A: LIST;  <strong><font color="#228B22">VAR</font></strong> AL,BL,SL: LIST); 
<font color="#B22222">(*Rational polynomial base coefficients least common multiple, greatest common divisor, and sign.  
A is a rational polynomial in r variables, r ge 0.  If A=0 then 
a=b=s=0.  Otherwise, a is the lcm of the denominators of the 
base coefficients of A, b is the gcd of the numerators of 
the base coefficients of A, and s is the sign of the leading base 
coefficient of A.*)</font>
<strong><font color="#228B22">VAR</font></strong>  ALP, AS, BLP, CL, EL, RLP, SLP: LIST; 
<strong><font color="#4169E1">BEGIN</font></strong>
<font color="#B22222">(*1*)</font> <font color="#B22222">(*a eq 0.*)</font> 
      <font color="#4169E1">IF</font> A = 0 <font color="#4169E1">THEN</font> AL:=0; BL:=0; SL:=0; RETURN; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*2*)</font> <font color="#B22222">(*rl eq 0.*)</font> 
      <font color="#4169E1">IF</font> RL = 0 <font color="#4169E1">THEN</font> BLP:=FIRST(A); SL:=ISIGNF(BLP); 
         BL:=IABSF(BLP); AL:=SECOND(A); RETURN; <strong><font color="#4169E1">END</font></strong>; 
<font color="#B22222">(*3*)</font> <font color="#B22222">(*general case.*)</font> RLP:=RL-1; ADV2(A, EL,CL,AS); RPBLGS(RLP,CL,
      AL,BL,SL); 
      <font color="#4169E1">WHILE</font> AS &lt;&gt; SIL <font color="#4169E1">DO</font> ADV2(AS, EL,CL,AS); 
            <font color="#4169E1">IF</font> RLP = 0 <font color="#4169E1">THEN</font> FIRST2(CL, BLP,ALP); <font color="#4169E1">ELSE</font>
               RPBLGS(RLP,CL, ALP,BLP,SLP); <strong><font color="#4169E1">END</font></strong>; 
            AL:=ILCM(AL,ALP); 
            <font color="#4169E1">IF</font> BL &lt;&gt; 1 <font color="#4169E1">THEN</font> BL:=IGCD(BL,BLP); <strong><font color="#4169E1">END</font></strong>; 
            <strong><font color="#4169E1">END</font></strong>; 
      RETURN; 
<font color="#B22222">(*6*)</font> <strong><font color="#4169E1">END</font></strong> RPBLGS; 


<strong><font color="#4169E1">END</font></strong> SACPGCD.
<font color="#B22222">(* -EOF- *)</font>
</pre>
</body>

</html>
