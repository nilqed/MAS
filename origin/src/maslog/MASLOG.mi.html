
<html>
<head>
<title>./maslog/MASLOG.mi</title>
<meta name="generator" content="pas2html 0.9.2">
<meta name="date" content="1994-12-09T09:42:51+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80"><font color="#B22222">(* ----------------------------------------------------------------------------
 * $Id: MASLOG.mi,v 1.4 1994/11/28 21:04:08 dolzmann Exp $
 * ----------------------------------------------------------------------------
 * Copyright (c) 1993 Universitaet Passau
 * ----------------------------------------------------------------------------
 * This file is part of MAS.
 * ----------------------------------------------------------------------------
 * $Log: MASLOG.mi,v $
 * Revision 1.4  1994/11/28  21:04:08  dolzmann
 * New revision of the MASLOG system: New functions and bug fixes of old one.
 *
 * Revision 1.3  1993/12/17  17:12:10  dolzmann
 * MASLOG is divided into three parts. (MLOGBASE, MLOGIO, MASLOG)
 * Additional input procedures are added.
 *
 * Revision 1.2  1993/10/03  18:28:02  dolzmann
 * New version of procedure FORMKVD
 *
 * Revision 1.1  1993/07/13  14:44:06  dolzmann
 * The maslog-system and a simple example.
 *
 * ----------------------------------------------------------------------------
 *)</font>

IMPLEMENTATION MODULE MASLOG;
<font color="#B22222">(* Maslog Implementation Module. *)</font>

<font color="#B22222">(******************************************************************************
*				 M A S L O G				      *
*-----------------------------------------------------------------------------*
* Author:   Andreas Dolzmann                                                  *
* Language: MODULA II (mocka or mtc are possible.)                            *
* System:   Program for the computer algebra system MAS by Heinz Kredel.      *
* Project:  MASLOG                                                            *
* Remark:   Libraries maskern, maslisp are used.                              *
* Abstract: A package for the MAS computer algebra system by Heinz Kredel.    *
*           This package implements basic routins on formulas of the first    *
*           order predicate calculus.                                         *
******************************************************************************)</font>

FROM MASBIOS	IMPORT	BLINES, MASORD, SWRITE;
FROM MASELEM	IMPORT	MASREM;
FROM MASERR	IMPORT	ERROR, confusion, fatal, harmless, severe, spotless;
FROM MASLISPU	IMPORT	Declare, PROCF0, PROCF1, PROCF2, PROCF3, PROCP1;
FROM MASSET	IMPORT	SetAddQ, SetComplementQ;
FROM MASSTOR	IMPORT	ADV, COMP, FIRST, INV, LENGTH, LIST, LIST1, RED, SIL;
FROM MASSYM2	IMPORT	ASSOCQ, ENTER, EXPLOD, GENSYM, SREAD, UWRITE; 
FROM MLOGBASE	IMPORT	ANY, BOOL, EQUIV, ET, EXIST, FALSUM, FORALL,
			FORGARGS, FORGLVAR, FORGOP, FORISATOM, FORISBBFOR,
			FORISBOOLVAR, FORISLVAR, FORISVAR, FORMKBINOP,
			FORMKCNST, FORMKFOR, FORMKLVAR, FORMKQUANT,
			FORMKUNOP, FORMKVAR, FORPARGS, FORPBINOP, FORPBINOPA,
			FORPFOR, FORPLVAR, FORPQUANT, FORPQUANTA, FORPUNOP,
			FORPUNOPA, FORPVAR, FORPVARA, FORTST, FORVTENTER,
			FORVTGET, IMP, NON, PROCFB1, PROCFB2, REP, TVAR, VEL,
			VERUM, XOR; 
FROM SACLIST	IMPORT	ADV2, ADV3, AREAD, CCONC, CINV, COMP2, CONC, EQUAL,
			LIST10, LIST2, LIST3, LIST4, LIST5, MEMBER, SECOND,
			THIRD;
			
<strong><font color="#228B22">CONST</font></strong> rcsidi = "$Id: MASLOG.mi,v 1.4 1994/11/28 21:04:08 dolzmann Exp $";
<strong><font color="#228B22">CONST</font></strong> copyrighti = "Copyright (c) 1993 Universitaet Passau";


<font color="#B22222">(******************************************************************************
*			  M A K E   P O S I T I V E			      *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORMKPOS</font></strong>(phi, pref: LIST;bbmkneg:PROCF1):LIST;
<font color="#B22222">(* formula make positive. phi is a formula; pref is a symbol of the set \{ET,
VEL, NON\}; bbmkneg is a bb-procedure to negate a bb-formula; a formula
equivalent to phi, which is relative positive, is returned.  Relative positive
means that negations are only in front of atomic formulas. pref is a switch
that controls the substitution of the operators IMP, REP, EQUIV, XOR. If
pref=NON then subformulas with IMP and REP are substituted, only if they are
negated, EQUIV and XOR are not substituted.  If pref=ET or pref=VEL then IMP
and REP are substituted every time.  If pref=ET (pref=VEL) then the outermost
operator of the replacement for EQUIV and XOR is an ET (a VEL) operator. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, args, vars, formula, posformula, result, key: LIST;
	<strong><font color="#228B22">VAR</font></strong> arg1, arg2, posarg1, posarg2, nposarg1, nposarg2: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi = SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	<font color="#4169E1">IF</font> (pref&lt;&gt;VEL) <font color="#4169E1">AND</font> (pref&lt;&gt;ET) <font color="#4169E1">AND</font> (pref&lt;&gt;NON) <font color="#4169E1">THEN</font>
		ERROR(severe,"FORMKPOS: wrong preference given (assume NON)");
		pref:=NON;
	<strong><font color="#4169E1">END</font></strong>;
	FORPFOR(phi,op,args);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
		RETURN phi;
	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(args,formula);
		RETURN complement(formula,pref,bbmkneg);
	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> args &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(args,formula,args);
			posformula:=FORMKPOS(formula,pref,bbmkneg);
			result:=COMP(posformula,result);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKFOR(op,INV(result));
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(args,vars,formula);
		posformula:=FORMKPOS(formula,pref,bbmkneg);
		RETURN FORMKQUANT(op,vars,posformula);
	ELSIF (op=IMP) <font color="#4169E1">AND</font> (pref&lt;&gt;NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		RETURN FORMKBINOP(VEL,complement(arg1,pref,bbmkneg),
			FORMKPOS(arg2,pref,bbmkneg));
	ELSIF (op=IMP) <font color="#4169E1">AND</font> (pref=NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		RETURN FORMKBINOP(IMP,FORMKPOS(arg1,pref,bbmkneg),
					FORMKPOS(arg2,pref,bbmkneg));
	ELSIF (op=REP) <font color="#4169E1">AND</font> (pref&lt;&gt;NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		RETURN FORMKBINOP(VEL,FORMKPOS(arg1,pref,bbmkneg),
			complement(arg2,pref,bbmkneg));
	ELSIF (op=REP) <font color="#4169E1">AND</font> (pref=NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		RETURN FORMKBINOP(REP,FORMKPOS(arg1,pref,bbmkneg),
					FORMKPOS(arg2,pref,bbmkneg));
	ELSIF (op=EQUIV) <font color="#4169E1">AND</font> (pref&lt;&gt;NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		posarg1:=FORMKPOS(arg1,pref,bbmkneg);
		posarg2:=FORMKPOS(arg2,pref,bbmkneg);
		nposarg1:=complement(arg1,pref,bbmkneg);
		nposarg2:=complement(arg2,pref,bbmkneg);
		<font color="#4169E1">IF</font> pref=ET <font color="#4169E1">THEN</font>
			RETURN FORMKBINOP(ET,FORMKBINOP(VEL,nposarg1,posarg2),
				 FORMKBINOP(VEL,posarg1,nposarg2));
		ELSIF pref=VEL <font color="#4169E1">THEN</font>
			RETURN FORMKBINOP(VEL,FORMKBINOP(ET,posarg1,posarg2),
				 FORMKBINOP(ET,nposarg1,nposarg2));
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF (op=EQUIV) <font color="#4169E1">AND</font> (pref=NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		RETURN FORMKBINOP(EQUIV,
			FORMKPOS(arg1,pref,bbmkneg),
			FORMKPOS(arg2,pref,bbmkneg));
	ELSIF (op=XOR) <font color="#4169E1">AND</font> (pref&lt;&gt;NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		posarg1:=FORMKPOS(arg1,pref,bbmkneg);
		posarg2:=FORMKPOS(arg2,pref,bbmkneg);
		nposarg1:=complement(arg1,pref,bbmkneg);
		nposarg2:=complement(arg2,pref,bbmkneg);
		<font color="#4169E1">IF</font> pref=VEL <font color="#4169E1">THEN</font>
			RETURN FORMKBINOP(VEL,FORMKBINOP(ET,posarg1,nposarg2),
				FORMKBINOP(ET,nposarg1,posarg2));
		ELSIF pref=ET <font color="#4169E1">THEN</font>
			RETURN FORMKBINOP(ET,FORMKBINOP(VEL,posarg1,posarg2),
				 FORMKBINOP(VEL,nposarg1,nposarg2));
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF (op=XOR) <font color="#4169E1">AND</font> (pref=NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		RETURN FORMKBINOP(XOR,
			FORMKPOS(arg1,pref,bbmkneg),
			FORMKPOS(arg2,pref,bbmkneg));
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		RETURN phi;
	<font color="#4169E1">ELSE</font>
		RETURN phi;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORMKPOS;

<strong><font color="#4169E1">PROCEDURE complement</font></strong>(phi, pref: LIST; bbmkneg:PROCF1): LIST;
<font color="#B22222">(* complement. like FORMKPOS, but supposes that phi is negated. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op,args,vars,formula,posformula,result: LIST;
	<strong><font color="#228B22">VAR</font></strong> arg1,arg2, posarg1, posarg2, nposarg1, nposarg2: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi = SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;
	FORPFOR(phi,op,args);
	<font color="#4169E1">IF</font> op=VERUM <font color="#4169E1">THEN</font>
		RETURN FORMKCNST(FALSUM);
	ELSIF op=FALSUM <font color="#4169E1">THEN</font>
		RETURN FORMKCNST(VERUM);
	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPARGS(args,formula,args);
		RETURN FORMKPOS(formula,pref,bbmkneg);
	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> args &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(args,formula,args);
			posformula:=complement(formula,pref,bbmkneg);
			result:=COMP(posformula,result);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKFOR(notsymbol(op),INV(result));
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(args,vars,formula);
		posformula:=complement(formula,pref,bbmkneg);
		RETURN FORMKQUANT(notsymbol(op),vars,posformula);
	ELSIF op=REP <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		posarg1:=complement(arg1,pref,bbmkneg);
		posarg2:=FORMKPOS(arg2,pref,bbmkneg);
		RETURN FORMKBINOP(ET,posarg1,posarg2);
	ELSIF op=IMP <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		posarg1:=FORMKPOS(arg1,pref,bbmkneg);
		posarg2:=complement(arg2,pref,bbmkneg);
		RETURN FORMKBINOP(ET,posarg1,posarg2);
	ELSIF (op=XOR) <font color="#4169E1">AND</font> (pref&lt;&gt;NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		posarg1:=FORMKPOS(arg1,pref,bbmkneg);
		posarg2:=FORMKPOS(arg2,pref,bbmkneg);
		nposarg1:=complement(arg1,pref,bbmkneg);
		nposarg2:=complement(arg2,pref,bbmkneg);
		<font color="#4169E1">IF</font> pref=ET <font color="#4169E1">THEN</font>
			RETURN FORMKBINOP(ET,FORMKBINOP(VEL,posarg1,nposarg2),
				 FORMKBINOP(VEL,nposarg1,posarg2));
		ELSIF pref=VEL <font color="#4169E1">THEN</font>
			RETURN FORMKBINOP(VEL,FORMKBINOP(ET,posarg1,posarg2),
				 FORMKBINOP(ET,nposarg1,nposarg2));
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF (op=XOR) <font color="#4169E1">AND</font> (pref=NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		RETURN FORMKBINOP(EQUIV,
			FORMKPOS(arg1,pref,bbmkneg),
			FORMKPOS(arg2,pref,bbmkneg));
	ELSIF (op=EQUIV) <font color="#4169E1">AND</font> (pref&lt;&gt;NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		posarg1:=FORMKPOS(arg1,pref,bbmkneg);
		posarg2:=FORMKPOS(arg2,pref,bbmkneg);
		nposarg1:=complement(arg1,pref,bbmkneg);
		nposarg2:=complement(arg2,pref,bbmkneg);
		<font color="#4169E1">IF</font> pref=VEL <font color="#4169E1">THEN</font>
			RETURN FORMKBINOP(VEL,FORMKBINOP(ET,posarg1,nposarg2),
				 FORMKBINOP(ET,nposarg1,posarg2));
		ELSIF pref=ET <font color="#4169E1">THEN</font>
			RETURN FORMKBINOP(ET,FORMKBINOP(VEL,posarg1,posarg2),
				 FORMKBINOP(VEL,nposarg1,nposarg2));
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF (op=EQUIV) <font color="#4169E1">AND</font> (pref=NON) <font color="#4169E1">THEN</font>
		FORPBINOPA(args,arg1,arg2);
		RETURN FORMKBINOP(XOR,
			FORMKPOS(arg1,pref,bbmkneg),
			FORMKPOS(arg2,pref,bbmkneg));
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		RETURN FORMKUNOP(NON,phi);
	<font color="#4169E1">ELSE</font>
		RETURN bbmkneg(phi);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> complement;


<font color="#B22222">(******************************************************************************
*	    M A K E   D I S J U N C T I V E   N O R M A L F O R M	      *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORMKDNF</font></strong>(phi: LIST; bbmkneg: PROCF1): LIST;
<font color="#B22222">(* formula make dnf. phi is a quantifier-free formula, bbmkneg is a
bb-pro\-ce\-dure to negate a bb-formula; a formula phi1 equivalent to phi is
returned.  phi1 is in strict dnf. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	RETURN FORMKDNF1(phi, bbmkneg, FALSE);
<strong><font color="#4169E1">END</font></strong> FORMKDNF;

<strong><font color="#4169E1">PROCEDURE FORMKDNF1</font></strong>(phi: LIST; bbmkneg: PROCF1; neg: BOOLEAN): LIST;
<font color="#B22222">(* formula make postiv 1. phi is a quantifier-free formula; bbmkneg is a
bb-procedure to negate a bb-formula, neg is a flag that shows whether a
negation was read or not; FORMKDNF1 returns an equivalent formula in strict
dnf. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, dnfarg, result, opvel, psi, prednf: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi=SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
		<font color="#4169E1">IF</font> neg 	<font color="#4169E1">THEN</font>
			RETURN FORMKUNOP(VEL,
				FORMKUNOP(ET,notsymbol(phi)));
		<font color="#4169E1">ELSE</font>
			RETURN FORMKUNOP(VEL,FORMKUNOP(ET,phi));
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(red,arg);
		RETURN FORMKDNF1(arg,bbmkneg,<font color="#4169E1">NOT</font> neg);
	ELSIF ((op=VEL) <font color="#4169E1">AND</font> (<font color="#4169E1">NOT</font> neg)) <font color="#4169E1">OR</font> ((op=ET) <font color="#4169E1">AND</font> neg) <font color="#B22222">(* VEL *)</font> 	<font color="#4169E1">THEN</font>
		<font color="#B22222">(* transform all arguments in dnf and join all disjunctions *)</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> red &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			dnfarg:=FORMKDNF1(arg,bbmkneg,neg);
			FORPARGS(dnfarg,opvel,psi);
			result:=CCONC(result,psi);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKFOR(VEL,result);
	ELSIF ((op=ET) <font color="#4169E1">AND</font> (<font color="#4169E1">NOT</font> neg)) <font color="#4169E1">OR</font> ((op=VEL) <font color="#4169E1">AND</font> neg) <font color="#B22222">(* ET *)</font> <font color="#4169E1">THEN</font>
		<font color="#B22222">(* transform all arguments in dnf ... *)</font>
		prednf:=SIL;
		<font color="#4169E1">WHILE</font> red &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			prednf:=COMP(FORMKDNF1(arg,bbmkneg,neg),prednf);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN distribetovel(INV(prednf));
	ELSIF op=IMP <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKDNF1(FORMKBINOP(VEL,FORMKUNOP(NON,arg1),arg2),
			bbmkneg,neg);
	ELSIF op=REP <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKDNF1(FORMKBINOP(VEL,arg1,FORMKUNOP(NON,arg2)),
			bbmkneg,neg);
	ELSIF ((op=EQUIV) <font color="#4169E1">AND</font> (<font color="#4169E1">NOT</font> neg)) <font color="#4169E1">OR</font> ((op=XOR) <font color="#4169E1">AND</font> neg) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKDNF1(FORMKBINOP(VEL,
			FORMKBINOP(ET,
				FORMKUNOP(NON,arg1),FORMKUNOP(NON,arg2)),
			FORMKBINOP(ET,arg1,arg2)),bbmkneg,FALSE);
	ELSIF ((op=XOR) <font color="#4169E1">AND</font> (<font color="#4169E1">NOT</font> neg)) <font color="#4169E1">OR</font> ((op=EQUIV) <font color="#4169E1">AND</font> neg) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKDNF1(FORMKBINOP(VEL,
			FORMKBINOP(ET,arg1,FORMKUNOP(NON,arg2)),
			FORMKBINOP(ET,FORMKUNOP(NON,arg1),arg2)),
			bbmkneg,FALSE);
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		<font color="#4169E1">IF</font> neg <font color="#4169E1">THEN</font>
			RETURN FORMKUNOP(VEL,FORMKUNOP(ET,FORMKUNOP(NON,phi)));
		<font color="#4169E1">ELSE</font>
			RETURN FORMKUNOP(VEL,FORMKUNOP(ET,phi));
		<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">ELSE</font>
		<font color="#4169E1">IF</font> neg <font color="#4169E1">THEN</font>
			RETURN FORMKUNOP(VEL,
				FORMKUNOP(ET,bbmkneg(phi)));
		<font color="#4169E1">ELSE</font>
			RETURN FORMKUNOP(VEL,FORMKUNOP(ET,phi));
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORMKDNF1;

<strong><font color="#4169E1">PROCEDURE distribetovel</font></strong>(L: LIST): LIST;
<font color="#B22222">(* distributive et over vel. L is a list of boolean terms in strict dnf; a
boolean term t equivalent to ET(L) is returned. t is in strict dnf. *)</font>
	<strong><font color="#228B22">VAR</font></strong> first, firstpt, tail, elem, redelem, obj, result, prefix: LIST;
	<strong><font color="#228B22">VAR</font></strong> dummy: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> L = SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(L,first,tail);
	<font color="#4169E1">IF</font> tail = SIL <font color="#4169E1">THEN</font>
		RETURN first;
	<strong><font color="#4169E1">END</font></strong>;
	FORPARGS(first,dummy,first);
	<font color="#4169E1">WHILE</font> tail &lt;&gt; SIL <font color="#4169E1">DO</font>
		FORPARGS(tail,obj,tail);
		FORPARGS(obj,dummy,obj);
		result:=SIL;
		<font color="#4169E1">WHILE</font> obj &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(obj,elem,obj);
			redelem:=RED(elem);
			firstpt:=first;
			<font color="#4169E1">WHILE</font> firstpt &lt;&gt; SIL <font color="#4169E1">DO</font>
				FORPARGS(firstpt,prefix,firstpt);
				result:=COMP(CCONC(prefix,redelem),result);
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
		first:=result;
	<strong><font color="#4169E1">END</font></strong>;
	result:=FORMKFOR(VEL,result);
	RETURN result;
<strong><font color="#4169E1">END</font></strong> distribetovel;


<font color="#B22222">(******************************************************************************
*	    M A K E   C O N J U N C T I V E   N O R M A L   F O R M           *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORMKCNF</font></strong>(phi: LIST; bbmkneg: PROCF1): LIST;
<font color="#B22222">(* formula make cnf. phi is a quantifier-free formula, bbmkneg is a
bb-pro\-ce\-dure to negate a bb-formula; a formula phi1 equivalent to phi is
returned.  phi1 is in strict cnf. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	RETURN FORMKCNF1(phi, bbmkneg, FALSE);
<strong><font color="#4169E1">END</font></strong> FORMKCNF;

<strong><font color="#4169E1">PROCEDURE FORMKCNF1</font></strong>(phi: LIST; bbmkneg: PROCF1; neg: BOOLEAN): LIST;
<font color="#B22222">(* formula make cnf 1. phi is a quantifier-free formula, bbmkneg is a
bb-procedure to negate a bb-formula positive, neg is a flag, that shows
whether a negation was read or not; FORMKCNF1 returns an equivalent formula in
strict cnf. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, cnfarg, result, opet, psi, precnf: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi=SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
		<font color="#4169E1">IF</font> neg 	<font color="#4169E1">THEN</font>
			RETURN FORMKUNOP(ET,
				FORMKUNOP(VEL,notsymbol(op)));
		<font color="#4169E1">ELSE</font>
			RETURN FORMKUNOP(ET,FORMKUNOP(VEL,phi));
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(red,arg);
		RETURN FORMKCNF1(arg,bbmkneg,<font color="#4169E1">NOT</font> neg);
	ELSIF ((op=ET) <font color="#4169E1">AND</font> (<font color="#4169E1">NOT</font> neg)) <font color="#4169E1">OR</font> ((op=VEL) <font color="#4169E1">AND</font> neg)  <font color="#B22222">(* op=ET *)</font> <font color="#4169E1">THEN</font>
		<font color="#B22222">(* transform all arguments in cnf and join all disjunctions *)</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> red &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			cnfarg:=FORMKCNF1(arg,bbmkneg,neg);
			FORPARGS(cnfarg,opet,psi);
			result:=CCONC(result,psi);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKFOR(ET,result);
	ELSIF ((op=VEL) <font color="#4169E1">AND</font> (<font color="#4169E1">NOT</font> neg)) <font color="#4169E1">OR</font> ((op=ET) <font color="#4169E1">AND</font> neg)  <font color="#B22222">(* op=VEL *)</font> <font color="#4169E1">THEN</font>
		<font color="#B22222">(* transform all arguments in cnf ... *)</font>
		precnf:=SIL;
		<font color="#4169E1">WHILE</font> red &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			precnf:=COMP(FORMKCNF1(arg,bbmkneg,neg),precnf);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN distribveloet(INV(precnf));
	ELSIF op=IMP <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKCNF1(FORMKBINOP(VEL,FORMKUNOP(NON,arg1),arg2),
			bbmkneg,neg);
	ELSIF op=REP <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKCNF1(FORMKBINOP(VEL,arg1,FORMKUNOP(NON,arg2)),
			bbmkneg,neg);
	ELSIF ((op=XOR) <font color="#4169E1">AND</font> (<font color="#4169E1">NOT</font> neg)) <font color="#4169E1">OR</font> ((op=EQUIV) <font color="#4169E1">AND</font> neg) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKCNF1(FORMKBINOP(ET,
			FORMKBINOP(VEL,
				FORMKUNOP(NON,arg1),FORMKUNOP(NON,arg2)),
			FORMKBINOP(VEL,arg1,arg2)),bbmkneg,FALSE);
	ELSIF ((op=EQUIV) <font color="#4169E1">AND</font> (<font color="#4169E1">NOT</font> neg)) <font color="#4169E1">OR</font> ((op=XOR) <font color="#4169E1">AND</font> neg) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKCNF1(FORMKBINOP(ET,
			FORMKBINOP(VEL,arg1,FORMKUNOP(NON,arg2)),
			FORMKBINOP(VEL,FORMKUNOP(NON,arg1),arg2)),
			bbmkneg,FALSE);
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		<font color="#4169E1">IF</font> neg 	<font color="#4169E1">THEN</font>
			RETURN FORMKUNOP(ET,FORMKUNOP(VEL,FORMKUNOP(NON,phi)));
		<font color="#4169E1">ELSE</font>
			RETURN FORMKUNOP(ET,FORMKUNOP(VEL,phi));
		<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">ELSE</font>
		<font color="#4169E1">IF</font> neg 	<font color="#4169E1">THEN</font>
			RETURN FORMKUNOP(ET,
				FORMKUNOP(VEL,bbmkneg(phi)));
		<font color="#4169E1">ELSE</font>
			RETURN FORMKUNOP(ET,FORMKUNOP(VEL,phi));
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORMKCNF1;

<strong><font color="#4169E1">PROCEDURE distribveloet</font></strong>(L: LIST): LIST;
<font color="#B22222">(* distributive vel over et. L is a list of quantifier-free formulas in strict
cnf; a quantifier-free formula equivalent to VEL(L), which is in strict cnf,
is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> first, firstpt, tail, elem, redelem, obj, result, prefix: LIST;
	<strong><font color="#228B22">VAR</font></strong> dummy: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> L = SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(L,first,tail);
	<font color="#4169E1">IF</font> tail = SIL <font color="#4169E1">THEN</font>
		RETURN first;
	<strong><font color="#4169E1">END</font></strong>;
	FORPARGS(first,dummy,first);
	<font color="#4169E1">WHILE</font> tail &lt;&gt; SIL <font color="#4169E1">DO</font>
		FORPARGS(tail,obj,tail);
		FORPARGS(obj,dummy,obj);
		result:=SIL;
		<font color="#4169E1">WHILE</font> obj &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(obj,elem,obj);
			redelem:=RED(elem);
			firstpt:=first;
			<font color="#4169E1">WHILE</font> firstpt &lt;&gt; SIL <font color="#4169E1">DO</font>
				FORPARGS(firstpt,prefix,firstpt);
				result:=COMP(CCONC(prefix,redelem),result);
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
		first:=result;
	<strong><font color="#4169E1">END</font></strong>;
	result:=FORMKFOR(ET,result);
	RETURN result;
<strong><font color="#4169E1">END</font></strong> distribveloet;


<font color="#B22222">(******************************************************************************
*			    M A K E   P R E N E X			      *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORMKPRENEX</font></strong>(phi,pref:LIST): LIST;
<font color="#B22222">(* formula make prenex. phi is a formula; pref is an element of \{EXIST,
FORALL\}; a formula psi in prenex normal form is returned.  phi must be a
relative positive formula without additional operation symbols like IMP, REP,
etc.  All bound variables in phi must have different specifications (i.e.
different names or different types).  The only transformation which is used to
calculate psi is the interchange of a junctor with a quantifier.  The formula
psi has the minimal number of blocks of quantifiers under all prenex formulas
which are built using only the interchange of a junctor with a quantifier.
The argument pref is only respected, if there are two equivalent formulas with
the same optimal number of blocks of quantifiers.  In this case the formula is
returned which has a "pref"-quantifier as the outermost operation symbol.*)</font>
	<strong><font color="#228B22">VAR</font></strong> pnfs, phi1, phi2, qbphi1, qbphi2: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> (pref&lt;&gt;EXIST) <font color="#4169E1">AND</font> (pref&lt;&gt;FORALL) <font color="#4169E1">THEN</font>
		ERROR(severe,
			"FORMKPRENEX: wrong preference given (assume EXIST)");
		pref:=EXIST;
	<strong><font color="#4169E1">END</font></strong>;
	pnfs:=FORMKPRENEX1(phi);
	<font color="#4169E1">IF</font> RED(pnfs)=SIL <font color="#4169E1">THEN</font>
		<font color="#B22222">(* Only one element: No choice is possible. *)</font>
		RETURN FIRST(FIRST(pnfs));
	<strong><font color="#4169E1">END</font></strong>;
	phi1:=FIRST(FIRST(pnfs));
	phi2:=FIRST(SECOND(pnfs));
	qbphi1:=SECOND(FIRST(pnfs));
	qbphi2:=SECOND(SECOND(pnfs));
	<font color="#B22222">(* Choice resp. number of blocks of quantifiers. *)</font>
	<font color="#4169E1">IF</font> qbphi1&lt;qbphi2 <font color="#4169E1">THEN</font>
		RETURN phi1;
	ELSIF qbphi1&gt;qbphi2 <font color="#4169E1">THEN</font>
		RETURN phi2;
	<font color="#B22222">(* Choice resp. the preferd type of quantifier. *)</font>
	ELSIF FORGOP(phi1)=pref <font color="#4169E1">THEN</font>
		RETURN phi1;
	<font color="#4169E1">ELSE</font>
		RETURN phi2;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORMKPRENEX;

<strong><font color="#4169E1">PROCEDURE FORMKPRENEXI</font></strong>(phi,pref:LIST): LIST;
<font color="#B22222">(* formula make prenex. phi is a formula; pref is an element of \{EXIST,
FORALL\}; a formula psi in prenex normal form is returned.  phi must be a
relative positive formula without additional operation symbols like IMP, REP,
etc.  All bound variables in phi must have different specifications (i.e.
different names or different types).  The only transformation which is used to
calculate psi is the interchange of a junctor with a quantifier.  The formula
psi has the minimal number of blocks of quantifiers under all prenex formulas
which are built using only the interchange of a junctor with a quantifier.
The argument pref is only respected, if there are two equivalent formulas with
the same optimal number of blocks of quantifiers.  In this case the formula is
returned which has a "pref"-quantifier as the innermost operation symbol.*)</font>
	<strong><font color="#228B22">VAR</font></strong> pnfs, phi1, phi2, qbphi1, qbphi2: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> (pref&lt;&gt;EXIST) <font color="#4169E1">AND</font> (pref&lt;&gt;FORALL) <font color="#4169E1">THEN</font>
		ERROR(severe,
			"FORMKPRENEX: wrong preference given (assume EXIST)");
		pref:=EXIST;
	<strong><font color="#4169E1">END</font></strong>;
	pnfs:=FORMKPRENEX1(phi);
	<font color="#4169E1">IF</font> RED(pnfs)=SIL <font color="#4169E1">THEN</font>
		<font color="#B22222">(* Only one element: No choice is possible. *)</font>
		RETURN FIRST(FIRST(pnfs));
	<strong><font color="#4169E1">END</font></strong>;
	phi1:=FIRST(FIRST(pnfs));
	phi2:=FIRST(SECOND(pnfs));
	qbphi1:=SECOND(FIRST(pnfs));
	qbphi2:=SECOND(SECOND(pnfs));
	<font color="#B22222">(* Choice resp. number of blocks of quantifiers. *)</font>
	<font color="#4169E1">IF</font> qbphi1&lt;qbphi2 <font color="#4169E1">THEN</font>
		RETURN phi1;
	ELSIF qbphi1&gt;qbphi2 <font color="#4169E1">THEN</font>
		RETURN phi2;
	<font color="#B22222">(* Choice resp. the preferd type of quantifier. *)</font>
	ELSIF FORIMQB(phi1)=pref <font color="#4169E1">THEN</font>
		RETURN phi1;
	<font color="#4169E1">ELSE</font>
		RETURN phi2;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORMKPRENEXI;

<strong><font color="#4169E1">PROCEDURE FORMKPRENEX1</font></strong>(phi: LIST): LIST;
<font color="#B22222">(* formula make prenex 1. phi is a relative positive formula; this procedure
returns a list of maximal two objects of the form (psi,qb(psi)). In
(psi,qb(psi)) psi is a formula in prenex normal form, and qb(psi) the number
of blocks of quantifiers.  If there are two objects in the returned list, then
the outermost quantifier of the first formula is an exist quantifier and the
outermost quantifier of the second formula is a forall quantifier.  In the
following comments such a list is called pnf-selection. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, res: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	FORPFOR(phi,op,res);
	<font color="#4169E1">IF</font> (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		RETURN pnfquantifier(phi)
	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		RETURN pnfjunctor(phi);
	<font color="#4169E1">ELSE</font>  	<font color="#B22222">(* i.e. phi is an atomic formula,
		   but not necessary a bb-formula.
		   VERUM, FALSUM, or a bb-formula, (which are
		   eventually negated) are possible. *)</font>
		RETURN LIST1(LIST2(phi,0))
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORMKPRENEX1;

<strong><font color="#4169E1">PROCEDURE pnfquantifier</font></strong>(phi:LIST): LIST;
<font color="#B22222">(* prenex normal form quantifier. phi is a relative positive formula with an
quantifier as the outermost operator symbol; pnfquantifier returns a
pnf-selection with only one formula equivalent to phi. *)</font>
	<strong><font color="#228B22">VAR</font></strong> pnfs, qf, vars, nvars, qform, psi1, psi2, qbpsi1, qbpsi2: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	FORPQUANT(phi,qf,vars,qform);
	nvars:=FORGLVAR(vars);
	pnfs:=FORMKPRENEX1(qform);
	psi1:=FIRST(FIRST(pnfs));
	qbpsi1:=SECOND(FIRST(pnfs));
	<font color="#4169E1">IF</font> RED(pnfs)=SIL <font color="#4169E1">THEN</font> <font color="#B22222">(* #pnfs=1 *)</font>
		RETURN LIST1(mkquant(qf,nvars,psi1,qbpsi1));
	ELSIF FORGOP(psi1)=qf <font color="#4169E1">THEN</font>
		RETURN LIST1(mkquant(qf,nvars,psi1,qbpsi1));
	<font color="#4169E1">ELSE</font>
		psi2:=FIRST(SECOND(pnfs));
		qbpsi2:=SECOND(SECOND(pnfs));
		RETURN LIST1(mkquant(qf,nvars,psi2,qbpsi2));
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> pnfquantifier;

<strong><font color="#4169E1">PROCEDURE mkquant</font></strong>(qf,vars,phi,qbqform: LIST): LIST;
<font color="#B22222">(* make quantifier. qf is a quantifier; vars is a list of the bound
variables of qf; phi is a formula; qbqform is the number of blocks of
quantifiers of qform, mkquantifier returns a pnf-selection with formulas
equivalent to the formula 'qf vars: phi'. If phi is a quantified formula and
the outermost quantifier of phi is a qf quantifier then mkquant generates no
new quantifier, but bounds the variables var to the outermost quantifier of
phi. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op,res,form,newvarlist, varlist:LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	FORPFOR(phi,op,res);
	<font color="#4169E1">IF</font> op&lt;&gt;qf <font color="#4169E1">THEN</font>
		RETURN LIST2(FORMKQUANT(qf,FORMKLVAR(vars),phi),qbqform+1);
	<font color="#4169E1">ELSE</font>
		FORPQUANTA(res,varlist,form);
		newvarlist:=CCONC(vars,FORGLVAR(varlist));
		RETURN LIST2(FORMKQUANT(qf,FORMKLVAR(newvarlist),form),
			qbqform);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> mkquant;

<strong><font color="#4169E1">PROCEDURE pnfjunctor</font></strong>(phi: LIST):LIST;
<font color="#B22222">(* prenex normal form junctor. phi is a relative positive formula with an ET
or VEL operator as the outermost function symbol; pnfjunctor returns a
pnf-selection with formulas equivalent to phi. If there are two objects in the
pnf-selection, then the outermost quantifier of the formula in the first
(second) object is an EXIST (FORALL) quantifier *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, res, arglist, pnfargs, arg, l1, l2, M, qf1, qf2:LIST;
	<strong><font color="#228B22">VAR</font></strong> phi1, qbphi1, phi2, qbphi2: LIST;
	<strong><font color="#228B22">VAR</font></strong> onlyex, onlyfa: BOOLEAN;
<strong><font color="#4169E1">BEGIN</font></strong>
	M:=0;
	onlyex:=TRUE;
	onlyfa:=TRUE;

	FORPFOR(phi,op,res);
	arglist:=SIL;
	l1:=SIL;
	l2:=SIL;
	<font color="#4169E1">WHILE</font> res&lt;&gt;SIL <font color="#4169E1">DO</font>
		FORPARGS(res,arg,res);
		pnfargs:=FORMKPRENEX1(arg);
		phi1:=FIRST(FIRST(pnfargs));
		qbphi1:=SECOND(FIRST(pnfargs));
		<font color="#B22222">(* calculate the characteristic selections *)</font>
		<font color="#4169E1">IF</font> RED(pnfargs)=SIL <font color="#4169E1">THEN</font>
			l1:=COMP(phi1,l1);
			l2:=COMP(phi1,l2);
			phi2:=phi1;
			qbphi2:=qbphi1;
		<font color="#4169E1">ELSE</font>
			phi2:=FIRST(SECOND(pnfargs));
			qbphi2:=SECOND(SECOND(pnfargs));
			<font color="#B22222">(* In resp. to the definition of pnf is the outermost
			* quantifier of phi1 (phi2) is an EXIST (FORALL)
			* quantifier *)</font>
			l1:=COMP(phi1,l1);
			l2:=COMP(phi2,l2);
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#B22222">(* compute the maximum of blocks of quantifiers,
		* simultaneous
		* ascertaian criterions which characteristic selection is
		* optimal resp. the number of blocks of quantifiers. *)</font>
		qf1:=FORGOP(phi1);
		qf2:=FORGOP(phi2);
		<font color="#4169E1">IF</font> M&lt;qbphi1 <font color="#4169E1">THEN</font>
			M:=qbphi1;
			onlyex:=TRUE;
			onlyfa:=TRUE;
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> (M=qbphi1) <font color="#4169E1">AND</font> (qf1&lt;&gt;EXIST)  <font color="#B22222">(* for M=0  meaningless *)</font>
		<font color="#4169E1">THEN</font> 				<font color="#B22222">(* but M=0 is a special *)</font>
			onlyex:=FALSE;		<font color="#B22222">(* case.		*)</font>
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> (M=qbphi2) <font color="#4169E1">AND</font> (qf2&lt;&gt;FORALL)	<font color="#B22222">(*        dito       *)</font>
		<font color="#4169E1">THEN</font>
			onlyfa:=FALSE
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> M=0 <font color="#4169E1">THEN</font>
		RETURN LIST1(LIST2(phi,0));
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#B22222">(* Calculate the result with respect to onlyex and onlyfa. *)</font>
	<font color="#B22222">(* refere to the proof in the documentation. *)</font>
	<font color="#4169E1">IF</font> onlyex <font color="#4169E1">AND</font> (<font color="#4169E1">NOT</font> onlyfa) <font color="#4169E1">THEN</font>
		RETURN LIST1(interchange(l1,op,EXIST));
	ELSIF onlyfa <font color="#4169E1">AND</font> (<font color="#4169E1">NOT</font> onlyex) <font color="#4169E1">THEN</font>
		RETURN LIST1(interchange(l2,op,FORALL));
	<font color="#4169E1">ELSE</font>
		RETURN LIST2(interchange(l1,op,EXIST),
			interchange(l2,op,FORALL));
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> pnfjunctor;

<strong><font color="#4169E1">PROCEDURE interchange</font></strong>(L,op,pref:LIST):LIST;
<font color="#B22222">(* interchange. L is a list of relative positive formulas; op is an operation
symbol (VEL or ET); pref is a quantifier symbol; interchange returns an element
of a pnf-selection with a formula equivalent to the formula 'op(L)'. pref is
the type of the outermost quantifier after the interchange, if a choice is
possible. *)</font>
	<strong><font color="#228B22">VAR</font></strong> l1, l2, qf, q, form, qblock, vblock, qform, vars: LIST;
 	<strong><font color="#228B22">VAR</font></strong> varlist, result, numqfb, nextop:LIST;
	<strong><font color="#228B22">VAR</font></strong> noqf: BOOLEAN;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> L=SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	l1:=L;
	qf:=pref;
	qblock:=SIL;	<font color="#B22222">(* List of all quantifiers in the blocks *)</font>
	vblock:=SIL;	<font color="#B22222">(* List of all bound variables in the blocks *)</font>
	<font color="#4169E1">REPEAT</font>
		l2:=SIL;
		varlist:=SIL;
		noqf:=TRUE;
		<font color="#4169E1">WHILE</font> l1&lt;&gt;SIL <font color="#4169E1">DO</font>
			ADV(l1,form,l1);
			getqfb(form,qf,vars,qform);
			nextop:=FORGOP(qform);
			noqf:=noqf <font color="#4169E1">AND</font> ((nextop&lt;&gt;EXIST) <font color="#4169E1">AND</font> (nextop&lt;&gt;FORALL));
			l2:=COMP(qform,l2);
			varlist:=CCONC(varlist,vars);
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> varlist &lt;&gt; SIL <font color="#4169E1">THEN</font>
			qblock:=COMP(qf,qblock);
			vblock:=COMP(FORMKLVAR(varlist),vblock);
		<strong><font color="#4169E1">END</font></strong>;
		l1:=l2;
		qf:=notsymbol(qf);
	<font color="#4169E1">UNTIL</font> noqf; <font color="#B22222">(* i.e there are no quantifiers in the formulas of L *)</font>
	<font color="#B22222">(* generate the result *)</font>
	numqfb:=LENGTH(vblock);
	result:=FORMKFOR(op,l1);
	<font color="#4169E1">WHILE</font> qblock &lt;&gt; SIL <font color="#4169E1">DO</font>
		ADV(qblock,q,qblock);
		ADV(vblock,varlist,vblock);
		result:=FORMKQUANT(q,varlist,result);
	<strong><font color="#4169E1">END</font></strong>;
	RETURN LIST2(result,numqfb);
<strong><font color="#4169E1">END</font></strong> interchange;

<strong><font color="#4169E1">PROCEDURE getqfb</font></strong>(phi,qf: LIST; <strong><font color="#228B22">VAR</font></strong> qfb, qform: LIST);
<font color="#B22222">(* get quantifier block. phi is a relative positive formula; qf is a
quantifier symbol.  qfb is assigned to a list of variables which are bound
to the outermost quantifier of type qf, qform is the formula bound by the
quantifier qf. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, res, varlist, bound: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	qfb:=SIL;
	FORPFOR(phi,op,res);
	<font color="#4169E1">IF</font> op&lt;&gt;qf <font color="#4169E1">THEN</font>
		qform:=phi;
		RETURN;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">WHILE</font> (op=qf) <font color="#4169E1">DO</font>
 		FORPQUANTA(res,varlist,qform);
		FORPLVAR(varlist,bound);
		qfb:=CCONC(qfb,bound);
		FORPFOR(qform,op,res);
	<strong><font color="#4169E1">END</font></strong>;
	RETURN;
<strong><font color="#4169E1">END</font></strong> getqfb;

<strong><font color="#4169E1">PROCEDURE FORIMQB</font></strong>(phi: LIST):LIST;
<font color="#B22222">(* formula innermost quantifier block. phi is a formula in prenex normal form.
If the outermost operator of phi is no quantifier then SIL is returned. 
Otherwise the type of the innermost quantifier block (either FOREX or FORALL) 
is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> sym, vars, imq : LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	sym:=FORGOP(phi);
	<font color="#4169E1">IF</font> (sym&lt;&gt;EXIST) <font color="#4169E1">AND</font> (sym&lt;&gt;FORALL) <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">REPEAT</font> 
		imq:=sym;
		FORPQUANT(phi,sym,vars,phi);
	<font color="#4169E1">UNTIL</font> (sym&lt;&gt;EXIST) <font color="#4169E1">AND</font> (sym&lt;&gt;FORALL);
	RETURN imq;
<strong><font color="#4169E1">END</font></strong> FORIMQB;

<font color="#B22222">(******************************************************************************
*		S U B S T I T U T E   V A R I A B L E                         *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORSUBSTVAR</font></strong>(phi, old, new: LIST; bbsubstvar: PROCF3): LIST;
<font color="#B22222">(* formula substitute variable. phi is a formula; old and new are variables; a
formula in which the variable old is substituted by the variable new is
returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, res, arg, arg1, arg2: LIST;
	<strong><font color="#228B22">VAR</font></strong> parlist, lvar, varlist, <strong><font color="#228B22">var</font></strong>, qform: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	FORPFOR(phi,op,res);

	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
		RETURN phi;
	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(res,arg);
		RETURN FORMKUNOP(op,FORSUBSTVAR(arg,old,new,bbsubstvar));
	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		parlist:=SIL;
		<font color="#4169E1">WHILE</font> res&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(res,arg,res);
			parlist:=COMP(FORSUBSTVAR(arg,old,new,bbsubstvar),
				parlist);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKFOR(op,INV(parlist));
	ELSIF (op=REP) <font color="#4169E1">OR</font> (op=IMP) <font color="#4169E1">OR</font> (op=EQUIV) <font color="#4169E1">OR</font> (op=XOR) <font color="#4169E1">THEN</font>
		FORPBINOPA(res,arg1,arg2);
		RETURN FORMKBINOP(op,
			FORSUBSTVAR(arg1,old,new,bbsubstvar),
			FORSUBSTVAR(arg2,old,new,bbsubstvar));
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		<font color="#4169E1">IF</font> EQUAL(phi,old)=1 <font color="#4169E1">THEN</font>
			RETURN new;
		<font color="#4169E1">ELSE</font>    
			RETURN phi;
		<strong><font color="#4169E1">END</font></strong>;       
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(res,lvar,qform);
		FORPLVAR(lvar,varlist);
		parlist:=SIL;
		<font color="#4169E1">WHILE</font> varlist&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(varlist,<strong><font color="#228B22">var</font></strong>,varlist);
			<font color="#4169E1">IF</font> EQUAL(<strong><font color="#228B22">var</font></strong>,old)=1 <font color="#4169E1">THEN</font>
				parlist:=COMP(new,varlist);
			<font color="#4169E1">ELSE</font>
				parlist:=COMP(<strong><font color="#228B22">var</font></strong>,parlist);
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKQUANT(op,FORMKLVAR(INV(parlist)),
			FORSUBSTVAR(qform,old,new,bbsubstvar));
	<font color="#4169E1">ELSE</font>
		RETURN bbsubstvar(phi,old,new);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORSUBSTVAR;


<font color="#B22222">(******************************************************************************
*		 M A K E   V A R I A B L E S   D I S J O I N T                *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORMKVD</font></strong>(phi:LIST; bbsubstvar:PROCF3;bblsvars:PROCF1): LIST;
<font color="#B22222">(* formula make variable names disjoint. phi is a formula, bbsubstvar is a
bb-procedure to substitute variables in bb-formulas, bblsvars is a
bb-procedure to list all variables in a bb-formula; FORMKVD returns a formula
in which all bound variables of the same sort have different names. Only the
minimal number of renamings are done to make the names different. *)</font>
	<strong><font color="#228B22">VAR</font></strong> all,used,<strong><font color="#228B22">var</font></strong>,xall,name,sort,free,bound,env: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	free:=SIL;
	bound:=SIL;
	env:=SIL;
	collectnames(phi,env,bblsvars,free,bound);
	used:=free;
	all:=CCONC(free,bound);
	xall:=SIL;
	<font color="#4169E1">WHILE</font> all&lt;&gt;SIL <font color="#4169E1">DO</font>
		ADV(all,<strong><font color="#228B22">var</font></strong>,all);
		FORPVAR(<strong><font color="#228B22">var</font></strong>,name,sort);
		xall:=COMP(LIST2(FORVTGET(name),FORVTGET(sort)),xall);
	<strong><font color="#4169E1">END</font></strong>;
	RETURN repvar(phi,SIL,SIL,used,xall,bbsubstvar);
<strong><font color="#4169E1">END</font></strong> FORMKVD;

<strong><font color="#4169E1">PROCEDURE collectnames</font></strong>(phi,env:LIST; bblsvars:PROCF1; <strong><font color="#228B22">VAR</font></strong> free, bound:LIST);
<font color="#B22222">(* collect names. phi is a formula, env is the list of all bound variables
in phi; bblsvars is a bb-procedure to list all variables in a bb-formula; 
the list of all free (bound) varaiables of phi are built in the list free 
(bound). 
It should be taken into account that one variable can occure in the list free
and in the list bound! *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, lvar, psi, name, sort: LIST;
	<strong><font color="#228B22">VAR</font></strong> varlist, <strong><font color="#228B22">var</font></strong>: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi=SIL <font color="#4169E1">THEN</font> RETURN;  <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
		RETURN ;
   	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(red,arg);
		collectnames(arg,env,bblsvars,free,bound);
		RETURN;
   	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		<font color="#4169E1">WHILE</font> red&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			collectnames(arg,env,bblsvars,free,bound);
   		<strong><font color="#4169E1">END</font></strong>;
		RETURN ;
	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">OR</font> (op=EQUIV) <font color="#4169E1">OR</font> (op=XOR) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		collectnames(arg1,env,bblsvars,free,bound);
		collectnames(arg2,env,bblsvars,free,bound);
		RETURN;
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(red,lvar,psi);
		varlist:=FORGLVAR(lvar);
		env:=CCONC(varlist,env);
		bound:=CCONC(varlist,bound);
		collectnames(psi,env,bblsvars,free,bound);
		RETURN;
	ELSIF (op=TVAR) <font color="#B22222">(* sort = BOOL *)</font> <font color="#4169E1">THEN</font>
		free:=COMP(phi,free);	<font color="#B22222">(* regard boolean vars as free vars *)</font>
		RETURN;
	<font color="#4169E1">ELSE</font>  <font color="#B22222">(* phi is an atomic formula *)</font>
		varlist:=SetComplementQ(env,bblsvars(phi));
		free:=CCONC(varlist,free);
		RETURN;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> collectnames;

<strong><font color="#4169E1">PROCEDURE repvar</font></strong>(phi,old,new:LIST; <strong><font color="#228B22">VAR</font></strong> used, denied: LIST;
	bbsubstvar: PROCF3):LIST;
<font color="#B22222">(* replace variables. phi is a formula; old is a list of variables which are
substituted with the corresponding variables in new; used is list of variables
of phi which are already used (and contains also the names of all free 
varaiables; denied is a list of lists of the form (name,sort). 
The list denied describes a list of variables which are not
allowed to be generated. 
The procedure bbsubstvar is a bb-procedure to substitute variables in 
bb-formulas. repvar returns a formula in which the variables are replaced; 
used and denied are updated. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, lvar, psi, name, newvars, newv,
		sort, result, vars, v, p, t: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi=SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
		RETURN phi;
   	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(red,arg);
		RETURN FORMKUNOP(NON,
			repvar(arg,old,new,used,denied,bbsubstvar));
   	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> red&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			result:=COMP(repvar(arg,old,new,used,denied,
					 bbsubstvar),result);
   		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKFOR(op,INV(result));
	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">OR</font> (op=EQUIV) <font color="#4169E1">OR</font> (op=XOR) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKBINOP(op,
			repvar(arg1,old,new,used,denied,bbsubstvar),
			repvar(arg2,old,new,used,denied,bbsubstvar))
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(red,lvar,psi);
		FORPLVAR(lvar,vars);
		newvars:=SIL;
		<font color="#4169E1">WHILE</font> vars&lt;&gt;SIL <font color="#4169E1">DO</font>
			ADV(vars,v,vars);
			<font color="#4169E1">IF</font> MEMBER(v,used)=1
			<font color="#4169E1">THEN</font>
				newv:=GENVAR(v,denied);
				FORPVAR(newv,name,sort);
				denied:=COMP(LIST2(FORVTGET(name),
					FORVTGET(sort)),denied); 
				old:=COMP(v,old);
				new:=COMP(newv,new);
				newvars:=COMP(newv,newvars);
			<font color="#4169E1">ELSE</font>
				used:=COMP(v,used);
				newvars:=COMP(v,newvars);
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKQUANT(op,FORMKLVAR(INV(newvars)),
			repvar(psi,old,new,used,denied,bbsubstvar));
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		<font color="#4169E1">WHILE</font> old&lt;&gt;SIL <font color="#4169E1">DO</font>
			ADV(old,p,old);
			ADV(new,t,new);
			<font color="#4169E1">IF</font> EQUAL(phi,p)=1 <font color="#4169E1">THEN</font> RETURN t; <strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
		RETURN phi;
	<font color="#4169E1">ELSE</font>
		<font color="#B22222">(* apply all substitution to the bb-formula phi *)</font>
		result:=phi;
		<font color="#4169E1">WHILE</font> old&lt;&gt;SIL <font color="#4169E1">DO</font>
			ADV(old,p,old);
			ADV(new,t,new);
			result:=bbsubstvar(result,p,t);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN result;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> repvar;

<strong><font color="#4169E1">PROCEDURE GENVAR</font></strong>(<strong><font color="#228B22">var</font></strong>,xdenied:LIST): LIST;
<font color="#B22222">(* generate variable. var is a variable; xdenied is a list of variables (all
symbols in this list must been exploded!).  The returned variable has a name
which is disjoint to the names of the variables in the list xdenied. (refere
the procedure GENSYM from the module MASSYM2.) *)</font>
	<strong><font color="#228B22">VAR</font></strong> name, sort, xname, xsort, sname,<font color="#B22222">(* x for explode, s for symbol *)</font>
		num, q, new: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	FORPVAR(<strong><font color="#228B22">var</font></strong>,name,sort);
	xname:=FORVTGET(name);
	xsort:=FORVTGET(sort);
	<font color="#B22222">(* check whether var is in denied or not *)</font>
	<font color="#4169E1">IF</font> MEMBER(LIST2(xname,xsort),xdenied)=0 <font color="#4169E1">THEN</font> RETURN <strong><font color="#228B22">var</font></strong>; <strong><font color="#4169E1">END</font></strong>;
	num:=0;
	<font color="#B22222">(* generate new varaibles until no name conflicts occurs *)</font>
	<font color="#4169E1">REPEAT</font>
		new:=SIL;      <font color="#B22222">(* FORMAT von XDENIED hat sich geaendert!!!! *)</font>
		num:=num+1;
		q:=num;
		<font color="#4169E1">REPEAT</font>
			new:=COMP(MASREM(q,10),new);
			q:=q DIV 10;
		<font color="#4169E1">UNTIL</font> q = 0;
		new:=COMP(MASORD("N"),new);
		new:=CCONC(xname,new);
	<font color="#4169E1">UNTIL</font> MEMBER(LIST2(new,xsort),xdenied)=0;
	sname:=FORVTENTER(new);
	RETURN FORMKVAR(sname,sort)
<strong><font color="#4169E1">END</font></strong> GENVAR;


<font color="#B22222">(******************************************************************************
*				 S I M P L I F Y			      *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORSMPL</font></strong>(phi: LIST; bbsmpl, bbmkneg: PROCF1): LIST;
<font color="#B22222">(* formula simplify. phi is a formula, simplifybb is a bb-procedure to
simplify a bb-formula; bbmkneg is a bb-procedure to negate a bb-formula; a
formula phi1 equivalent to phi is returned. The formula phi1 is simplified,
that means the constants VERUM and FALSUM are eliminated, and nested operators
are eliminated. (In this case the procedure takes advantage of associativity
of ET and VEL, and the idempotenz of NON.) *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, simparg1, simparg2, newop, newarg: LIST;
	<strong><font color="#228B22">VAR</font></strong> newred, vars, qform, simpqform, elem, result: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi = SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
		RETURN phi;
	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(red,arg);
		newarg:=FORSMPL(arg,bbsmpl,bbmkneg);
		RETURN formkneg(newarg,bbmkneg);
	ELSIF op=ET <font color="#4169E1">THEN</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> red &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			newarg:=FORSMPL(arg,bbsmpl,bbmkneg);
			<font color="#4169E1">IF</font> newarg=FALSUM
			<font color="#4169E1">THEN</font>
				RETURN FORMKCNST(FALSUM);
			ELSIF newarg&lt;&gt;VERUM <font color="#B22222">(* VERUM is neutral w.r.t. ET *)</font>
			<font color="#4169E1">THEN</font>
			<font color="#B22222">(* Try to simplify the formula with the law of
			* associativity *)</font>
				FORPARGS(newarg,newop,newred);
				<font color="#4169E1">IF</font> newop=ET <font color="#4169E1">THEN</font>
					<font color="#4169E1">WHILE</font> newred &lt;&gt; SIL <font color="#4169E1">DO</font>
						FORPARGS(newred,elem,newred);
						result:=COMP(elem,result);
					<strong><font color="#4169E1">END</font></strong>;

				<font color="#4169E1">ELSE</font>
					result:=COMP(newarg,result);
				<strong><font color="#4169E1">END</font></strong>;
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> result&lt;&gt;SIL 	<font color="#4169E1">THEN</font>
			RETURN FORMKFOR(ET,INV(result));
		<font color="#4169E1">ELSE</font>
			RETURN FORMKCNST(VERUM);
		<strong><font color="#4169E1">END</font></strong>
	ELSIF op=VEL <font color="#4169E1">THEN</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> red &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			newarg:=FORSMPL(arg,bbsmpl,bbmkneg);
			<font color="#4169E1">IF</font> newarg=VERUM <font color="#4169E1">THEN</font>
				RETURN VERUM;
			ELSIF newarg&lt;&gt;FALSUM <font color="#4169E1">THEN</font>
			<font color="#B22222">(* Try to simplify the formula with the law of
			* associativity *)</font>
				FORPARGS(newarg,newop,newred);
				<font color="#4169E1">IF</font> newop=VEL <font color="#4169E1">THEN</font>
					<font color="#4169E1">WHILE</font> newred &lt;&gt; SIL <font color="#4169E1">DO</font>
						FORPARGS(newred,elem,newred);
						result:=COMP(elem,result);
					<strong><font color="#4169E1">END</font></strong>;
				<font color="#4169E1">ELSE</font>
					result:=COMP(newarg,result);
				<strong><font color="#4169E1">END</font></strong>;
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> result&lt;&gt;SIL 	<font color="#4169E1">THEN</font>
			RETURN FORMKFOR(VEL,INV(result));
		<font color="#4169E1">ELSE</font>
			RETURN FORMKCNST(FALSUM);
		<strong><font color="#4169E1">END</font></strong>;
 	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">THEN</font>
		RETURN smplimpl(phi,bbsmpl,bbmkneg);
 	ELSIF op=EQUIV <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		simparg1:=FORSMPL(arg1,bbsmpl,bbmkneg);
		simparg2:=FORSMPL(arg2,bbsmpl,bbmkneg);
		<font color="#4169E1">IF</font> simparg1=VERUM <font color="#4169E1">THEN</font>
			RETURN simparg2
		ELSIF simparg2=VERUM <font color="#4169E1">THEN</font>
			RETURN simparg1
		ELSIF simparg1=FALSUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg2,bbmkneg);
		ELSIF simparg2=FALSUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg1,bbmkneg);
		<font color="#4169E1">ELSE</font>
			RETURN FORMKBINOP(EQUIV,simparg1,simparg2);
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF op=XOR <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		simparg1:=FORSMPL(arg1,bbsmpl,bbmkneg);
		simparg2:=FORSMPL(arg2,bbsmpl,bbmkneg);
		<font color="#4169E1">IF</font> simparg1=FALSUM <font color="#4169E1">THEN</font>
			RETURN simparg2
		ELSIF simparg2=FALSUM <font color="#4169E1">THEN</font>
			RETURN simparg1
		ELSIF simparg1=VERUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg2,bbmkneg);
		ELSIF simparg2=VERUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg1,bbmkneg);
		<font color="#4169E1">ELSE</font>
			RETURN FORMKBINOP(XOR,simparg1,simparg2);
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(red,vars,qform);
		simpqform:=FORSMPL(qform,bbsmpl,bbmkneg);
		<font color="#4169E1">IF</font> (simpqform=VERUM) <font color="#4169E1">OR</font> (simpqform=FALSUM) <font color="#4169E1">THEN</font>
			RETURN simpqform
		<font color="#4169E1">ELSE</font>
			RETURN FORMKQUANT(op,vars,simpqform);
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		RETURN phi;
	<font color="#4169E1">ELSE</font>
		RETURN bbsmpl(phi);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORSMPL;

<strong><font color="#4169E1">PROCEDURE smplimpl</font></strong>(phi:LIST;bbsmpl,bbmkneg:PROCF1):LIST;
<font color="#B22222">(* simplify implication. phi is either an implication or a replication; bbsmpl
is bb-procedure to simplify a bb-formula; bbmkneg is a bb-procedure to negate
a bb-formula; a simplification of phi is returned. (see the description of
FORSMPL). *)</font>
	<strong><font color="#228B22">VAR</font></strong> sprem, sconcl,prem,concl,op,newarg,newop,arg1,arg2: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	FORPBINOP(phi,op,arg1,arg2);
	<font color="#4169E1">IF</font> op=IMP <font color="#4169E1">THEN</font>
		prem:=arg1;
		concl:=arg2;
	<font color="#4169E1">ELSE</font>
		prem:=arg2;
		concl:=arg1;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> prem=FALSUM <font color="#4169E1">THEN</font>
		RETURN FORMKCNST(VERUM);
	ELSIF prem=VERUM <font color="#4169E1">THEN</font>
		RETURN FORSMPL(concl,bbsmpl,bbmkneg);
	ELSIF concl=FALSUM <font color="#4169E1">THEN</font>
		RETURN FORSMPL(FORMKUNOP(NON,prem),bbsmpl,bbmkneg);
	ELSIF concl=VERUM <font color="#4169E1">THEN</font>
		RETURN concl;
	<font color="#4169E1">ELSE</font>
		sprem:=FORSMPL(prem,bbsmpl,bbmkneg);
		sconcl:=FORSMPL(concl,bbsmpl,bbmkneg);
		<font color="#4169E1">IF</font> sprem=FALSUM <font color="#4169E1">THEN</font>
			RETURN FORMKCNST(VERUM);
		ELSIF sprem=VERUM <font color="#4169E1">THEN</font>
			RETURN sconcl;
		ELSIF sconcl=FALSUM <font color="#4169E1">THEN</font>
			FORPFOR(sprem,newop,newarg);
			<font color="#4169E1">IF</font> newop=NON <font color="#4169E1">THEN</font>
				RETURN newarg;
			<font color="#4169E1">ELSE</font>
				RETURN FORMKUNOP(NON,sprem)
			<strong><font color="#4169E1">END</font></strong>;
		ELSIF sconcl=VERUM <font color="#4169E1">THEN</font>
			RETURN sconcl;
		<font color="#4169E1">ELSE</font>
			<font color="#4169E1">IF</font> EQUAL(sprem,sconcl)=1 <font color="#4169E1">THEN</font> RETURN VERUM; <strong><font color="#4169E1">END</font></strong>;
			<font color="#4169E1">IF</font> op=IMP <font color="#4169E1">THEN</font>
				RETURN FORMKBINOP(IMP,sprem,sconcl);
			<font color="#4169E1">ELSE</font>
				RETURN FORMKBINOP(REP,sconcl,sprem);
			<strong><font color="#4169E1">END</font></strong>;
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> smplimpl;


<strong><font color="#4169E1">PROCEDURE FORSIMPLIFY</font></strong>(phi: LIST; smart: PROCF1; bbsmpl, bbmkneg: PROCF1):LIST;
<font color="#B22222">(* formula simplify. phi is a formula, smart is a function
to do smart simplification on a list of atomic formulas. 
simplifybb is a bb-procedure to
simplify a bb-formula; bbmkneg is a bb-procedure to negate a bb-formula.
A simplification of phi is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, simparg1, simparg2, newop, newarg: LIST;
	<strong><font color="#228B22">VAR</font></strong> newred, vars, qform, simpqform, elem, result: LIST;
	<strong><font color="#228B22">VAR</font></strong> aflist, cflist,psi: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi = SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
		RETURN phi;
	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(red,arg);
		newarg:=FORSIMPLIFY(arg,smart,bbsmpl,bbmkneg);
		RETURN formkneg(newarg,bbmkneg);
	ELSIF (op=ET) <font color="#4169E1">OR</font> (op=VEL) <font color="#4169E1">THEN</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> red&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			arg:=FORSIMPLIFY(arg,smart,bbsmpl,bbmkneg);
			result:=SimplifyComp(arg,op,result);
			<font color="#4169E1">IF</font> (result=VERUM) <font color="#4169E1">OR</font> (result=FALSUM) <font color="#4169E1">THEN</font>
				RETURN result;
			<strong><font color="#4169E1">END</font></strong>; 
		<strong><font color="#4169E1">END</font></strong>;
		result:=DoSmartSimplify(result,op,smart);
		<font color="#4169E1">IF</font> (result=VERUM) <font color="#4169E1">OR</font> (result=FALSUM) <font color="#4169E1">THEN</font>
			RETURN result;
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> (result=VERUM) <font color="#4169E1">OR</font> (result=FALSUM) <font color="#4169E1">THEN</font>
			RETURN FORMKCNST(result);
		ELSIF result=SIL <font color="#4169E1">THEN</font>
			<font color="#4169E1">IF</font> op=ET <font color="#4169E1">THEN</font> 
				RETURN FORMKCNST(VERUM); 
			<font color="#4169E1">ELSE</font> <font color="#B22222">(* IF op=VEL *)</font>
				RETURN FORMKCNST(FALSUM); 
			<strong><font color="#4169E1">END</font></strong>;
		ELSIF RED(result)=SIL <font color="#4169E1">THEN</font> 	<font color="#B22222">(* only one argument *)</font>
			RETURN FIRST(result)
		<font color="#4169E1">ELSE</font>
			RETURN FORMKFOR(op,result);
		<strong><font color="#4169E1">END</font></strong>;
 	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">THEN</font>
		RETURN smplimpl(phi,bbsmpl,bbmkneg);
 	ELSIF op=EQUIV <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		simparg1:=FORSIMPLIFY(arg1,smart,bbsmpl,bbmkneg);
		simparg2:=FORSIMPLIFY(arg2,smart,bbsmpl,bbmkneg);
		<font color="#4169E1">IF</font> simparg1=VERUM <font color="#4169E1">THEN</font>
			RETURN simparg2
		ELSIF simparg2=VERUM <font color="#4169E1">THEN</font>
			RETURN simparg1
		ELSIF simparg1=FALSUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg2,bbmkneg);
		ELSIF simparg2=FALSUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg1,bbmkneg);
		<font color="#4169E1">ELSE</font>
			<font color="#4169E1">IF</font> EQUAL(simparg1,simparg2)=1 <font color="#4169E1">THEN</font> RETURN VERUM; <strong><font color="#4169E1">END</font></strong>; 
			RETURN FORMKBINOP(EQUIV,simparg1,simparg2);
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF op=XOR <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		simparg1:=FORSIMPLIFY(arg1,smart,bbsmpl,bbmkneg);
		simparg2:=FORSIMPLIFY(arg2,smart,bbsmpl,bbmkneg);
		<font color="#4169E1">IF</font> simparg1=FALSUM <font color="#4169E1">THEN</font>
			RETURN simparg2
		ELSIF simparg2=FALSUM <font color="#4169E1">THEN</font>
			RETURN simparg1
		ELSIF simparg1=VERUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg2,bbmkneg);
		ELSIF simparg2=VERUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg1,bbmkneg);
		<font color="#4169E1">ELSE</font>
			<font color="#4169E1">IF</font> EQUAL(simparg1,simparg2)=1 <font color="#4169E1">THEN</font> RETURN FALSUM; <strong><font color="#4169E1">END</font></strong>; 
			RETURN FORMKBINOP(XOR,simparg1,simparg2);
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(red,vars,qform);
		simpqform:=FORSIMPLIFY(qform,smart,bbsmpl,bbmkneg);
		<font color="#4169E1">IF</font> (simpqform=VERUM) <font color="#4169E1">OR</font> (simpqform=FALSUM) <font color="#4169E1">THEN</font>
			RETURN simpqform
		<font color="#4169E1">ELSE</font>
			RETURN FORMKQUANT(op,vars,simpqform);
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		RETURN phi;
	<font color="#4169E1">ELSE</font>
		RETURN bbsmpl(phi);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORSIMPLIFY;

<strong><font color="#4169E1">PROCEDURE SimplifyComp</font></strong>(phi,op,L:LIST):LIST;
<font color="#B22222">(* simplify composition. phi is a formula. 
op is either ET or VEL. L is a list of formulas. 
A list of formulas is returned. If phi is already a element of L then L is 
returned. If the operator symbol of phi is equal to op then all arguments 
of this operator of phi are inserted in L, otherwise phi is inserted in L.
L is modified, the result is returned. If the result of SimplifyComp
is VERUM or FALUSM then VERUM or FALSUM are returned, not the LIST of 
one of these symbols. 
*)</font>
	<strong><font color="#228B22">VAR</font></strong> args,psi: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> ((op=ET) <font color="#4169E1">AND</font> (phi=FALSUM) ) <font color="#4169E1">OR</font> 
	   ((op=VEL) <font color="#4169E1">AND</font> (phi=VERUM) ) 
	<font color="#4169E1">THEN</font>
		RETURN phi;
	ELSIF (phi=VERUM) <font color="#4169E1">OR</font> (phi=FALSUM) <font color="#4169E1">THEN</font>
		RETURN L;
	<strong><font color="#4169E1">END</font></strong>; 
	<font color="#4169E1">IF</font> FORGOP(phi)=op <font color="#4169E1">THEN</font>
		args:=FORGARGS(phi);
		<font color="#4169E1">WHILE</font> args&lt;&gt;SIL <font color="#4169E1">DO</font>
			ADV(args,psi,args);
			L:=SetAddQ(psi,L);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN L;
	<font color="#4169E1">ELSE</font>
		RETURN SetAddQ(phi,L);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> SimplifyComp;

<strong><font color="#4169E1">PROCEDURE DoSmartSimplify</font></strong>(L,op:LIST;smart:PROCF1):LIST;
<font color="#B22222">(* do smart simplification. L is a list of formulas. op is a the operator
ET or VEL. smart is a procedure for smart simplification. The
simplified formula op(L) is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> aflist, cflist, psi, result,smartresult: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	aflist:=SIL; 
	result:=SIL;
	<font color="#4169E1">WHILE</font> L&lt;&gt;SIL <font color="#4169E1">DO</font>
		ADV(L,psi,L);
		<font color="#4169E1">IF</font> FORISBBFOR(psi)
		<font color="#4169E1">THEN</font>
			aflist:=COMP(psi,aflist);
		<font color="#4169E1">ELSE</font>
			result:=COMP(psi,result);
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> aflist&lt;&gt;SIL <font color="#4169E1">THEN</font>
		smartresult:=smart(FORMKFOR(op,aflist));
		<font color="#4169E1">IF</font> <font color="#4169E1">NOT</font> FORISATOM(smartresult) <font color="#4169E1">THEN</font> 
			smartresult:=FORMKFOR(FORGOP(smartresult),
				INV(FORGARGS(smartresult)));
		<strong><font color="#4169E1">END</font></strong>;
		RETURN SimplifyComp(smartresult,op,result);
	<font color="#4169E1">ELSE</font>
		RETURN result;
	<strong><font color="#4169E1">END</font></strong>; 
<strong><font color="#4169E1">END</font></strong> DoSmartSimplify;

<strong><font color="#4169E1">PROCEDURE FORSIMPLIFYP</font></strong>(phi,maxlevel: LIST;
	smart: PROCF1; bbsmpl, bbmkneg: PROCF1):LIST;
<font color="#B22222">(* formula simplify prune. phi is a formula, level, maxlevel are atoms, 
smart is a function to do smart simplification on a list of atomic formulas. 
simplifybb is a bb-procedure to
simplify a bb-formula; bbmkneg is a bb-procedure to negate a bb-formula.
maxlevel defines the number of levels that are simplified, 1 means only 
the top-level, zero means simplify the hole tree.
A simplification of phi is returned. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	RETURN simplifyp(phi,1,maxlevel,smart,bbsmpl,bbmkneg);
<strong><font color="#4169E1">END</font></strong> FORSIMPLIFYP;

<strong><font color="#4169E1">PROCEDURE simplifyp</font></strong>(phi,level,maxlevel: LIST;
	smart: PROCF1; bbsmpl, bbmkneg: PROCF1):LIST;
<font color="#B22222">(* formula simplify prune. phi is a formula, level, maxlevel are atoms, 
smart is a function to do smart simplification on a list of atomic formulas. 
simplifybb is a bb-procedure to
simplify a bb-formula; bbmkneg is a bb-procedure to negate a bb-formula.
maxlevel defines the number of levels that are simplified, 1 means only 
the top-level, zero means simplify the hole tree. level is the current level.
A simplification of phi is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, simparg1, simparg2, newop, newarg: LIST;
	<strong><font color="#228B22">VAR</font></strong> newred, vars, qform, simpqform, elem, result: LIST;
	<strong><font color="#228B22">VAR</font></strong> aflist, cflist,psi: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi = SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> level=maxlevel+1 <font color="#4169E1">THEN</font> RETURN phi; <strong><font color="#4169E1">END</font></strong>; 

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
		RETURN phi;
	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(red,arg);
		newarg:=simplifyp(arg,level+1,maxlevel,smart,bbsmpl,bbmkneg);
		RETURN formkneg(newarg,bbmkneg);
	ELSIF (op=ET) <font color="#4169E1">OR</font> (op=VEL) <font color="#4169E1">THEN</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> red&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			arg:=simplifyp(arg,level+1,maxlevel,smart,bbsmpl,bbmkneg);
			result:=SimplifyComp(arg,op,result);
			<font color="#4169E1">IF</font> (result=VERUM) <font color="#4169E1">OR</font> (result=FALSUM) <font color="#4169E1">THEN</font>
				RETURN result;
			<strong><font color="#4169E1">END</font></strong>; 
		<strong><font color="#4169E1">END</font></strong>;
		result:=DoSmartSimplify(result,op,smart);
		<font color="#4169E1">IF</font> (result=VERUM) <font color="#4169E1">OR</font> (result=FALSUM) <font color="#4169E1">THEN</font>
			RETURN result;
		<strong><font color="#4169E1">END</font></strong>;
		<font color="#4169E1">IF</font> (result=VERUM) <font color="#4169E1">OR</font> (result=FALSUM) <font color="#4169E1">THEN</font>
			RETURN FORMKCNST(result);
		ELSIF result=SIL <font color="#4169E1">THEN</font>
			<font color="#4169E1">IF</font> op=ET <font color="#4169E1">THEN</font> 
				RETURN FORMKCNST(VERUM); 
			<font color="#4169E1">ELSE</font> <font color="#B22222">(* IF op=VEL *)</font>
				RETURN FORMKCNST(FALSUM); 
			<strong><font color="#4169E1">END</font></strong>;
		ELSIF RED(result)=SIL <font color="#4169E1">THEN</font> 	<font color="#B22222">(* only one argument *)</font>
			RETURN FIRST(result)
		<font color="#4169E1">ELSE</font>
			RETURN FORMKFOR(op,result);
		<strong><font color="#4169E1">END</font></strong>;
 	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">THEN</font>
		RETURN smplimpl(phi,bbsmpl,bbmkneg);
 	ELSIF op=EQUIV <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		simparg1:=simplifyp(arg1,level+1,maxlevel,smart,bbsmpl,bbmkneg);
		simparg2:=simplifyp(arg2,level+1,maxlevel,smart,bbsmpl,bbmkneg);
		<font color="#4169E1">IF</font> simparg1=VERUM <font color="#4169E1">THEN</font>
			RETURN simparg2
		ELSIF simparg2=VERUM <font color="#4169E1">THEN</font>
			RETURN simparg1
		ELSIF simparg1=FALSUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg2,bbmkneg);
		ELSIF simparg2=FALSUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg1,bbmkneg);
		<font color="#4169E1">ELSE</font>
			<font color="#4169E1">IF</font> EQUAL(simparg1,simparg2)=1 <font color="#4169E1">THEN</font> RETURN VERUM; <strong><font color="#4169E1">END</font></strong>; 
			RETURN FORMKBINOP(EQUIV,simparg1,simparg2);
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF op=XOR <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		simparg1:=simplifyp(arg1,level+1,maxlevel,smart,bbsmpl,bbmkneg);
		simparg2:=simplifyp(arg2,level+1,maxlevel,smart,bbsmpl,bbmkneg);
		<font color="#4169E1">IF</font> simparg1=FALSUM <font color="#4169E1">THEN</font>
			RETURN simparg2
		ELSIF simparg2=FALSUM <font color="#4169E1">THEN</font>
			RETURN simparg1
		ELSIF simparg1=VERUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg2,bbmkneg);
		ELSIF simparg2=VERUM <font color="#4169E1">THEN</font>
			RETURN formkneg(simparg1,bbmkneg);
		<font color="#4169E1">ELSE</font>
			<font color="#4169E1">IF</font> EQUAL(simparg1,simparg2)=1 <font color="#4169E1">THEN</font> RETURN FALSUM; <strong><font color="#4169E1">END</font></strong>; 
			RETURN FORMKBINOP(XOR,simparg1,simparg2);
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(red,vars,qform);
		simpqform:=simplifyp(qform,level+1,maxlevel,smart,bbsmpl,bbmkneg);
		<font color="#4169E1">IF</font> (simpqform=VERUM) <font color="#4169E1">OR</font> (simpqform=FALSUM) <font color="#4169E1">THEN</font>
			RETURN simpqform
		<font color="#4169E1">ELSE</font>
			RETURN FORMKQUANT(op,vars,simpqform);
		<strong><font color="#4169E1">END</font></strong>;
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		RETURN phi;
	<font color="#4169E1">ELSE</font>
		RETURN bbsmpl(phi);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> simplifyp;

<font color="#B22222">(******************************************************************************
*	 P R E P A R E   Q U A N T I F I E R   E L I M I N A T I O N	      *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORPREPQE</font></strong>(phi: LIST; bbmkneg: PROCF1):LIST;
<font color="#B22222">(* formula prepare quantifier elimination. phi is a prenex formula; bbmkneg is
a bb-procedure to negate a bb-formula; a formula psi equivalent to phi is
returned. psi is built according to the following rules: If the innermost
block of quantifiers is an exist-quantifier, then matrix(phi) is transformed
in CNF and the innermost block of quantifiers is moved inside the conjunction.
If the innermost quantifier is a forall-quantifier, then matrix(phi) is
transformed in DNF and the innermost block of quantifiers is moved inside the
disjunction.*)</font>
	<strong><font color="#228B22">VAR</font></strong> op, quant, red, parg, phi1, lastop, qblocks, vblocks, psi,
		arg, psi1, lvar: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi=SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op&lt;&gt;EXIST) <font color="#4169E1">AND</font> (op&lt;&gt;FORALL) <font color="#4169E1">THEN</font>
		RETURN phi;
	<strong><font color="#4169E1">END</font></strong>;
	qblocks:=SIL;
	vblocks:=SIL;
	<font color="#4169E1">WHILE</font> (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">DO</font>
		FORPQUANTA(red,lvar,phi1);
		qblocks:=COMP(op,qblocks);
		vblocks:=COMP(lvar,vblocks);
		FORPFOR(phi1,op,red);
	<strong><font color="#4169E1">END</font></strong>;
	<font color="#B22222">(* now: qblocks is a list of all blocks of quantifiers of phi, but
	the sequence is reveresed. *)</font>
	ADV(qblocks,quant,qblocks);
	ADV(vblocks,lvar,vblocks);
	<font color="#B22222">(* now: quant is the innermost quantifier *)</font>
	<font color="#4169E1">IF</font> quant=EXIST <font color="#4169E1">THEN</font>
		psi1:=FORMKDNF(phi1,bbmkneg);
	<font color="#4169E1">ELSE</font> 		<font color="#B22222">(* op=FORALL *)</font>
		psi1:=FORMKCNF(phi1,bbmkneg);
	<strong><font color="#4169E1">END</font></strong>;
	FORPFOR(psi1,op,red);
	psi:=SIL;
	<font color="#4169E1">WHILE</font> red&lt;&gt;SIL <font color="#4169E1">DO</font>
		FORPARGS(red,arg,red);
		parg:=FORMKQUANT(quant,lvar,arg);	<font color="#B22222">(* simplification? *)</font>
		psi:=COMP(parg,psi);
	<strong><font color="#4169E1">END</font></strong>;
	psi:=FORMKFOR(op,psi);
	<font color="#4169E1">WHILE</font> qblocks&lt;&gt;SIL <font color="#4169E1">DO</font>
		ADV(qblocks,quant,qblocks);
		ADV(vblocks,lvar,vblocks);
		psi:=FORMKQUANT(quant,lvar,psi);
	<strong><font color="#4169E1">END</font></strong>;
	RETURN psi;
<strong><font color="#4169E1">END</font></strong> FORPREPQE;


<font color="#B22222">(******************************************************************************
*  E L I M I N A T E   E X T E N D E D   O P E R A T I O N   S Y M B O L S    *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORELIMXOPS</font></strong>(phi :LIST; pref: LIST): LIST;
<font color="#B22222">(* formula eliminate extended operation symbols. phi is formula, pref is a
symbol of the set \{VEL, ET, NON\}; FORELIMXOPS returns a formula phi1
equivalent to phi. If pref is NON then this function does nothing. Otherwise
this function replaces all subterms of phi with the operators IMP, REP, EQUIV
or XOR with terms with the operators VEL, ET and NON. There are two different
substitutions for EQUIV and XOR. If pref=ET (pref=VEL) then the outermost
operator of the replacement terms for EQUIV, XOR is ET (VEL). *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, arglist, arg, arg1, arg2, prem, concl, lvar, qform: LIST;
	<strong><font color="#228B22">VAR</font></strong> elimarg1, elimarg2, res: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi = SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> pref = NON <font color="#4169E1">THEN</font> RETURN phi; <strong><font color="#4169E1">END</font></strong>;

	<font color="#4169E1">IF</font> (pref &lt;&gt; VEL) <font color="#4169E1">AND</font> (pref &lt;&gt; ET) <font color="#4169E1">THEN</font>
		ERROR(severe,"FORMELIMXOPS: wrong preferenz given (assume NON)");
		RETURN phi;
	<strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,arglist);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
		RETURN phi;
	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(arglist,arg);
		RETURN FORMKUNOP(NON,FORELIMXOPS(arg,pref));
	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		res:=SIL;
		<font color="#4169E1">WHILE</font> arglist &lt;&gt; SIL <font color="#4169E1">DO</font>
			FORPARGS(arglist,arg,arglist);
			res:=COMP(FORELIMXOPS(arg,pref),res);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKFOR(op,INV(res));
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(arglist,lvar,qform);
		RETURN FORMKQUANT(op,lvar,FORELIMXOPS(qform,pref));
	ELSIF op=IMP <font color="#4169E1">THEN</font>
		FORPBINOPA(arglist,prem,concl);
		RETURN FORMKBINOP(VEL,FORMKUNOP(NON,FORELIMXOPS(prem,pref)),
			FORELIMXOPS(concl,pref));
	ELSIF op=REP <font color="#4169E1">THEN</font>
		FORPBINOPA(arglist,concl,prem);
		RETURN FORMKBINOP(VEL,FORELIMXOPS(concl,pref),
			FORMKUNOP(NON,FORELIMXOPS(prem,pref)));
	ELSIF (op=EQUIV) <font color="#4169E1">AND</font> (pref=VEL) <font color="#4169E1">THEN</font>
		FORPBINOPA(arglist,arg1,arg2);
		elimarg1:=FORELIMXOPS(arg1,pref);
		elimarg2:=FORELIMXOPS(arg2,pref);
		RETURN FORMKBINOP(VEL,
				FORMKBINOP(ET,elimarg1,elimarg2),
				FORMKBINOP(ET,
					FORMKUNOP(NON,elimarg1),
					FORMKUNOP(NON,elimarg2)));
	ELSIF (op=EQUIV) <font color="#4169E1">AND</font> (pref=ET) <font color="#4169E1">THEN</font>
		FORPBINOPA(arglist,arg1,arg2);
		elimarg1:=FORELIMXOPS(arg1,pref);
		elimarg2:=FORELIMXOPS(arg2,pref);
		RETURN FORMKBINOP(ET,
			FORMKBINOP(VEL,FORMKUNOP(NON,elimarg1),elimarg2),
			FORMKBINOP(VEL,elimarg1,FORMKUNOP(NON,elimarg2)));
	ELSIF (op=XOR) <font color="#4169E1">AND</font> (pref=VEL) <font color="#4169E1">THEN</font>
		FORPBINOPA(arglist,arg1,arg2);
		elimarg1:=FORELIMXOPS(arg1,pref);
		elimarg2:=FORELIMXOPS(arg2,pref);
		RETURN FORMKBINOP(VEL,
			FORMKBINOP(ET,FORMKUNOP(NON,elimarg1),elimarg2),
			FORMKBINOP(ET,elimarg1,FORMKUNOP(NON,elimarg2)));
	ELSIF (op=XOR) <font color="#4169E1">AND</font> (pref=ET) <font color="#4169E1">THEN</font>
		FORPBINOPA(arglist,arg1,arg2);
		elimarg1:=FORELIMXOPS(arg1,pref);
		elimarg2:=FORELIMXOPS(arg2,pref);
		RETURN FORMKBINOP(ET,
			FORMKBINOP(VEL,elimarg1,elimarg2),
			FORMKBINOP(VEL,
				FORMKUNOP(NON,elimarg1),
				FORMKUNOP(NON,elimarg2)));
	<font color="#4169E1">ELSE</font>
		RETURN phi;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORELIMXOPS;


<font color="#B22222">(******************************************************************************
*                              F O R R E P A F S                              *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORREPAFS</font></strong>(phi,rep:LIST):LIST;
<font color="#B22222">(* formula replace atomic formulas. phi is a formula. rep is a 
assoc list of the form (old1,new1,old2,new2,...), where old1,... and
new1,.. are atomic formulas. Each occurence of oldi in phi is 
replaced with newi. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op,arg1,arg2,args,argi,found,result: LIST;
	<strong><font color="#228B22">VAR</font></strong> quantifier, bvars: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	op:=FORGOP(phi);
	<font color="#4169E1">IF</font> (op=NON) <font color="#4169E1">THEN</font> 
		RETURN FORMKUNOP(NON,FORREPAFS(FIRST(FORGARGS(phi)),rep));
	ELSIF (op=ET) <font color="#4169E1">OR</font> (op=VEL) <font color="#4169E1">THEN</font>
		args:=FORGARGS(phi);
		result:=SIL;
		<font color="#4169E1">WHILE</font> args&lt;&gt;SIL <font color="#4169E1">DO</font> 
			ADV(args,argi,args);
			result:=COMP(FORREPAFS(argi,rep),result);
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKFOR(op,INV(result));
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANT(phi,quantifier,bvars,arg1);
		RETURN FORMKQUANT(quantifier,bvars,FORREPAFS(arg1,rep));
	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">OR</font> (op=EQUIV) <font color="#4169E1">OR</font> (op=XOR) <font color="#4169E1">THEN</font>
		FORPBINOP(phi,op,arg1,arg2);
		RETURN FORMKBINOP(op,FORREPAFS(arg1,rep),FORREPAFS(arg2,rep));
	<font color="#4169E1">ELSE</font> <font color="#B22222">(* phi is a atomic formula *)</font>
		found:=ASSOCQ(phi,rep);
		<font color="#4169E1">IF</font> found=SIL <font color="#4169E1">THEN</font> 
			RETURN phi;
		<font color="#4169E1">ELSE</font>
			RETURN FIRST(found);
		<strong><font color="#4169E1">END</font></strong>;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORREPAFS;

<font color="#B22222">(******************************************************************************
*			  A P P L Y   T O   A T O M			      *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORAPPLYAT</font></strong>(phi:LIST; dosomething:PROCF1): LIST;
<font color="#B22222">(* formula apply to atomic formular. phi is a formula; a formular in which all
atomic formulas psi are substituted with dosomething(psi) is returned.  *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, lvar, psi, name, sort, result: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi=SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
  		RETURN dosomething(phi)
   	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(red,arg);
		RETURN FORMKUNOP(NON,FORAPPLYAT(arg,dosomething));
   	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> red&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			result:=COMP(FORAPPLYAT(arg,dosomething),result);
   		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKFOR(op,INV(result));
	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">OR</font> (op=EQUIV) <font color="#4169E1">OR</font> (op=XOR) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKBINOP(op,FORAPPLYAT(arg1,dosomething),
			FORAPPLYAT(arg2,dosomething))
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(red,lvar,psi);
		RETURN FORMKQUANT(op,lvar,FORAPPLYAT(psi,dosomething));
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		RETURN dosomething(phi);
	<font color="#4169E1">ELSE</font>
		RETURN dosomething(phi);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORAPPLYAT;

<strong><font color="#4169E1">PROCEDURE FORAPPLYATF2</font></strong>(phi,param1:LIST; dosomething:PROCF2): LIST;
<font color="#B22222">(* formula apply to atomic formula f2. 
phi is a formula; param1 is an arbitrary list object,
a formula in which all atomic formulas psi are substituted with 
dosomething(psi,param1) is returned.  *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, lvar, psi, name, sort, result: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi=SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;
	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
  		RETURN dosomething(phi,param1)
   	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(red,arg);
		RETURN FORMKUNOP(NON,FORAPPLYATF2(arg,param1,dosomething));
   	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		result:=SIL;
		<font color="#4169E1">WHILE</font> red&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			result:=COMP(FORAPPLYATF2(arg,param1,dosomething),
				result);
   		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORMKFOR(op,INV(result));
	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">OR</font> (op=EQUIV) <font color="#4169E1">OR</font> (op=XOR) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORMKBINOP(op,FORAPPLYATF2(arg1,param1,dosomething),
			FORAPPLYATF2(arg2,param1,dosomething))
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(red,lvar,psi);
		RETURN FORMKQUANT(op,lvar,
			FORAPPLYATF2(psi,param1,dosomething));
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		RETURN dosomething(phi,param1);
	<font color="#4169E1">ELSE</font>
		RETURN dosomething(phi,param1);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORAPPLYATF2;

<font color="#B22222">(******************************************************************************
*                  C O U N T   A T O M I C   F O R M U L A S                  *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORCOUNTAF</font></strong>(phi:LIST): LIST;
<font color="#B22222">(* formula count atomic formulas. phi is a formula; 
The number of the atomic formulas in the formula phi is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, lvar, psi, number: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi=SIL <font color="#4169E1">THEN</font> RETURN SIL; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
  		RETURN 1;
   	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(red,arg);
		RETURN FORCOUNTAF(arg);
   	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		number:=0;
		<font color="#4169E1">WHILE</font> red&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			number:=number+FORCOUNTAF(arg);
   		<strong><font color="#4169E1">END</font></strong>;
		RETURN number;
	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">OR</font> (op=EQUIV) <font color="#4169E1">OR</font> (op=XOR) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORCOUNTAF(arg1)+FORCOUNTAF(arg2)
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(red,lvar,psi);
		RETURN FORCOUNTAF(psi);
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		RETURN 1;
	<font color="#4169E1">ELSE</font>
		RETURN 1;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORCOUNTAF;


<font color="#B22222">(******************************************************************************
*	      C O N T A I N S   B O U N D E D   V A R I A B L E		      *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORCONTBDVAR</font></strong>(phi:LIST; svar: LIST): BOOLEAN;
<font color="#B22222">(* formula contain bound variable. phi is a formula; svar is a variable;
FORCONTBDVAR returns true, if and only if phi contains svar as a bound
variable. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, lvar, psi, varlist, <strong><font color="#228B22">var</font></strong>: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi=SIL <font color="#4169E1">THEN</font> RETURN FALSE; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
  		RETURN FALSE;
   	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(phi,arg);
		RETURN FORCONTBDVAR(arg,svar);
   	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		<font color="#4169E1">WHILE</font> red&lt;&gt;SIL  <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			<font color="#4169E1">IF</font> FORCONTBDVAR(arg,svar) <font color="#4169E1">THEN</font> RETURN TRUE; <strong><font color="#4169E1">END</font></strong>;
   		<strong><font color="#4169E1">END</font></strong>;
		RETURN FALSE; 
	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">OR</font> (op=EQUIV) <font color="#4169E1">OR</font> (op=XOR) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORCONTBDVAR(arg1,svar) <font color="#4169E1">OR</font> FORCONTBDVAR(arg2,svar)
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		FORPQUANTA(red,lvar,psi);
		FORPLVAR(lvar,varlist);
		<font color="#4169E1">WHILE</font> varlist&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(varlist,<strong><font color="#228B22">var</font></strong>,varlist);
			<font color="#4169E1">IF</font>  EQUAL(svar,<strong><font color="#228B22">var</font></strong>)=1 <font color="#4169E1">THEN</font> RETURN TRUE; <strong><font color="#4169E1">END</font></strong>; 
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORCONTBDVAR(psi,svar);
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		RETURN FALSE;
	<font color="#4169E1">ELSE</font>
		RETURN FALSE;
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORCONTBDVAR;


<font color="#B22222">(******************************************************************************
*		      C O N T A I N S   V A R I A B L E			      *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE FORCONTVAR</font></strong>(phi:LIST; svar: LIST; bbcontvar: PROCFB2): BOOLEAN;
<font color="#B22222">(* formula contain variable. phi is a formula; var is a variable; bbcontvar is
a procedure, which tests whether a bb-formula contains a variable or not;
FORCONTVAR returns true, if and only if phi contains var as a free variable.
*)</font>
	<strong><font color="#228B22">VAR</font></strong> op, red, arg, arg1, arg2, lvar, psi, varlist, <strong><font color="#228B22">var</font></strong>: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> phi=SIL <font color="#4169E1">THEN</font> RETURN FALSE; <strong><font color="#4169E1">END</font></strong>;

	FORPFOR(phi,op,red);
	<font color="#4169E1">IF</font> (op=VERUM) <font color="#4169E1">OR</font> (op=FALSUM) <font color="#4169E1">THEN</font>
  		RETURN FALSE;
   	ELSIF op=NON <font color="#4169E1">THEN</font>
		FORPUNOPA(phi,arg);
		RETURN FORCONTVAR(arg,svar,bbcontvar);
   	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">THEN</font>
		<font color="#4169E1">WHILE</font> red&lt;&gt;SIL <font color="#4169E1">DO</font>
			FORPARGS(red,arg,red);
			<font color="#4169E1">IF</font> FORCONTVAR(arg,svar,bbcontvar) <font color="#4169E1">THEN</font> RETURN TRUE <strong><font color="#4169E1">END</font></strong>;
   		<strong><font color="#4169E1">END</font></strong>;
		RETURN FALSE;
	ELSIF (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">OR</font> (op=EQUIV) <font color="#4169E1">OR</font> (op=XOR) <font color="#4169E1">THEN</font>
		FORPBINOPA(red,arg1,arg2);
		RETURN FORCONTVAR(arg1,svar,bbcontvar) <font color="#4169E1">OR</font>
			FORCONTVAR(arg2,svar,bbcontvar)
	ELSIF (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL)	<font color="#4169E1">THEN</font>
		FORPQUANTA(red,lvar,psi);
		FORPLVAR(lvar,varlist);
		<font color="#4169E1">WHILE</font> varlist&lt;&gt;SIL  <font color="#4169E1">DO</font>
			FORPARGS(varlist,<strong><font color="#228B22">var</font></strong>,varlist);
			<font color="#4169E1">IF</font> EQUAL(svar,<strong><font color="#228B22">var</font></strong>)=1 <font color="#4169E1">THEN</font> RETURN FALSE; <strong><font color="#4169E1">END</font></strong>; 
		<strong><font color="#4169E1">END</font></strong>;
		RETURN FORCONTVAR(psi,svar,bbcontvar);
	ELSIF op=TVAR <font color="#4169E1">THEN</font>
		RETURN EQUAL(svar,<strong><font color="#228B22">var</font></strong>)=1;
	<font color="#4169E1">ELSE</font>
		RETURN bbcontvar(phi,<strong><font color="#228B22">var</font></strong>);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> FORCONTVAR;


<font color="#B22222">(******************************************************************************
*	    G E N E R A L   A U X I L I A R Y   P R O C E D U R E S           *
******************************************************************************)</font>

<strong><font color="#4169E1">PROCEDURE notsymbol</font></strong>(sym :LIST): LIST;
<font color="#B22222">(* not symbol. sym is a symbol of the set {VERUM, FALSUM, VEL, ET, IMP, REP,
EQUIV, XOR, FORALL, EXIST}; returns the (defined) negation of this symbol. *)</font>
<strong><font color="#4169E1">BEGIN</font></strong>
	<font color="#4169E1">IF</font> sym=VERUM	<font color="#4169E1">THEN</font> RETURN FALSUM;	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> sym=FALSUM	<font color="#4169E1">THEN</font> RETURN VERUM;	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> sym=VEL	<font color="#4169E1">THEN</font> RETURN ET;		<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> sym=ET	<font color="#4169E1">THEN</font> RETURN VEL;	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> sym=EXIST	<font color="#4169E1">THEN</font> RETURN FORALL;	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> sym=FORALL	<font color="#4169E1">THEN</font> RETURN EXIST;	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> sym=IMP	<font color="#4169E1">THEN</font> RETURN REP;	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> sym=REP	<font color="#4169E1">THEN</font> RETURN IMP;	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> sym=EQUIV	<font color="#4169E1">THEN</font> RETURN XOR;	<strong><font color="#4169E1">END</font></strong>;
	<font color="#4169E1">IF</font> sym=XOR	<font color="#4169E1">THEN</font> RETURN EQUIV;	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> notsymbol;


<strong><font color="#4169E1">PROCEDURE formkneg</font></strong>(phi:LIST; bbmkneg: PROCF1): LIST;
<font color="#B22222">(* formula make negation. phi is a formula, bbmkneg a procedure to negate a
bb-formula, a simplification of a negation of phi is returned. *)</font>
	<strong><font color="#228B22">VAR</font></strong> op, arg, left, right: LIST;
<strong><font color="#4169E1">BEGIN</font></strong>
	FORPFOR(phi,op,arg);
	<font color="#4169E1">IF</font> op=VERUM <font color="#4169E1">THEN</font>
		RETURN FORMKCNST(FALSUM)
	ELSIF op=FALSUM <font color="#4169E1">THEN</font>
		RETURN FORMKCNST(VERUM)
	ELSIF op=NON <font color="#4169E1">THEN</font>
		RETURN arg;
	ELSIF (op=VEL) <font color="#4169E1">OR</font> (op=ET) <font color="#4169E1">OR</font> (op=IMP) <font color="#4169E1">OR</font> (op=REP) <font color="#4169E1">OR</font>
		(op=TVAR) <font color="#4169E1">OR</font> (op=EXIST) <font color="#4169E1">OR</font> (op=FORALL) <font color="#4169E1">THEN</font>
		RETURN FORMKUNOP(NON,phi);
	ELSIF op=EQUIV <font color="#4169E1">THEN</font>
		FORPBINOPA(arg,left,right);
		RETURN FORMKBINOP(XOR,left,right);
	ELSIF op=XOR <font color="#4169E1">THEN</font>
		FORPBINOPA(arg,left,right);
		RETURN FORMKBINOP(EQUIV,left,right);
	ELSIF op=TVAR <font color="#4169E1">THEN</font> 
		RETURN FORMKUNOP(NON,phi);
	<font color="#4169E1">ELSE</font>
		RETURN bbmkneg(phi);
	<strong><font color="#4169E1">END</font></strong>;
<strong><font color="#4169E1">END</font></strong> formkneg;


<font color="#B22222">(******************************************************************************
*				   M A I N				      *
******************************************************************************)</font>

<font color="#B22222">(* BEGIN *)</font> <font color="#B22222">(* OF INITIALIZATION *)</font>

<strong><font color="#4169E1">END</font></strong> MASLOG.

<font color="#B22222">(* -EOF- *)</font>
</pre>
</body>

</html>
